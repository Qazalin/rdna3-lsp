{"s_add_u32": {"desc": "Add two unsigned inputs, store the result into a scalar register and store the carry-out bit into SCC.", "code": "tmp = 64'U(S0.u) + 64'U(S1.u);\nSCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// unsigned overflow or carry-out for S_ADDC_U32.\nD0.u = tmp.u", "notes": ""}, "s_sub_u32": {"desc": "Subtract the second unsigned input from the first input, store the result into a scalar register and store the\ncarry-out bit into SCC.", "code": "tmp = S0.u - S1.u;\nSCC = S1.u > S0.u ? 1'1U : 1'0U;\n// unsigned overflow or carry-out for S_SUBB_U32.\nD0.u = tmp.u", "notes": ""}, "s_add_i32": {"desc": "Add two signed inputs, store the result into a scalar register and store the carry-out bit into SCC.", "code": "tmp = S0.i + S1.i;\nSCC = ((S0.u[31] == S1.u[31]) && (S0.u[31] != tmp.u[31]));\n// signed overflow.\nD0.i = tmp.i", "notes": "This opcode is not suitable for use with S_ADDC_U32 for implementing 64-bit operations."}, "s_sub_i32": {"desc": "16.1. SOP2 Instructions 188 of 600\n\"RDNA3\" Instruction Set Architecture\nSubtract the second signed input from the first input, store the result into a scalar register and store the carry-\nout bit into SCC.", "code": "tmp = S0.i - S1.i;\nSCC = ((S0.u[31] != S1.u[31]) && (S0.u[31] != tmp.u[31]));\n// signed overflow.\nD0.i = tmp.i", "notes": "This opcode is not suitable for use with S_SUBB_U32 for implementing 64-bit operations."}, "s_addc_u32": {"desc": "Add two unsigned inputs and a carry-in bit, store the result into a scalar register and store the carry-out bit into\nSCC.", "code": "tmp = 64'U(S0.u) + 64'U(S1.u) + SCC.u64;\nSCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// unsigned overflow.\nD0.u = tmp.u", "notes": ""}, "s_subb_u32": {"desc": "Subtract the second unsigned input from the first input, subtract the carry-in bit, store the result into a scalar\nregister and store the carry-out bit into SCC.", "code": "tmp = S0.u - S1.u - SCC.u;\nSCC = 64'U(S1.u) + SCC.u64 > 64'U(S0.u) ? 1'1U : 1'0U;\n// unsigned overflow.\nD0.u = tmp.u", "notes": ""}, "s_absdiff_i32": {"desc": "Calculate the absolute value of difference between two scalar inputs, store the result into a scalar register and\nset SCC iff the result is nonzero.\n16.1. SOP2 Instructions 189 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.i = S0.i - S1.i;\nif D0.i < 0 then\nD0.i = -D0.i\nendif;\nSCC = D0.i != 0", "notes": "Functional examples:\nS_ABSDIFF_I32(0x00000002, 0x00000005) => 0x00000003\nS_ABSDIFF_I32(0xffffffff, 0x00000000) => 0x00000001\nS_ABSDIFF_I32(0x80000000, 0x00000000) => 0x80000000 // Note: result is negative!\nS_ABSDIFF_I32(0x80000000, 0x00000001) => 0x7fffffff\nS_ABSDIFF_I32(0x80000000, 0xffffffff) => 0x7fffffff\nS_ABSDIFF_I32(0x80000000, 0xfffffffe) => 0x7ffffffe"}, "s_lshl_b32": {"desc": "Given a shift count in the second scalar input, calculate the logical shift left of the first scalar input, store the\nresult into a scalar register and set SCC iff the result is nonzero.", "code": "D0.u = (S0.u << S1.u[4 : 0].u);\nSCC = D0.u != 0U", "notes": ""}, "s_lshl_b64": {"desc": "Given a shift count in the second scalar input, calculate the logical shift left of the first scalar input, store the\nresult into a scalar register and set SCC iff the result is nonzero.", "code": "D0.u64 = (S0.u64 << S1.u[5 : 0].u);\nSCC = D0.u64 != 0ULL", "notes": ""}, "s_lshr_b32": {"desc": "Given a shift count in the second scalar input, calculate the logical shift right of the first scalar input, store the\nresult into a scalar register and set SCC iff the result is nonzero.", "code": "D0.u = (S0.u >> S1.u[4 : 0].u);\nSCC = D0.u != 0U", "notes": ""}, "s_lshr_b64": {"desc": "Given a shift count in the second scalar input, calculate the logical shift right of the first scalar input, store the\nresult into a scalar register and set SCC iff the result is nonzero.\n16.1. SOP2 Instructions 190 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u64 = (S0.u64 >> S1.u[5 : 0].u);\nSCC = D0.u64 != 0ULL", "notes": ""}, "s_ashr_i32": {"desc": "Given a shift count in the second scalar input, calculate the arithmetic shift right (preserving sign bit) of the\nfirst scalar input, store the result into a scalar register and set SCC iff the result is nonzero.", "code": "D0.i = 32'I(signext(S0.i) >> S1.u[4 : 0].u);\nSCC = D0.i != 0", "notes": ""}, "s_ashr_i64": {"desc": "Given a shift count in the second scalar input, calculate the arithmetic shift right (preserving sign bit) of the\nfirst scalar input, store the result into a scalar register and set SCC iff the result is nonzero.", "code": "D0.i64 = (signext(S0.i64) >> S1.u[5 : 0].u);\nSCC = D0.i64 != 0LL", "notes": ""}, "s_lshl1_add_u32": {"desc": "Calculate the logical shift left of the first input by 1, then add the second input, store the result into a scalar\nregister and set SCC iff the summation results in an unsigned overflow.", "code": "tmp = (64'U(S0.u) << 1U) + 64'U(S1.u);\nSCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// unsigned overflow.\nD0.u = tmp.u", "notes": ""}, "s_lshl2_add_u32": {"desc": "Calculate the logical shift left of the first input by 2, then add the second input, store the result into a scalar\nregister and set SCC iff the summation results in an unsigned overflow.\n16.1. SOP2 Instructions 191 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = (64'U(S0.u) << 2U) + 64'U(S1.u);\nSCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// unsigned overflow.\nD0.u = tmp.u", "notes": ""}, "s_lshl3_add_u32": {"desc": "Calculate the logical shift left of the first input by 3, then add the second input, store the result into a scalar\nregister and set SCC iff the summation results in an unsigned overflow.", "code": "tmp = (64'U(S0.u) << 3U) + 64'U(S1.u);\nSCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// unsigned overflow.\nD0.u = tmp.u", "notes": ""}, "s_lshl4_add_u32": {"desc": "Calculate the logical shift left of the first input by 4, then add the second input, store the result into a scalar\nregister and set SCC iff the summation results in an unsigned overflow.", "code": "tmp = (64'U(S0.u) << 4U) + 64'U(S1.u);\nSCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// unsigned overflow.\nD0.u = tmp.u", "notes": ""}, "s_min_i32": {"desc": "Select the minimum of two signed integers, store the selected value into a scalar register and set SCC iff the\nfirst value is selected.", "code": "SCC = S0.i < S1.i;\nD0.i = SCC ? S0.i : S1.i", "notes": ""}, "s_min_u32": {"desc": "Select the minimum of two unsigned integers, store the selected value into a scalar register and set SCC iff the\nfirst value is selected.", "code": "SCC = S0.u < S1.u;\nD0.u = SCC ? S0.u : S1.u", "notes": ""}, "s_max_i32": {"desc": "16.1. SOP2 Instructions 192 of 600\n\"RDNA3\" Instruction Set Architecture\nSelect the maximum of two signed integers, store the selected value into a scalar register and set SCC iff the\nfirst value is selected.", "code": "SCC = S0.i > S1.i;\nD0.i = SCC ? S0.i : S1.i", "notes": ""}, "s_max_u32": {"desc": "Select the maximum of two unsigned integers, store the selected value into a scalar register and set SCC iff the\nfirst value is selected.", "code": "SCC = S0.u > S1.u;\nD0.u = SCC ? S0.u : S1.u", "notes": ""}, "s_and_b32": {"desc": "Calculate bitwise AND on two scalar inputs, store the result into a scalar register and set SCC iff the result is\nnonzero.", "code": "D0.u = (S0.u & S1.u);\nSCC = D0.u != 0U", "notes": ""}, "s_and_b64": {"desc": "Calculate bitwise AND on two scalar inputs, store the result into a scalar register and set SCC iff the result is\nnonzero.", "code": "D0.u64 = (S0.u64 & S1.u64);\nSCC = D0.u64 != 0ULL", "notes": ""}, "s_or_b32": {"desc": "Calculate bitwise OR on two scalar inputs, store the result into a scalar register and set SCC iff the result is\nnonzero.\n16.1. SOP2 Instructions 193 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u = (S0.u | S1.u);\nSCC = D0.u != 0U", "notes": ""}, "s_or_b64": {"desc": "Calculate bitwise OR on two scalar inputs, store the result into a scalar register and set SCC iff the result is\nnonzero.", "code": "D0.u64 = (S0.u64 | S1.u64);\nSCC = D0.u64 != 0ULL", "notes": ""}, "s_xor_b32": {"desc": "Calculate bitwise XOR on two scalar inputs, store the result into a scalar register and set SCC iff the result is\nnonzero.", "code": "D0.u = (S0.u ^ S1.u);\nSCC = D0.u != 0U", "notes": ""}, "s_xor_b64": {"desc": "Calculate bitwise XOR on two scalar inputs, store the result into a scalar register and set SCC iff the result is\nnonzero.", "code": "D0.u64 = (S0.u64 ^ S1.u64);\nSCC = D0.u64 != 0ULL", "notes": ""}, "s_nand_b32": {"desc": "Calculate bitwise NAND on two scalar inputs, store the result into a scalar register and set SCC if the result is\nnonzero.", "code": "D0.u = ~(S0.u & S1.u);\nSCC = D0.u != 0U", "notes": ""}, "s_nand_b64": {"desc": "Calculate bitwise NAND on two scalar inputs, store the result into a scalar register and set SCC if the result is\nnonzero.\n16.1. SOP2 Instructions 194 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u64 = ~(S0.u64 & S1.u64);\nSCC = D0.u64 != 0ULL", "notes": ""}, "s_nor_b32": {"desc": "Calculate bitwise NOR on two scalar inputs, store the result into a scalar register and set SCC if the result is\nnonzero.", "code": "D0.u = ~(S0.u | S1.u);\nSCC = D0.u != 0U", "notes": ""}, "s_nor_b64": {"desc": "Calculate bitwise NOR on two scalar inputs, store the result into a scalar register and set SCC if the result is\nnonzero.", "code": "D0.u64 = ~(S0.u64 | S1.u64);\nSCC = D0.u64 != 0ULL", "notes": ""}, "s_xnor_b32": {"desc": "Calculate bitwise XNOR on two scalar inputs, store the result into a scalar register and set SCC if the result is\nnonzero.", "code": "D0.u = ~(S0.u ^ S1.u);\nSCC = D0.u != 0U", "notes": ""}, "s_xnor_b64": {"desc": "Calculate bitwise XNOR on two scalar inputs, store the result into a scalar register and set SCC if the result is\nnonzero.", "code": "D0.u64 = ~(S0.u64 ^ S1.u64);\nSCC = D0.u64 != 0ULL", "notes": ""}, "s_and_not1_b32": {"desc": "16.1. SOP2 Instructions 195 of 600\n\"RDNA3\" Instruction Set Architecture\nCalculate bitwise AND with the first input and the negation of the second input, store the result into a scalar\nregister and set SCC if the result is nonzero.", "code": "D0.u = (S0.u & ~S1.u);\nSCC = D0.u != 0U", "notes": ""}, "s_and_not1_b64": {"desc": "Calculate bitwise AND with the first input and the negation of the second input, store the result into a scalar\nregister and set SCC if the result is nonzero.", "code": "D0.u64 = (S0.u64 & ~S1.u64);\nSCC = D0.u64 != 0ULL", "notes": ""}, "s_or_not1_b32": {"desc": "Calculate bitwise OR with the first input and the negation of the second input, store the result into a scalar\nregister and set SCC if the result is nonzero.", "code": "D0.u = (S0.u | ~S1.u);\nSCC = D0.u != 0U", "notes": ""}, "s_or_not1_b64": {"desc": "Calculate bitwise OR with the first input and the negation of the second input, store the result into a scalar\nregister and set SCC if the result is nonzero.", "code": "D0.u64 = (S0.u64 | ~S1.u64);\nSCC = D0.u64 != 0ULL", "notes": ""}, "s_bfe_u32": {"desc": "Extract an unsigned bitfield from the first input using field offset and size encoded in the second input, store\nthe result into a scalar register and set SCC iff the result is nonzero.\n16.1. SOP2 Instructions 196 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u = ((S0.u >> S1.u[4 : 0].u) & ((1U << S1.u[22 : 16].u) - 1U));\nSCC = D0.u != 0U", "notes": ""}, "s_bfe_i32": {"desc": "Extract a signed bitfield from the first input using field offset and size encoded in the second input, store the\nresult into a scalar register and set SCC iff the result is nonzero.", "code": "tmp = ((S0.i >> S1.u[4 : 0].u) & ((1 << S1.u[22 : 16].u) - 1));\nD0.i = 32'I(signextFromBit(tmp, S1.i[22 : 16].i));\nSCC = D0.i != 0", "notes": ""}, "s_bfe_u64": {"desc": "Extract an unsigned bitfield from the first input using field offset and size encoded in the second input, store\nthe result into a scalar register and set SCC iff the result is nonzero.", "code": "D0.u64 = ((S0.u64 >> S1.u[5 : 0].u) & ((1ULL << S1.u[22 : 16].u) - 1ULL));\nSCC = D0.u64 != 0ULL", "notes": ""}, "s_bfe_i64": {"desc": "Extract a signed bitfield from the first input using field offset and size encoded in the second input, store the\nresult into a scalar register and set SCC iff the result is nonzero.", "code": "tmp = ((S0.i64 >> S1.u[5 : 0].u) & ((1LL << S1.u[22 : 16].u) - 1LL));\nD0.i64 = signextFromBit(tmp, S1.i[22 : 16].i64);\nSCC = D0.i64 != 0LL", "notes": ""}, "s_bfm_b32": {"desc": "Calculate a bitfield mask given a field offset and size and store the result in a scalar register.", "code": "D0.u = (((1U << S0.u[4 : 0].u) - 1U) << S1.u[4 : 0].u)", "notes": ""}, "s_bfm_b64": {"desc": "Calculate a bitfield mask given a field offset and size and store the result in a scalar register.\n16.1. SOP2 Instructions 197 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u64 = (((1ULL << S0.u[5 : 0].u) - 1ULL) << S1.u[5 : 0].u)", "notes": ""}, "s_mul_i32": {"desc": "Multiply two signed integers and store the result into a scalar register.", "code": "D0.i = S0.i * S1.i", "notes": ""}, "s_mul_hi_u32": {"desc": "Multiply two unsigned integers and store the high 32 bits of the result into a scalar register.", "code": "D0.u = 32'U((64'U(S0.u) * 64'U(S1.u)) >> 32U)", "notes": ""}, "s_mul_hi_i32": {"desc": "Multiply two signed integers and store the high 32 bits of the result into a scalar register.", "code": "D0.i = 32'I((64'I(S0.i) * 64'I(S1.i)) >> 32U)", "notes": ""}, "s_cselect_b32": {"desc": "Select the first input if SCC is true otherwise select the second input, then store the selected input into a scalar\nregister.", "code": "D0.u = SCC ? S0.u : S1.u", "notes": ""}, "s_cselect_b64": {"desc": "Select the first input if SCC is true otherwise select the second input, then store the selected input into a scalar\nregister.", "code": "D0.u64 = SCC ? S0.u64 : S1.u64", "notes": ""}, "s_pack_ll_b32_b16": {"desc": "16.1. SOP2 Instructions 198 of 600\n\"RDNA3\" Instruction Set Architecture\nPack two 16-bit scalar values into a scalar register.", "code": "D0 = { S1[15 : 0].u16, S0[15 : 0].u16 }", "notes": ""}, "s_pack_lh_b32_b16": {"desc": "Pack two 16-bit scalar values into a scalar register.", "code": "D0 = { S1[31 : 16].u16, S0[15 : 0].u16 }", "notes": ""}, "s_pack_hh_b32_b16": {"desc": "Pack two 16-bit scalar values into a scalar register.", "code": "D0 = { S1[31 : 16].u16, S0[31 : 16].u16 }", "notes": ""}, "s_pack_hl_b32_b16": {"desc": "Pack two 16-bit scalar values into a scalar register.\n16.1. SOP2 Instructions 199 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0 = { S1[15 : 0].u16, S0[31 : 16].u16 }", "notes": "Instructions in this format may not use a 32-bit literal constant that occurs immediately after the instruction."}, "s_movk_i32": {"desc": "Sign extend a literal 16-bit constant and store the result into a scalar register.", "code": "D0.i = 32'I(signext(SIMM16.i16))", "notes": ""}, "s_version": {"desc": "Do nothing. This opcode is used to specify the microcode version for tools that interpret shader microcode.\nArgument is ignored by hardware. This opcode is not designed for inserting wait states as the next instruction\nmay issue in the same cycle. Do not use this opcode to resolve wait state hazards, use S_NOP instead.\nThis opcode may also be used to validate microcode is running with the correct compatibility settings in\ndrivers and functional models that support multiple generations. We strongly encourage this opcode be\nincluded at the top of every shader block to simplify debug and catch configuration errors.\nThis opcode must appear in the first 16 bytes of a block of shader code in order to be recognized by external\ntools and functional models. Avoid placing opcodes > 32 bits or encodings that are not available in all versions\nof the microcode before the S_VERSION opcode. If this opcode is absent then tools are allowed to make an\neducated guess of the microcode version using cues from the environment; the guess may be incorrect and\nlead to an invalid decode. It is highly recommended that this be the first opcode of a shader block except for\ntrap handlers, where it should be the second opcode (allowing the first opcode to be a 32-bit branch to\naccommodate context switch).\nSIMM16[7:0] specifies the microcode version.\nSIMM16[15:8] must be set to zero.", "code": "nop();\n// Do nothing - for use by tools only", "notes": ""}, "s_cmovk_i32": {"desc": "Move the sign extension of a literal 16-bit constant into a scalar register iff SCC is nonzero.\n16.2. SOPK Instructions 200 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "if SCC then\nD0.i = 32'I(signext(SIMM16.i16))\nendif", "notes": ""}, "s_cmpk_eq_i32": {"desc": "Set SCC to 1 iff scalar input is equal to the sign extension of a literal 16-bit constant.", "code": "SCC = 64'I(S0.i) == signext(SIMM16.i16)", "notes": ""}, "s_cmpk_lg_i32": {"desc": "Set SCC to 1 iff scalar input is less than or greater than the sign extension of a literal 16-bit constant.", "code": "SCC = 64'I(S0.i) != signext(SIMM16.i16)", "notes": ""}, "s_cmpk_gt_i32": {"desc": "Set SCC to 1 iff scalar input is greater than the sign extension of a literal 16-bit constant.", "code": "SCC = 64'I(S0.i) > signext(SIMM16.i16)", "notes": ""}, "s_cmpk_ge_i32": {"desc": "Set SCC to 1 iff scalar input is greater than or equal to the sign extension of a literal 16-bit constant.", "code": "SCC = 64'I(S0.i) >= signext(SIMM16.i16)", "notes": ""}, "s_cmpk_lt_i32": {"desc": "Set SCC to 1 iff scalar input is less than the sign extension of a literal 16-bit constant.\n16.2. SOPK Instructions 201 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "SCC = 64'I(S0.i) < signext(SIMM16.i16)", "notes": ""}, "s_cmpk_le_i32": {"desc": "Set SCC to 1 iff scalar input is less than or equal to the sign extension of a literal 16-bit constant.", "code": "SCC = 64'I(S0.i) <= signext(SIMM16.i16)", "notes": ""}, "s_cmpk_eq_u32": {"desc": "Set SCC to 1 iff scalar input is equal to the zero extension of a literal 16-bit constant.", "code": "SCC = S0.u == 32'U(SIMM16.u16)", "notes": ""}, "s_cmpk_lg_u32": {"desc": "Set SCC to 1 iff scalar input is less than or greater than the zero extension of a literal 16-bit constant.", "code": "SCC = S0.u != 32'U(SIMM16.u16)", "notes": ""}, "s_cmpk_gt_u32": {"desc": "Set SCC to 1 iff scalar input is greater than the zero extension of a literal 16-bit constant.", "code": "SCC = S0.u > 32'U(SIMM16.u16)", "notes": ""}, "s_cmpk_ge_u32": {"desc": "Set SCC to 1 iff scalar input is greater than or equal to the zero extension of a literal 16-bit constant.", "code": "SCC = S0.u >= 32'U(SIMM16.u16)", "notes": ""}, "s_cmpk_lt_u32": {"desc": "Set SCC to 1 iff scalar input is less than the zero extension of a literal 16-bit constant.\n16.2. SOPK Instructions 202 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "SCC = S0.u < 32'U(SIMM16.u16)", "notes": ""}, "s_cmpk_le_u32": {"desc": "Set SCC to 1 iff scalar input is less than or equal to the zero extension of a literal 16-bit constant.", "code": "SCC = S0.u <= 32'U(SIMM16.u16)", "notes": ""}, "s_addk_i32": {"desc": "Add a scalar input and the sign extension of a literal 16-bit constant, store the result into a scalar register and\nstore the carry-out bit into SCC.", "code": "tmp = D0.i;\n// save value so we can check sign bits for overflow later.\nD0.i = 32'I(64'I(D0.i) + signext(SIMM16.i16));\nSCC = ((tmp[31] == SIMM16.i16[15]) && (tmp[31] != D0.i[31]));\n// signed overflow.", "notes": ""}, "s_mulk_i32": {"desc": "Multiply a scalar input with the sign extension of a literal 16-bit constant and store the result into a scalar\nregister.", "code": "D0.i = 32'I(64'I(D0.i) * signext(SIMM16.i16))", "notes": ""}, "s_getreg_b32": {"desc": "Read some or all of a hardware register into the LSBs of destination.\nThe SIMM16 argument is encoded as follows:\n\"RDNA3\" Instruction Set Architecture", "code": "", "notes": "ID of hardware register to access.\nOFFSET = SIMM16[10:6]\nLSB offset of register bits to access.\n16.2. SOPK Instructions 203 of 600\nSize of register bits to access, minus 1. Set this field to 31 to read/write all bits of the hardware register.\nhwRegId = SIMM16.u16[5 : 0];\noffset = SIMM16.u16[10 : 6];\nsize = SIMM16.u16[15 : 11].u + 1U;\n// logical size is in range 1:32\nvalue = HW_REGISTERS[hwRegId];\nD0.u = 32'U(32'I(value >> offset.u) & ((1 << size) - 1))"}, "s_setreg_b32": {"desc": "Write some or all of the LSBs of source argument into a hardware register.\nThe SIMM16 argument is encoded as follows:", "code": "", "notes": "ID of hardware register to access.\nOFFSET = SIMM16[10:6]\nLSB offset of register bits to access.\nSIZE = SIMM16[15:11]\nSize of register bits to access, minus 1. Set this field to 31 to read/write all bits of the hardware register.\nhwRegId = SIMM16.u16[5 : 0];\noffset = SIMM16.u16[10 : 6];\nsize = SIMM16.u16[15 : 11].u + 1U;\n// logical size is in range 1:32\nmask = (1 << size) - 1;\nmask = (mask & 32'I(writeableBitMask(hwRegId.u, WAVE_STATUS.PRIV)));\n// Mask of bits we are allowed to modify\nvalue = ((S0.u << offset.u) & mask.u);\nvalue = (value | 32'U(HW_REGISTERS[hwRegId].i & ~mask));\nHW_REGISTERS[hwRegId] = value.b;\n// Side-effects may trigger here if certain bits are modified"}, "s_setreg_imm32_b32": {"desc": "Write some or all of the LSBs of a 32-bit literal constant into a hardware register; this instruction requires a 32-\nbit literal constant.\nThe SIMM16 argument is encoded as follows:\n\"RDNA3\" Instruction Set Architecture", "code": "", "notes": "ID of hardware register to access.\n16.2. SOPK Instructions 204 of 600\nLSB offset of register bits to access.\nSIZE = SIMM16[15:11]\nSize of register bits to access, minus 1. Set this field to 31 to read/write all bits of the hardware register.\nhwRegId = SIMM16.u16[5 : 0];\noffset = SIMM16.u16[10 : 6];\nsize = SIMM16.u16[15 : 11].u + 1U;\n// logical size is in range 1:32\nmask = (1 << size) - 1;\nmask = (mask & 32'I(writeableBitMask(hwRegId.u, WAVE_STATUS.PRIV)));\n// Mask of bits we are allowed to modify\nvalue = ((SIMM32.u << offset.u) & mask.u);\nvalue = (value | 32'U(HW_REGISTERS[hwRegId].i & ~mask));\nHW_REGISTERS[hwRegId] = value.b;\n// Side-effects may trigger here if certain bits are modified"}, "s_call_b64": {"desc": "Store the address of the next instruction to a scalar register and then jump to a constant offset relative to the\ncurrent PC.\nThe literal argument is a signed DWORD offset relative to the PC of the next instruction. The byte address of\nthe instruction immediately following this instruction is saved to the destination.", "code": "D0.i64 = PC + 4LL;\nPC = PC + signext(SIMM16.i16 * 16'4) + 4LL", "notes": "This implements a short subroutine call where the return address (the next instruction after the S_CALL_B64)\nis saved to D. Long calls should consider S_SWAPPC_B64 instead.\nThis instruction must be 4 bytes."}, "s_waitcnt_vscnt": {"desc": "Wait for the counts of outstanding vector store events -- vector memory stores and atomics that DO NOT return\ndata -- to be at or below the specified level. This counter is not used in 'all-in-order' mode.\nWaits for the following condition to hold before continuing:\n16.2. SOPK Instructions 205 of 600\n\"RDNA3\" Instruction Set Architecture\nTo wait on a literal constant only, write 'null' for the GPR argument.\nThis opcode may only appear inside a clause if the SGPR operand is set to NULL.\nSee also S_WAITCNT.", "code": "vscnt <= S0.u[5:0] + S1.u[5:0].\n// Comparison is 6 bits, no clamping is applied for add overflow", "notes": ""}, "s_waitcnt_vmcnt": {"desc": "Wait for the counts of outstanding vector memory events -- everything except for memory stores and atomics-\nwithout-return -- to be at or below the specified level. When in 'all-in-order' mode, wait for all vector memory\nevents.\nWaits for the following condition to hold before continuing:\nTo wait on a literal constant only, write 'null' for the GPR argument or use S_WAITCNT.\nThis opcode may only appear inside a clause if the SGPR operand is set to NULL.\nSee also S_WAITCNT.", "code": "vmcnt <= S0.u[5:0] + S1.u[5:0].\n// Comparison is 6 bits, no clamping is applied for add overflow", "notes": ""}, "s_waitcnt_expcnt": {"desc": "Wait for the counts of outstanding export events to be at or below the specified level.\nWaits for the following condition to hold before continuing:\nTo wait on a literal constant only, write 'null' for the GPR argument or use S_WAITCNT.\nThis opcode may only appear inside a clause if the SGPR operand is set to NULL.\nSee also S_WAITCNT.", "code": "expcnt <= S0.u[2:0] + S1.u[2:0].\n// Comparison is 3 bits, no clamping is applied for add overflow", "notes": ""}, "s_waitcnt_lgkmcnt": {"desc": "Wait for the counts of outstanding DS (LG), scalar memory (K) and message (M) events to be at or below the\nspecified level.\nWaits for the following condition to hold before continuing:\n16.2. SOPK Instructions 206 of 600\n\"RDNA3\" Instruction Set Architecture\nTo wait on a literal constant only, write 'null' for the GPR argument or use S_WAITCNT.\nThis opcode may only appear inside a clause if the SGPR operand is set to NULL.\nSee also S_WAITCNT.\n16.2. SOPK Instructions 207 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "lgkmcnt <= S0.u[5:0] + S1.u[5:0].\n// Comparison is 6 bits, no clamping is applied for add overflow", "notes": "Instructions in this format may use a 32-bit literal constant that occurs immediately after the instruction."}, "s_mov_b32": {"desc": "Move scalar input into a scalar register.", "code": "D0.b = S0.b", "notes": ""}, "s_mov_b64": {"desc": "Move scalar input into a scalar register.", "code": "D0.b64 = S0.b64", "notes": ""}, "s_cmov_b32": {"desc": "Move scalar input into a scalar register iff SCC is nonzero.", "code": "if SCC then\nD0.b = S0.b\nendif", "notes": ""}, "s_cmov_b64": {"desc": "Move scalar input into a scalar register iff SCC is nonzero.", "code": "if SCC then\nD0.b64 = S0.b64\nendif", "notes": ""}, "s_brev_b32": {"desc": "16.3. SOP1 Instructions 208 of 600\n\"RDNA3\" Instruction Set Architecture\nReverse the order of bits in a scalar input and store the result into a scalar register.", "code": "D0.u[31 : 0] = S0.u[0 : 31]", "notes": ""}, "s_brev_b64": {"desc": "Reverse the order of bits in a scalar input and store the result into a scalar register.", "code": "D0.u64[63 : 0] = S0.u64[0 : 63]", "notes": ""}, "s_ctz_i32_b32": {"desc": "Count the number of trailing \"0\" bits before the first \"1\" in a scalar input and store the result into a scalar\nregister. Store -1 if there are no \"1\" bits in the input.", "code": "tmp = -1;\n// Set if no ones are found\nfor i in 0 : 31 do\n// Search from LSB\nif S0.u[i] == 1'1U then\ntmp = i;\nbreak\nendif\nendfor;\nD0.i = tmp", "notes": "Functional examples:\nS_CTZ_I32_B32(0xaaaaaaaa) => 1\nS_CTZ_I32_B32(0x55555555) => 0\nS_CTZ_I32_B32(0x00000000) => 0xffffffff\nS_CTZ_I32_B32(0xffffffff) => 0\nS_CTZ_I32_B32(0x00010000) => 16\nCompare with V_CTZ_I32_B32, which performs the equivalent operation in the vector ALU."}, "s_ctz_i32_b64": {"desc": "Count the number of trailing \"0\" bits before the first \"1\" in a scalar input and store the result into a scalar\nregister. Store -1 if there are no \"1\" bits in the input.\n16.3. SOP1 Instructions 209 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = -1;\n// Set if no ones are found\nfor i in 0 : 63 do\n// Search from LSB\nif S0.u64[i] == 1'1U then\ntmp = i;\nbreak\nendif\nendfor;\nD0.i = tmp", "notes": ""}, "s_clz_i32_u32": {"desc": "Count the number of leading \"0\" bits before the first \"1\" in a scalar input and store the result into a scalar\nregister. Store -1 if there are no \"1\" bits.", "code": "tmp = -1;\n// Set if no ones are found\nfor i in 0 : 31 do\n// Search from MSB\nif S0.u[31 - i] == 1'1U then\ntmp = i;\nbreak\nendif\nendfor;\nD0.i = tmp", "notes": "Functional examples:\nS_CLZ_I32_U32(0x00000000) => 0xffffffff\nS_CLZ_I32_U32(0x0000cccc) => 16\nS_CLZ_I32_U32(0xffff3333) => 0\nS_CLZ_I32_U32(0x7fffffff) => 1\nS_CLZ_I32_U32(0x80000000) => 0\nS_CLZ_I32_U32(0xffffffff) => 0\nCompare with V_CLZ_I32_U32, which performs the equivalent operation in the vector ALU."}, "s_clz_i32_u64": {"desc": "Count the number of leading \"0\" bits before the first \"1\" in a scalar input and store the result into a scalar\nregister. Store -1 if there are no \"1\" bits.\n16.3. SOP1 Instructions 210 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = -1;\n// Set if no ones are found\nfor i in 0 : 63 do\n// Search from MSB\nif S0.u64[63 - i] == 1'1U then\ntmp = i;\nbreak\nendif\nendfor;\nD0.i = tmp", "notes": ""}, "s_cls_i32": {"desc": "Count the number of leading bits that are the same as the sign bit of a scalar input and store the result into a\nscalar register. Store -1 if all input bits are the same.", "code": "tmp = -1;\n// Set if all bits are the same\nfor i in 1 : 31 do\n// Search from MSB\nif S0.u[31 - i] != S0.u[31] then\ntmp = i;\nbreak\nendif\nendfor;\nD0.i = tmp", "notes": "Functional examples:\nS_CLS_I32(0x00000000) => 0xffffffff\nS_CLS_I32(0x0000cccc) => 16\nS_CLS_I32(0xffff3333) => 16\nS_CLS_I32(0x7fffffff) => 1\nS_CLS_I32(0x80000000) => 1\nS_CLS_I32(0xffffffff) => 0xffffffff\nCompare with V_CLS_I32, which performs the equivalent operation in the vector ALU."}, "s_cls_i32_i64": {"desc": "Count the number of leading bits that are the same as the sign bit of a scalar input and store the result into a\nscalar register. Store -1 if all input bits are the same.\n16.3. SOP1 Instructions 211 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = -1;\n// Set if all bits are the same\nfor i in 1 : 63 do\n// Search from MSB\nif S0.u64[63 - i] != S0.u64[63] then\ntmp = i;\nbreak\nendif\nendfor;\nD0.i = tmp", "notes": ""}, "s_sext_i32_i8": {"desc": "Sign extend a signed 8 bit scalar input to 32 bits and store the result into a scalar register.", "code": "D0.i = 32'I(signext(S0.i8))", "notes": ""}, "s_sext_i32_i16": {"desc": "Sign extend a signed 16 bit scalar input to 32 bits and store the result into a scalar register.", "code": "D0.i = 32'I(signext(S0.i16))", "notes": ""}, "s_bitset0_b32": {"desc": "Given a bit offset in a scalar input, set the indicated bit in the destination scalar register to 0.", "code": "D0.u[S0.u[4 : 0]] = 1'0U", "notes": ""}, "s_bitset0_b64": {"desc": "Given a bit offset in a scalar input, set the indicated bit in the destination scalar register to 0.", "code": "D0.u64[S0.u[5 : 0]] = 1'0U", "notes": ""}, "s_bitset1_b32": {"desc": "Given a bit offset in a scalar input, set the indicated bit in the destination scalar register to 1.\n16.3. SOP1 Instructions 212 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u[S0.u[4 : 0]] = 1'1U", "notes": ""}, "s_bitset1_b64": {"desc": "Given a bit offset in a scalar input, set the indicated bit in the destination scalar register to 1.", "code": "D0.u64[S0.u[5 : 0]] = 1'1U", "notes": ""}, "s_bitreplicate_b64_b32": {"desc": "Substitute each bit of a 32 bit scalar input with two instances of itself and store the result into a 64 bit scalar\nregister.", "code": "tmp = S0.u;\nfor i in 0 : 31 do\nD0.u64[i * 2 + 0] = tmp[i];\nD0.u64[i * 2 + 1] = tmp[i]\nendfor", "notes": "This opcode can be used to convert a quad mask into a pixel mask; given quad mask in s0, the following\nsequence produces a pixel mask in s2:\ns_bitreplicate_b64 s2, s0\ns_bitreplicate_b64 s2, s2\nTo perform the inverse operation see S_QUADMASK_B64."}, "s_abs_i32": {"desc": "Compute the absolute value of a scalar input, store the result into a scalar register and set SCC iff the result is\nnonzero.\n\"RDNA3\" Instruction Set Architecture", "code": "D0.i = S0.i < 0 ? -S0.i : S0.i;\nSCC = D0.i != 0\nS_ABS_I32(0x00000001) => 0x00000001\nS_ABS_I32(0x7fffffff) => 0x7fffffff\nS_ABS_I32(0x80000000) => 0x80000000 // Note this is negative!\nS_ABS_I32(0x80000001) => 0x7fffffff\nS_ABS_I32(0x80000002) => 0x7ffffffe\nS_ABS_I32(0xffffffff) => 0x00000001", "notes": "Functional examples:\n16.3. SOP1 Instructions 213 of 600"}, "s_bcnt0_i32_b32": {"desc": "Count the number of \"0\" bits in a scalar input, store the result into a scalar register and set SCC iff the result is\nnonzero.", "code": "tmp = 0;\nfor i in 0 : 31 do\ntmp += S0.u[i].u == 0U ? 1 : 0\nendfor;\nD0.i = tmp;\nSCC = D0.u != 0U", "notes": "Functional examples:\nS_BCNT0_I32_B32(0x00000000) => 32\nS_BCNT0_I32_B32(0xcccccccc) => 16\nS_BCNT0_I32_B32(0xffffffff) => 0"}, "s_bcnt0_i32_b64": {"desc": "Count the number of \"0\" bits in a scalar input, store the result into a scalar register and set SCC iff the result is\nnonzero.", "code": "tmp = 0;\nfor i in 0 : 63 do\ntmp += S0.u64[i].u == 0U ? 1 : 0\nendfor;\nD0.i = tmp;\nSCC = D0.u64 != 0ULL", "notes": ""}, "s_bcnt1_i32_b32": {"desc": "Count the number of \"1\" bits in a scalar input, store the result into a scalar register and set SCC iff the result is\n16.3. SOP1 Instructions 214 of 600\n\"RDNA3\" Instruction Set Architecture\nnonzero.", "code": "tmp = 0;\nfor i in 0 : 31 do\ntmp += S0.u[i].u == 1U ? 1 : 0\nendfor;\nD0.i = tmp;\nSCC = D0.u != 0U", "notes": "Functional examples:\nS_BCNT1_I32_B32(0x00000000) => 0\nS_BCNT1_I32_B32(0xcccccccc) => 16\nS_BCNT1_I32_B32(0xffffffff) => 32"}, "s_bcnt1_i32_b64": {"desc": "Count the number of \"1\" bits in a scalar input, store the result into a scalar register and set SCC iff the result is\nnonzero.", "code": "tmp = 0;\nfor i in 0 : 63 do\ntmp += S0.u64[i].u == 1U ? 1 : 0\nendfor;\nD0.i = tmp;\nSCC = D0.u64 != 0ULL", "notes": ""}, "s_quadmask_b32": {"desc": "Reduce a pixel mask from the scalar input into a quad mask, store the result in a scalar register and set SCC iff\nthe result is nonzero.\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = 0U;\nfor i in 0 : 7 do\ntmp[i] = S0.u[i * 4 + 3 : i * 4] != 0U\nendfor;\nD0.u = tmp;\nSCC = D0.u != 0U", "notes": "To perform the inverse operation see S_BITREPLICATE_B64_B32.\n16.3. SOP1 Instructions 215 of 600"}, "s_quadmask_b64": {"desc": "Reduce a pixel mask from the scalar input into a quad mask, store the result in a scalar register and set SCC iff\nthe result is nonzero.", "code": "tmp = 0ULL;\nfor i in 0 : 15 do\ntmp[i] = S0.u64[i * 4 + 3 : i * 4] != 0ULL\nendfor;\nD0.u64 = tmp;\nSCC = D0.u64 != 0ULL", "notes": "To perform the inverse operation see S_BITREPLICATE_B64_B32."}, "s_wqm_b32": {"desc": "Given an active pixel mask in a scalar input, calculate whole quad mode mask for that input, store the result\ninto a scalar register and set SCC iff the result is nonzero.\nIn whole quad mode, if any pixel in a quad is active then all pixels of the quad are marked active.", "code": "tmp = 0U;\ndeclare i : 6'U;\nfor i in 6'0U : 6'31U do\ntmp[i] = S0.u[i | 6'3U : i & 6'60U] != 0U\nendfor;\nD0.u = tmp;\nSCC = D0.u != 0U", "notes": ""}, "s_wqm_b64": {"desc": "Given an active pixel mask in a scalar input, calculate whole quad mode mask for that input, store the result\ninto a scalar register and set SCC iff the result is nonzero.\nIn whole quad mode, if any pixel in a quad is active then all pixels of the quad are marked active.\n16.3. SOP1 Instructions 216 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = 0ULL;\ndeclare i : 6'U;\nfor i in 6'0U : 6'63U do\ntmp[i] = S0.u64[i | 6'3U : i & 6'60U] != 0ULL\nendfor;\nD0.u64 = tmp;\nSCC = D0.u64 != 0ULL", "notes": ""}, "s_not_b32": {"desc": "Calculate bitwise negation on a scalar input, store the result into a scalar register and set SCC iff the result is\nnonzero.", "code": "D0.u = ~S0.u;\nSCC = D0.u != 0U", "notes": ""}, "s_not_b64": {"desc": "Calculate bitwise negation on a scalar input, store the result into a scalar register and set SCC iff the result is\nnonzero.", "code": "D0.u64 = ~S0.u64;\nSCC = D0.u64 != 0ULL", "notes": ""}, "s_and_saveexec_b32": {"desc": "Calculate bitwise AND on the scalar input and the EXEC mask, store the calculated result into the EXEC mask,\nset SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar\ndestination register.\nThe original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.", "code": "saveexec = EXEC.u;\nEXEC.u = (S0.u & EXEC.u);\nD0.u = saveexec.u;\nSCC = EXEC.u != 0U", "notes": ""}, "s_and_saveexec_b64": {"desc": "Calculate bitwise AND on the scalar input and the EXEC mask, store the calculated result into the EXEC mask,\nset SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar\ndestination register.\nThe original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.\n16.3. SOP1 Instructions 217 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "saveexec = EXEC.u64;\nEXEC.u64 = (S0.u64 & EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL", "notes": ""}, "s_or_saveexec_b32": {"desc": "Calculate bitwise OR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set\nSCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination\nregister.\nThe original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.", "code": "saveexec = EXEC.u;\nEXEC.u = (S0.u | EXEC.u);\nD0.u = saveexec.u;\nSCC = EXEC.u != 0U", "notes": ""}, "s_or_saveexec_b64": {"desc": "Calculate bitwise OR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set\nSCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination\nregister.\nThe original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.", "code": "saveexec = EXEC.u64;\nEXEC.u64 = (S0.u64 | EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL", "notes": ""}, "s_xor_saveexec_b32": {"desc": "Calculate bitwise XOR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask,\nset SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar\ndestination register.\nThe original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.\n16.3. SOP1 Instructions 218 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "saveexec = EXEC.u;\nEXEC.u = (S0.u ^ EXEC.u);\nD0.u = saveexec.u;\nSCC = EXEC.u != 0U", "notes": ""}, "s_xor_saveexec_b64": {"desc": "Calculate bitwise XOR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask,\nset SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar\ndestination register.\nThe original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.", "code": "saveexec = EXEC.u64;\nEXEC.u64 = (S0.u64 ^ EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL", "notes": ""}, "s_nand_saveexec_b32": {"desc": "Bitwise NAND with EXEC mask.\nThe original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.", "code": "saveexec = EXEC.u;\nEXEC.u = ~(S0.u & EXEC.u);\nD0.u = saveexec.u;\nSCC = EXEC.u != 0U", "notes": ""}, "s_nand_saveexec_b64": {"desc": "Bitwise NAND with EXEC mask.\nThe original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.", "code": "saveexec = EXEC.u64;\nEXEC.u64 = ~(S0.u64 & EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL", "notes": ""}, "s_nor_saveexec_b32": {"desc": "Bitwise NOR with EXEC mask.\n16.3. SOP1 Instructions 219 of 600\n\"RDNA3\" Instruction Set Architecture\nThe original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.", "code": "saveexec = EXEC.u;\nEXEC.u = ~(S0.u | EXEC.u);\nD0.u = saveexec.u;\nSCC = EXEC.u != 0U", "notes": ""}, "s_nor_saveexec_b64": {"desc": "Bitwise NOR with EXEC mask.\nThe original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.", "code": "saveexec = EXEC.u64;\nEXEC.u64 = ~(S0.u64 | EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL", "notes": ""}, "s_xnor_saveexec_b32": {"desc": "Bitwise XNOR with EXEC mask.\nThe original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.", "code": "saveexec = EXEC.u;\nEXEC.u = ~(S0.u ^ EXEC.u);\nD0.u = saveexec.u;\nSCC = EXEC.u != 0U", "notes": ""}, "s_xnor_saveexec_b64": {"desc": "Bitwise XNOR with EXEC mask.\nThe original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.\n16.3. SOP1 Instructions 220 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "saveexec = EXEC.u64;\nEXEC.u64 = ~(S0.u64 ^ EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL", "notes": ""}, "s_and_not0_saveexec_b32": {"desc": "Calculate bitwise AND on the EXEC mask and the negation of the scalar input, store the calculated result into\nthe EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into\nthe scalar destination register.\nThe original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.", "code": "saveexec = EXEC.u;\nEXEC.u = (~S0.u & EXEC.u);\nD0.u = saveexec.u;\nSCC = EXEC.u != 0U", "notes": ""}, "s_and_not0_saveexec_b64": {"desc": "Calculate bitwise AND on the EXEC mask and the negation of the scalar input, store the calculated result into\nthe EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into\nthe scalar destination register.\nThe original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.", "code": "saveexec = EXEC.u64;\nEXEC.u64 = (~S0.u64 & EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL", "notes": ""}, "s_or_not0_saveexec_b32": {"desc": "Calculate bitwise OR on the EXEC mask and the negation of the scalar input, store the calculated result into the\nEXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the\nscalar destination register.\nThe original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.", "code": "saveexec = EXEC.u;\nEXEC.u = (~S0.u | EXEC.u);\nD0.u = saveexec.u;\nSCC = EXEC.u != 0U", "notes": ""}, "s_or_not0_saveexec_b64": {"desc": "Calculate bitwise OR on the EXEC mask and the negation of the scalar input, store the calculated result into the\nEXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the\n16.3. SOP1 Instructions 221 of 600\n\"RDNA3\" Instruction Set Architecture\nscalar destination register.\nThe original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.", "code": "saveexec = EXEC.u64;\nEXEC.u64 = (~S0.u64 | EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL", "notes": ""}, "s_and_not1_saveexec_b32": {"desc": "Calculate bitwise AND on the scalar input and the negation of the EXEC mask, store the calculated result into\nthe EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into\nthe scalar destination register.\nThe original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.", "code": "saveexec = EXEC.u;\nEXEC.u = (S0.u & ~EXEC.u);\nD0.u = saveexec.u;\nSCC = EXEC.u != 0U", "notes": ""}, "s_and_not1_saveexec_b64": {"desc": "Calculate bitwise AND on the scalar input and the negation of the EXEC mask, store the calculated result into\nthe EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into\nthe scalar destination register.\nThe original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.", "code": "saveexec = EXEC.u64;\nEXEC.u64 = (S0.u64 & ~EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL", "notes": ""}, "s_or_not1_saveexec_b32": {"desc": "Calculate bitwise OR on the scalar input and the negation of the EXEC mask, store the calculated result into the\nEXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the\nscalar destination register.\nThe original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.\n16.3. SOP1 Instructions 222 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "saveexec = EXEC.u;\nEXEC.u = (S0.u | ~EXEC.u);\nD0.u = saveexec.u;\nSCC = EXEC.u != 0U", "notes": ""}, "s_or_not1_saveexec_b64": {"desc": "Calculate bitwise OR on the scalar input and the negation of the EXEC mask, store the calculated result into the\nEXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the\nscalar destination register.\nThe original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.", "code": "saveexec = EXEC.u64;\nEXEC.u64 = (S0.u64 | ~EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL", "notes": ""}, "s_and_not0_wrexec_b32": {"desc": "Calculate bitwise AND on the EXEC mask and the negation of the scalar input, store the calculated result into\nthe EXEC mask and also into the scalar destination register, and set SCC iff the calculated result is nonzero.\nUnlike the SAVEEXEC series of opcodes, the value written to destination SGPRs is the result of the bitwise-op\nresult. EXEC and the destination SGPRs have the same value at the end of this instruction. This instruction is\nintended to help accelerate waterfalling.", "code": "EXEC.u = (~S0.u & EXEC.u);\nD0.u = EXEC.u;\nSCC = EXEC.u != 0U", "notes": ""}, "s_and_not0_wrexec_b64": {"desc": "Calculate bitwise AND on the EXEC mask and the negation of the scalar input, store the calculated result into\nthe EXEC mask and also into the scalar destination register, and set SCC iff the calculated result is nonzero.\nUnlike the SAVEEXEC series of opcodes, the value written to destination SGPRs is the result of the bitwise-op\nresult. EXEC and the destination SGPRs have the same value at the end of this instruction. This instruction is\nintended to help accelerate waterfalling.\n16.3. SOP1 Instructions 223 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "EXEC.u64 = (~S0.u64 & EXEC.u64);\nD0.u64 = EXEC.u64;\nSCC = EXEC.u64 != 0ULL", "notes": ""}, "s_and_not1_wrexec_b32": {"desc": "Calculate bitwise AND on the scalar input and the negation of the EXEC mask, store the calculated result into\nthe EXEC mask and also into the scalar destination register, and set SCC iff the calculated result is nonzero.\nUnlike the SAVEEXEC series of opcodes, the value written to destination SGPRs is the result of the bitwise-op\nresult. EXEC and the destination SGPRs have the same value at the end of this instruction. This instruction is\nintended to help accelerate waterfalling.", "code": "EXEC.u = (S0.u & ~EXEC.u);\nD0.u = EXEC.u;\nSCC = EXEC.u != 0U", "notes": "See S_AND_NOT1_WREXEC_B64 for example code."}, "s_and_not1_wrexec_b64": {"desc": "Calculate bitwise AND on the scalar input and the negation of the EXEC mask, store the calculated result into\nthe EXEC mask and also into the scalar destination register, and set SCC iff the calculated result is nonzero.\nUnlike the SAVEEXEC series of opcodes, the value written to destination SGPRs is the result of the bitwise-op\nresult. EXEC and the destination SGPRs have the same value at the end of this instruction. This instruction is\nintended to help accelerate waterfalling.\n\"RDNA3\" Instruction Set Architecture", "code": "EXEC.u64 = (S0.u64 & ~EXEC.u64);\nD0.u64 = EXEC.u64;\nSCC = EXEC.u64 != 0ULL\nv_cmpx_eq s0, v0\n<OP> // do the operation using the current EXEC mask. S0 holds the index.\n// mask out thread that was just executed\n// s_andn2_b64 s4, s4, exec\n// s_mov_b64 exec, s4\ns_andn2_wrexec_b64 s4, s4 // replaces above 2 ops\n// repeat until EXEC==0\ns_cbranch_scc1 loop\ns_mov_b64 exec, s2", "notes": "In particular, the following sequence of waterfall code is optimized by using a WREXEC instead of two separate\nscalar ops:\n// V0 holds the index value per lane\n// save exec mask for restore at the end\ns_mov_b64 s2, exec\n// exec mask of remaining (unprocessed) threads\ns_mov_b64 s4, exec\nloop:\n// get the index value for the first active lane\nv_readfirstlane_b32 s0, v0\n// find all other lanes with same index value\n16.3. SOP1 Instructions 224 of 600"}, "s_movrels_b32": {"desc": "Move data from a relatively-indexed scalar register into another scalar register.", "code": "addr = SRC0.u;\n// Raw value from instruction\naddr += M0.u[31 : 0];\nD0.b = SGPR[addr].b", "notes": "Example: The following instruction sequence performs the move s5 <= s17:\ns_mov_b32 m0, 10\ns_movrels_b32 s5, s7"}, "s_movrels_b64": {"desc": "Move data from a relatively-indexed scalar register into another scalar register.\nThe index in M0.u and the operand address in SRC0.u must be even for this operation.", "code": "addr = SRC0.u;\n// Raw value from instruction\naddr += M0.u[31 : 0];\nD0.b64 = SGPR[addr].b64", "notes": ""}, "s_movreld_b32": {"desc": "Move data from a scalar input into a relatively-indexed scalar register.\n16.3. SOP1 Instructions 225 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "addr = DST.u;\n// Raw value from instruction\naddr += M0.u[31 : 0];\nSGPR[addr].b = S0.b", "notes": "Example: The following instruction sequence performs the move s15 <= s7:\ns_mov_b32 m0, 10\ns_movreld_b32 s5, s7"}, "s_movreld_b64": {"desc": "Move data from a scalar input into a relatively-indexed scalar register.\nThe index in M0.u and the operand address in DST.u must be even for this operation.", "code": "addr = DST.u;\n// Raw value from instruction\naddr += M0.u[31 : 0];\nSGPR[addr].b64 = S0.b64", "notes": ""}, "s_movrelsd_2_b32": {"desc": "Move data from a relatively-indexed scalar register into another relatively-indexed scalar register, using\ndifferent offsets for each index.\n\"RDNA3\" Instruction Set Architecture", "code": "addrs = SRC0.u;\n// Raw value from instruction\naddrd = DST.u;\n// Raw value from instruction\naddrs += M0.u[9 : 0].u;\naddrd += M0.u[25 : 16].u;\nSGPR[addrd].b = SGPR[addrs].b", "notes": "Example: The following instruction sequence performs the move s25 <= s17:\ns_mov_b32 m0, ((20 << 16) | 10)\ns_movrelsd_2_b32 s5, s7\n16.3. SOP1 Instructions 226 of 600"}, "s_getpc_b64": {"desc": "Store the address of the next instruction to a scalar register.\nThe byte address of the instruction immediately following this instruction is saved to the destination.", "code": "D0.i64 = PC + 4LL", "notes": "This instruction must be 4 bytes."}, "s_setpc_b64": {"desc": "Jump to an address specified in a scalar register.\nThe argument is a byte address of the instruction to jump to.", "code": "PC = S0.i64", "notes": ""}, "s_swappc_b64": {"desc": "Store the address of the next instruction to a scalar register and then jump to an address specified in the scalar\ninput.\nThe argument is a byte address of the instruction to jump to. The byte address of the instruction immediately\n_following this instruction is saved to the destination._", "code": "jump_addr = S0.i64;\nD0.i64 = PC + 4LL;\nPC = jump_addr.i64", "notes": "This instruction must be 4 bytes."}, "s_rfe_b64": {"desc": "Return from the exception handler. Clear the wave's PRIV bit and then jump to an address specified by the\nscalar input.\nThe argument is a byte address of the instruction to jump to; this address is likely derived from the state passed\ninto the trap handler.\n16.3. SOP1 Instructions 227 of 600\n\"RDNA3\" Instruction Set Architecture\nThis instruction may only be used within a trap handler.", "code": "WAVE_STATUS.PRIV = 1'0U;\nPC = S0.i64", "notes": ""}, "s_sendmsg_rtn_b32": {"desc": "Send a message to upstream control hardware.\nSSRC[7:0] contains the message type encoded in the instruction directly (this instruction does not read an\nSGPR). The message is expected to return a response from the upstream control hardware and the result is\nwritten to SDST. Use s_waitcnt lgkmcnt(\u2026) to wait for the response on the dependent instruction.\nS_SENDMSG_RTN* instructions return data in-order among themselves but out-of-order with other\ninstructions that manipulate lgkmcnt (including S_SENDMSG and S_SENDMSGHALT).\nIf the message returns a 64 bit value then only the lower 32 bits are written to SDST.\nIf SDST is VCC then VCCZ is undefined.", "code": "", "notes": ""}, "s_sendmsg_rtn_b64": {"desc": "Send a message to upstream control hardware.\nSSRC[7:0] contains the message type encoded in the instruction directly (this instruction does not read an\nSGPR). The message is expected to return a response from the upstream control hardware and the result is\nwritten to SDST. Use s_waitcnt lgkmcnt(\u2026) to wait for the response on the dependent instruction.\nS_SENDMSG_RTN* instructions return data in-order among themselves but out-of-order with other\ninstructions that manipulate lgkmcnt (including S_SENDMSG and S_SENDMSGHALT).\nIf the message returns a 32 bit value then this instruction fills the upper bits of SDST with zero.\nIf SDST is VCC then VCCZ is undefined.\n16.3. SOP1 Instructions 228 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "", "notes": "Instructions in this format may use a 32-bit literal constant that occurs immediately after the instruction."}, "s_cmp_eq_i32": {"desc": "Set SCC to 1 iff the first scalar input is equal to the second scalar input.", "code": "SCC = S0.i == S1.i", "notes": "Note that S_CMP_EQ_I32 and S_CMP_EQ_U32 are identical opcodes, but both are provided for symmetry."}, "s_cmp_lg_i32": {"desc": "Set SCC to 1 iff the first scalar input is less than or greater than the second scalar input.", "code": "SCC = S0.i <> S1.i", "notes": "Note that S_CMP_LG_I32 and S_CMP_LG_U32 are identical opcodes, but both are provided for symmetry."}, "s_cmp_gt_i32": {"desc": "Set SCC to 1 iff the first scalar input is greater than the second scalar input.", "code": "SCC = S0.i > S1.i", "notes": ""}, "s_cmp_ge_i32": {"desc": "Set SCC to 1 iff the first scalar input is greater than or equal to the second scalar input.\n16.4. SOPC Instructions 229 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "SCC = S0.i >= S1.i", "notes": ""}, "s_cmp_lt_i32": {"desc": "Set SCC to 1 iff the first scalar input is less than the second scalar input.", "code": "SCC = S0.i < S1.i", "notes": ""}, "s_cmp_le_i32": {"desc": "Set SCC to 1 iff the first scalar input is less than or equal to the second scalar input.", "code": "SCC = S0.i <= S1.i", "notes": ""}, "s_cmp_eq_u32": {"desc": "Set SCC to 1 iff the first scalar input is equal to the second scalar input.", "code": "SCC = S0.u == S1.u", "notes": "Note that S_CMP_EQ_I32 and S_CMP_EQ_U32 are identical opcodes, but both are provided for symmetry."}, "s_cmp_lg_u32": {"desc": "Set SCC to 1 iff the first scalar input is less than or greater than the second scalar input.", "code": "SCC = S0.u <> S1.u", "notes": "Note that S_CMP_LG_I32 and S_CMP_LG_U32 are identical opcodes, but both are provided for symmetry."}, "s_cmp_gt_u32": {"desc": "Set SCC to 1 iff the first scalar input is greater than the second scalar input.\n16.4. SOPC Instructions 230 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "SCC = S0.u > S1.u", "notes": ""}, "s_cmp_ge_u32": {"desc": "Set SCC to 1 iff the first scalar input is greater than or equal to the second scalar input.", "code": "SCC = S0.u >= S1.u", "notes": ""}, "s_cmp_lt_u32": {"desc": "Set SCC to 1 iff the first scalar input is less than the second scalar input.", "code": "SCC = S0.u < S1.u", "notes": ""}, "s_cmp_le_u32": {"desc": "Set SCC to 1 iff the first scalar input is less than or equal to the second scalar input.", "code": "SCC = S0.u <= S1.u", "notes": ""}, "s_bitcmp0_b32": {"desc": "Extract a bit from the first scalar input based on an index in the second scalar input, and set SCC to 1 iff the\nextracted bit is equal to 0.", "code": "SCC = S0.u[S1.u[4 : 0]] == 1'0U", "notes": ""}, "s_bitcmp1_b32": {"desc": "Extract a bit from the first scalar input based on an index in the second scalar input, and set SCC to 1 iff the\nextracted bit is equal to 1.", "code": "SCC = S0.u[S1.u[4 : 0]] == 1'1U", "notes": ""}, "s_bitcmp0_b64": {"desc": "16.4. SOPC Instructions 231 of 600\n\"RDNA3\" Instruction Set Architecture\nExtract a bit from the first scalar input based on an index in the second scalar input, and set SCC to 1 iff the\nextracted bit is equal to 0.", "code": "SCC = S0.u64[S1.u[5 : 0]] == 1'0U", "notes": ""}, "s_bitcmp1_b64": {"desc": "Extract a bit from the first scalar input based on an index in the second scalar input, and set SCC to 1 iff the\nextracted bit is equal to 1.", "code": "SCC = S0.u64[S1.u[5 : 0]] == 1'1U", "notes": ""}, "s_cmp_eq_u64": {"desc": "Set SCC to 1 iff the first scalar input is equal to the second scalar input.", "code": "SCC = S0.u64 == S1.u64", "notes": ""}, "s_cmp_lg_u64": {"desc": "Set SCC to 1 iff the first scalar input is less than or greater than the second scalar input.\n16.4. SOPC Instructions 232 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "SCC = S0.u64 <> S1.u64", "notes": ""}, "s_nop": {"desc": "Do nothing. Delay issue of next instruction by a small, fixed amount.\nInsert 0..15 wait states based on SIMM16[3:0]. 0x0 means the next instruction can issue on the next clock, 0xf\nmeans the next instruction can issue 16 clocks later.", "code": "for i in 0U : SIMM16.u16[3 : 0].u do\nnop()\nendfor", "notes": "Examples:\ns_nop 0 // Wait 1 cycle.\ns_nop 0xf // Wait 16 cycles."}, "s_setkill": {"desc": "Kill this wave if the least significant bit of the immediate constant is 1.\nUsed primarily for debugging kill wave host command behavior.", "code": "", "notes": ""}, "s_sethalt": {"desc": "Set or clear the HALT or FATAL_HALT status bits.\nThe particular status bit is chosen by halt type control as indicated in SIMM16[2]; 0 = HALT bit select; 1 =\nFATAL_HALT bit select.\nWhen halt type control is set to 0 (HALT bit select): Set HALT bit to value of SIMM16[0]; 1 = halt, 0 = clear HALT\nbit. The halt flag is ignored while PRIV == 1 (inside trap handlers) but the shader halts after the handler returns\nif HALT is still set at that time.\nWhen halt type control is set to 1 (FATAL HALT bit select): Set FATAL_HALT bit to value of SIMM16[0]; 1 =\nfatal_halt, 0 = clear FATAL_HALT bit. Setting the fatal_halt flag halts the shader in or outside of the trap\nhandlers.\n16.5. SOPP Instructions 233 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "", "notes": ""}, "s_sleep": {"desc": "Cause a wave to sleep for up to ~8000 clocks.\nThe wave sleeps for (64*(SIMM16[6:0]-1) .. 64*SIMM16[6:0]) clocks. The exact amount of delay is approximate.\nCompare with S_NOP. When SIMM16[6:0] is zero then no sleep occurs.", "code": "", "notes": "Examples:\ns_sleep 0 // Wait for 0 clocks.\ns_sleep 1 // Wait for 1-64 clocks.\ns_sleep 2 // Wait for 65-128 clocks."}, "s_set_inst_prefetch_distance": {"desc": "Change instruction prefetch mode. This controls how many cachelines ahead of the current PC the shader will\ntry to prefetch.\nSIMM16[1:0] specifies the prefetch mode to switch to. Prefetch modes are:", "code": "", "notes": ""}, "prefetch_safe": {"desc": "Reserved, do not use.", "code": "", "notes": ""}, "prefetch_1_line": {"desc": "Prefetch 1 cache line ahead of PC; keep 2 lines behind PC.", "code": "", "notes": ""}, "prefetch_2_lines": {"desc": "Prefetch 2 cache lines ahead of PC; keep 1 line behind PC.", "code": "", "notes": ""}, "prefetch_3_lines": {"desc": "Prefetch 3 cache lines ahead of PC; keep 0 lines behind PC.\nSIMM16[15:2] must be set to zero.", "code": "", "notes": ""}, "s_clause": {"desc": "Mark the beginning of a clause.\nThe next instruction determines the clause type, which may be one of the following types.\n\u2022 Image Load (non-sample instructions )\n\u2022 Image Sample\n\u2022 Image Store\n\u2022 Image Atomic\n16.5. SOPP Instructions 234 of 600\n\"RDNA3\" Instruction Set Architecture\n\u2022 Buffer/Global/Scratch Load\n\u2022 Buffer/Global/Scratch Store\n\u2022 Buffer/Global/Scratch Atomic\n\u2022 Flat Load\n\u2022 Flat Store\n\u2022 Flat Atomic\n\u2022 LDS (loads, stores, atomics may be in same clause)\n\u2022 Scalar Memory\n\u2022 Vector ALU\nOnce the clause type is determined, any instruction encountered within the clause that is not of the same type\n(and not an internal instruction described below) is illegal and may lead to undefined behaviour. Attempting to\nissue S_CLAUSE while inside a clause is also illegal.\nInstructions that are processed internally do not interrupt the clause. The following instructions are internal:\n\u2022 S_NOP,\n\u2022 S_WAITCNT and its variants, unless they read an SGPR,\n\u2022 S_SLEEP,\n\u2022 S_DELAY_ALU.\nHalting or killing a wave breaks the clause. VALU exceptions and other traps that cause the shader to enter its\ntrap handler breaks the clause. The single-step debug mode breaks the clause.\nThe clause length must be between 2 and 63 instructions, inclusive. Clause breaks may be from 1 to 15, or may\nbe disabled entirely. Clause length and breaks are encoded in the SIMM16 argument as follows:\n\"RDNA3\" Instruction Set Architecture\ndetermine the clause type.\nS_DELAY_ALU must not appear inside a clause. The features are orthogonal; ALU clauses should be structured\nto avoid any stalling.", "code": "", "notes": "This field is set to the logical number of instructions in the clause, minus 1 (e.g. if a clause has 4\ninstructions, program this field to 3). The minimum number of instructions required for a clause is 2 and\nthe maximum number of instructions is 63, therefore this field must be programmed in the range [1, 62]\ninclusive.\nBREAK_SPAN = SIMM16[11:8]\nThis field is set to the number of instructions to issue before each clause break. If set to zero then there are\nno clause breaks. If set to nonzero value then the maximum number of instructions between clause breaks\nis 15.\nThe following instruction types cannot appear in a clause:\n\u2022 SALU\n\u2022 Export\n\u2022 Branch\n\u2022 Message\n\u2022 LDSDIR\n\u2022 VINTERP\n\u2022 GDS\nTo schedule an S_WAITCNT or S_DELAY_ALU instruction for the first instruction in the clause, the\nwaitcnt/delay instruction must appear before the S_CLAUSE instruction so that S_CLAUSE can accurately\n16.5. SOPP Instructions 235 of 600"}, "s_delay_alu": {"desc": "Insert delay between dependent SALU/VALU instructions.\nThe SIMM16 argument is encoded as:", "code": "", "notes": "Hazard to delay for with the next VALU instruction.\nINSTSKIP = SIMM16[6:4]\nIdentify the VALU instruction that the second delay condition applies to.\nINSTID1 = SIMM16[10:7]\nHazard to delay for with the VALU instruction identified by INSTSKIP.\nLegal values for the InstID0 and InstID1 fields are:"}, "instid_no_dep": {"desc": "No dependency on any prior instruction.", "code": "", "notes": ""}, "instid_valu_dep_1": {"desc": "Dependent on previous VALU instruction, 1 instruction back.", "code": "", "notes": ""}, "instid_valu_dep_2": {"desc": "Dependent on previous VALU instruction, 2 instructions back.", "code": "", "notes": ""}, "instid_valu_dep_3": {"desc": "Dependent on previous VALU instruction, 3 instructions back.", "code": "", "notes": ""}, "instid_valu_dep_4": {"desc": "Dependent on previous VALU instruction, 4 instructions back.", "code": "", "notes": ""}, "instid_trans32_dep_1": {"desc": "Dependent on previous TRANS32 instruction, 1 instruction back.", "code": "", "notes": ""}, "instid_trans32_dep_2": {"desc": "Dependent on previous TRANS32 instruction, 2 instructions back.", "code": "", "notes": ""}, "instid_trans32_dep_3": {"desc": "Dependent on previous TRANS32 instruction, 3 instructions back.", "code": "", "notes": ""}, "instid_fma_accum_cycle_1": {"desc": "Single cycle penalty for FMA accumulation (reserved).\n16.5. SOPP Instructions 236 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "", "notes": ""}, "instid_salu_cycle_1": {"desc": "1 cycle penalty for a prior SALU instruction.", "code": "", "notes": ""}, "instid_salu_cycle_2": {"desc": "2 cycle penalty for a prior SALU instruction (reserved).", "code": "", "notes": ""}, "instid_salu_cycle_3": {"desc": "3 cycle penalty for a prior SALU instruction (reserved).\nLegal values for the InstSkip field are:", "code": "", "notes": ""}, "instskip_same": {"desc": "Apply second dependency to same instruction (2 dependencies on one instruction).", "code": "", "notes": ""}, "instskip_next": {"desc": "Apply second dependency to next instruction (no skip).", "code": "", "notes": ""}, "instskip_skip_1": {"desc": "Skip 1 instruction then apply dependency.", "code": "", "notes": ""}, "instskip_skip_2": {"desc": "Skip 2 instructions then apply dependency.", "code": "", "notes": ""}, "instskip_skip_3": {"desc": "Skip 3 instructions then apply dependency.", "code": "", "notes": ""}, "instskip_skip_4": {"desc": "Skip 4 instructions then apply dependency.\nThis instruction describes dependencies for two instructions, directing the hardware to insert delay if the\ndependent instruction was issued too recently to forward data to the second.\nS_DELAY_ALU instructions record the required delay with respect to a previous VALU instruction and indicate\ndata dependencies that benefit from having extra idle cycles inserted between them. These instructions are\noptional: without them the program still functions correctly but performance may suffer when multiple waves\nare in flight; IB may issue dependent instructions that stall in the ALU, preventing those cycles from being\nutilized by other wavefronts.\nIf enough independent instructions are between dependent ones then no delay is necessary and this\ninstruction may be omitted. For wave64 the compiler may not know the status of the EXEC mask and hence\ndoes not know if instructions require 1 or 2 passes to issue. S_DELAY_ALU encodes the type of dependency so\nthat hardware may apply the correct delay depending on the number of active passes.\nS_DELAY_ALU may execute in zero cycles.\nTo reduce instruction stream overhead the S_DELAY_ALU instructions packs two delay values into one\ninstruction, with a \"skip\" indicator so the two delayed instructions don't need to be back-to-back.\nS_DELAY_ALU is illegal inside of a clause created by S_CLAUSE.\nExample:\n16.5. SOPP Instructions 237 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "v_mov_b32 v3, v0\nv_lshlrev_b32 v30, 1, v31\nv_lshlrev_b32 v24, 1, v25\ns_delay_alu instid0(INSTID_VALU_DEP_3) | instskip(INSTSKIP_SKIP_1) | instid1(INSTID_VALU_DEP_1)\n// 1 cycle delay here\nv_add_f32 v0, v1, v3\nv_sub_f32 v11, v9, v9\n// 2 cycles delay here\nv_mul_f32 v10, v13, v11", "notes": ""}, "s_waitcnt": {"desc": "Wait for the counts of outstanding lds, vector-memory and export/vmem-write-data to be at or below the\nspecified levels.\nThe SIMM16 argument is encoded as:", "code": "", "notes": "Export wait count. 0x7 means do not wait on EXPCNT.\nLGKM = SIMM16[9:4]\nLGKM wait count. 0x3f means do not wait on LGKMCNT.\nVM = SIMM16[15:10]\nVM wait count. 0x3f means do not wait on VMCNT.\nWaits for all of the following conditions to hold before continuing:\nexpcnt <= WaitEXPCNT\nlgkmcnt <= WaitLGKMCNT\nvmcnt <= WaitVMCNT\nVMCNT only counts vector memory loads, image sample instructions, and vector memory atomics that return\ndata. Contrast with the VSCNT counter.\nSee also S_WAITCNT_VSCNT."}, "s_wait_idle": {"desc": "Wait for all activity in the wave to be complete (all dependency and memory counters at zero).", "code": "", "notes": ""}, "s_wait_event": {"desc": "Wait for an event to occur or a condition to be satisfied before continuing. The SIMM16 argument specifies\n16.5. SOPP Instructions 238 of 600\n\"RDNA3\" Instruction Set Architecture\nwhich event(s) to wait on.", "code": "", "notes": "If this value is ZERO then sleep until the export_ready bit is 1. If the export_ready bit is already 1, no sleep\noccurs. Effect is the same as the export_ready check performed before issuing an export instruction.\nNo wait occurs if this value is ONE.\nThis wait can be broken or preempted by KILL, context-save, host trap, single-step or trap after instruction\nevents. IB waits for the event to occur before processing internal exceptions which can delay entry to the trap\nhandler for a significant amount of time."}, "s_trap": {"desc": "Enter the trap handler.\nThis instruction may be generated internally as well in response to a host trap (HT = 1) or an exception. TrapID\n0 is reserved for hardware use and should not be used in a shader-generated trap.", "code": "TrapID = SIMM16.u16[7 : 0];\n\"Wait for all instructions to complete\";\n// PC passed into trap handler points to S_TRAP itself,\n// *not* to the next instruction.\n{ TTMP[1], TTMP[0] } = { 7'0, HT[0], TrapID[7 : 0], PC[47 : 0] };\nPC = TBA.i64;\n// trap base address\nWAVE_STATUS.PRIV = 1'1U", "notes": ""}, "s_round_mode": {"desc": "Set floating point round mode using an immediate constant.\nAvoids wait state penalty that would be imposed by S_SETREG.", "code": "", "notes": ""}, "s_denorm_mode": {"desc": "Set floating point denormal mode using an immediate constant.\nAvoids wait state penalty that would be imposed by S_SETREG.", "code": "", "notes": ""}, "s_code_end": {"desc": "Generate an illegal instruction interrupt. This instruction is used to mark the end of a shader buffer for debug\ntools.\n16.5. SOPP Instructions 239 of 600\n\"RDNA3\" Instruction Set Architecture\nThis instruction should not appear in typical shader code. It is used to pad the end of a shader program to make\nit easier for analysis programs to locate the end of a shader program buffer. Use of this opcode in an embedded\nshader block may cause analysis tools to fail.\nTo unambiguously mark the end of a shader buffer, this instruction must be specified five times in a row (total\nof 20 bytes) and analysis tools must ensure the opcode occurs at least five times to be certain they are at the end\nof the buffer. This is because the bit pattern generated by this opcode could incidentally appear in a valid\ninstruction's second dword, literal constant or as part of a multi-DWORD image instruction.\nIn short: do not embed this opcode in the middle of a valid shader program. DO use this opcode 5 times at the\nend of a shader program to clearly mark the end of the program.\nExample:", "code": "...\ns_endpgm // last real instruction in shader buffer\ns_code_end // 1\ns_code_end // 2\ns_code_end // 3\ns_code_end // 4\ns_code_end // done!", "notes": ""}, "s_branch": {"desc": "Jump to a constant offset relative to the current PC.\nThe literal argument is a signed DWORD offset relative to the PC of the next instruction.", "code": "PC = PC + signext(SIMM16.i16 * 16'4) + 4LL;\n// short jump.", "notes": "For a long jump or an indirect jump use S_SETPC_B64.\nExamples:\ns_branch label // Set SIMM16 = +4 = 0x0004\ns_nop 0 // 4 bytes\nlabel:\ns_nop 0 // 4 bytes\ns_branch label // Set SIMM16 = -8 = 0xfff8"}, "s_cbranch_scc0": {"desc": "16.5. SOPP Instructions 240 of 600\n\"RDNA3\" Instruction Set Architecture\nIf SCC is 0 then jump to a constant offset relative to the current PC.\nThe literal argument is a signed DWORD offset relative to the PC of the next instruction.", "code": "if SCC == 1'0U then\nPC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nPC = PC + 4LL\nendif", "notes": ""}, "s_cbranch_scc1": {"desc": "If SCC is 1 then jump to a constant offset relative to the current PC.\nThe literal argument is a signed DWORD offset relative to the PC of the next instruction.", "code": "if SCC == 1'1U then\nPC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nPC = PC + 4LL\nendif", "notes": ""}, "s_cbranch_vccz": {"desc": "If VCCZ is 1 then jump to a constant offset relative to the current PC.\nThe literal argument is a signed DWORD offset relative to the PC of the next instruction.", "code": "if VCCZ.u1 == 1'1U then\nPC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nPC = PC + 4LL\nendif", "notes": ""}, "s_cbranch_vccnz": {"desc": "If VCCZ is 0 then jump to a constant offset relative to the current PC.\nThe literal argument is a signed DWORD offset relative to the PC of the next instruction.\n16.5. SOPP Instructions 241 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "if VCCZ.u1 == 1'0U then\nPC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nPC = PC + 4LL\nendif", "notes": ""}, "s_cbranch_execz": {"desc": "If EXECZ is 1 then jump to a constant offset relative to the current PC.\nThe literal argument is a signed DWORD offset relative to the PC of the next instruction.", "code": "if EXECZ.u1 == 1'1U then\nPC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nPC = PC + 4LL\nendif", "notes": ""}, "s_cbranch_execnz": {"desc": "If EXECZ is 0 then jump to a constant offset relative to the current PC.\nThe literal argument is a signed DWORD offset relative to the PC of the next instruction.", "code": "if EXECZ.u1 == 1'0U then\nPC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nPC = PC + 4LL\nendif", "notes": ""}, "s_cbranch_cdbgsys": {"desc": "If the system debug flag is set then jump to a constant offset relative to the current PC.\nThe literal argument is a signed DWORD offset relative to the PC of the next instruction.", "code": "if WAVE_STATUS.COND_DBG_SYS.u != 0U then\nPC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nPC = PC + 4LL\nendif", "notes": ""}, "s_cbranch_cdbguser": {"desc": "16.5. SOPP Instructions 242 of 600\n\"RDNA3\" Instruction Set Architecture\nIf the user debug flag is set then jump to a constant offset relative to the current PC.\nThe literal argument is a signed DWORD offset relative to the PC of the next instruction.", "code": "if WAVE_STATUS.COND_DBG_USER.u != 0U then\nPC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nPC = PC + 4LL\nendif", "notes": ""}, "s_cbranch_cdbgsys_or_user": {"desc": "If either the system debug flag or the user debug flag is set then jump to a constant offset relative to the current\nPC.\nThe literal argument is a signed DWORD offset relative to the PC of the next instruction.", "code": "if (WAVE_STATUS.COND_DBG_SYS || WAVE_STATUS.COND_DBG_USER) then\nPC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nPC = PC + 4LL\nendif", "notes": ""}, "s_cbranch_cdbgsys_and_user": {"desc": "If both the system debug flag and the user debug flag are set then jump to a constant offset relative to the\ncurrent PC.\nThe literal argument is a signed DWORD offset relative to the PC of the next instruction.", "code": "if (WAVE_STATUS.COND_DBG_SYS && WAVE_STATUS.COND_DBG_USER) then\nPC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nPC = PC + 4LL\nendif", "notes": ""}, "s_endpgm": {"desc": "End of program; terminate wavefront.\nThe hardware implicitly executes S_WAITCNT 0 and S_WAITCNT_VSCNT 0 before executing this instruction.\nSee S_ENDPGM_SAVED for the context-switch version of this instruction and\nS_ENDPGM_ORDERED_PS_DONE for the POPS critical region version of this instruction.\n16.5. SOPP Instructions 243 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "", "notes": ""}, "s_endpgm_saved": {"desc": "End of program; signal that a wave has been saved by the context-switch trap handler and terminate\nwavefront.\nThe hardware implicitly executes S_WAITCNT 0 and S_WAITCNT_VSCNT 0 before executing this instruction.\nSee S_ENDPGM for additional variants.", "code": "", "notes": ""}, "s_endpgm_ordered_ps_done": {"desc": "End of program; signal that a wave has exited its POPS critical section and terminate wavefront.\nThe hardware implicitly executes S_WAITCNT 0 and S_WAITCNT_VSCNT 0 before executing this instruction.\nThis instruction is an optimization that combines S_SENDMSG(MSG_ORDERED_PS_DONE) and S_ENDPGM;\nthere may be cases where the message needs to be sent separately, in which case the shader can be terminated\nwith a normal S_ENDPGM instruction.\nSee S_ENDPGM for additional variants.", "code": "", "notes": ""}, "s_wakeup": {"desc": "Allow a wave to 'ping' all the other waves in its threadgroup to force them to wake up early from an S_SLEEP\ninstruction.\nThe ping is ignored if the waves are not sleeping. This allows for efficient polling on a memory location. The\nwaves which are polling can sit in a long S_SLEEP between memory reads, but the wave which writes the value\ncan tell them all to wake up early now that the data is available. This method is also safe from races because if\nany wave misses the ping, everything is expected to work fine (waves which missed it just complete their\nS_SLEEP).\nIf the wave executing S_WAKEUP is in a threadgroup (in_wg set), then it wakes up all waves associated with the\nsame threadgroup ID. Otherwise, S_WAKEUP is treated as an S_NOP.", "code": "", "notes": ""}, "s_setprio": {"desc": "Change wave user priority.\nUser settable wave priority is set to SIMM16[1:0]. 0 is the lowest priority and 3 is the highest. The overall wave\npriority is:\nThe system priority cannot be modified from within the wave.\n16.5. SOPP Instructions 244 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "Priority = {SysUserPrio[1:0], WaveAge[3:0]}\nSysUserPrio = MIN(3, SysPrio[1:0] + UserPrio[1:0]).", "notes": ""}, "s_sendmsg": {"desc": "Send a message to upstream control hardware.\nSIMM16[7:0] contains the message type.", "code": "", "notes": ""}, "s_sendmsghalt": {"desc": "Send a message to upstream control hardware and then HALT the wavefront; see S_SENDMSG for details.", "code": "", "notes": ""}, "s_incperflevel": {"desc": "Increment performance counter specified in SIMM16[3:0] by 1.", "code": "", "notes": ""}, "s_decperflevel": {"desc": "Decrement performance counter specified in SIMM16[3:0] by 1.", "code": "", "notes": ""}, "s_icache_inv": {"desc": "Invalidate entire first level instruction cache.", "code": "", "notes": ""}, "s_barrier": {"desc": "Synchronize waves within a threadgroup.\nIf not all waves of the threadgroup have been created yet, waits for entire group before proceeding. If some\nwaves in the threadgroup have already terminated, this waits on only the surviving waves. Barriers are legal\ninside trap handlers.\nBarrier instructions do not wait for any counters to go to zero before issuing. If the barrier is being used to\nprotect an outstanding memory operation use the appropriate S_WAITCNT instruction before the barrier.\n16.5. SOPP Instructions 245 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "", "notes": ""}, "s_load_b32": {"desc": "Load 32 bits of data from the scalar data cache into a scalar register.", "code": "SDATA[31 : 0] = MEM[ADDR + 0U].b", "notes": "If the offset is specified as an SGPR, the SGPR contains an UNSIGNED BYTE offset (the 2 LSBs are ignored).\nIf the offset is specified as an immediate 21-bit constant, the constant is a SIGNED BYTE offset."}, "s_load_b64": {"desc": "Load 64 bits of data from the scalar data cache into a scalar register.", "code": "SDATA[31 : 0] = MEM[ADDR + 0U].b;\nSDATA[63 : 32] = MEM[ADDR + 4U].b", "notes": "See S_LOAD_B32 for details on the offset input."}, "s_load_b128": {"desc": "Load 128 bits of data from the scalar data cache into a scalar register.\n\"RDNA3\" Instruction Set Architecture", "code": "SDATA[31 : 0] = MEM[ADDR + 0U].b;\nSDATA[63 : 32] = MEM[ADDR + 4U].b;\nSDATA[95 : 64] = MEM[ADDR + 8U].b;\nSDATA[127 : 96] = MEM[ADDR + 12U].b", "notes": "See S_LOAD_B32 for details on the offset input.\n16.6. SMEM Instructions 246 of 600"}, "s_load_b256": {"desc": "Load 256 bits of data from the scalar data cache into a scalar register.", "code": "SDATA[31 : 0] = MEM[ADDR + 0U].b;\nSDATA[63 : 32] = MEM[ADDR + 4U].b;\nSDATA[95 : 64] = MEM[ADDR + 8U].b;\nSDATA[127 : 96] = MEM[ADDR + 12U].b;\nSDATA[159 : 128] = MEM[ADDR + 16U].b;\nSDATA[191 : 160] = MEM[ADDR + 20U].b;\nSDATA[223 : 192] = MEM[ADDR + 24U].b;\nSDATA[255 : 224] = MEM[ADDR + 28U].b", "notes": "See S_LOAD_B32 for details on the offset input."}, "s_load_b512": {"desc": "Load 512 bits of data from the scalar data cache into a scalar register.", "code": "SDATA[31 : 0] = MEM[ADDR + 0U].b;\nSDATA[63 : 32] = MEM[ADDR + 4U].b;\nSDATA[95 : 64] = MEM[ADDR + 8U].b;\nSDATA[127 : 96] = MEM[ADDR + 12U].b;\nSDATA[159 : 128] = MEM[ADDR + 16U].b;\nSDATA[191 : 160] = MEM[ADDR + 20U].b;\nSDATA[223 : 192] = MEM[ADDR + 24U].b;\nSDATA[255 : 224] = MEM[ADDR + 28U].b;\nSDATA[287 : 256] = MEM[ADDR + 32U].b;\nSDATA[319 : 288] = MEM[ADDR + 36U].b;\nSDATA[351 : 320] = MEM[ADDR + 40U].b;\nSDATA[383 : 352] = MEM[ADDR + 44U].b;\nSDATA[415 : 384] = MEM[ADDR + 48U].b;\nSDATA[447 : 416] = MEM[ADDR + 52U].b;\nSDATA[479 : 448] = MEM[ADDR + 56U].b;\nSDATA[511 : 480] = MEM[ADDR + 60U].b", "notes": "See S_LOAD_B32 for details on the offset input."}, "s_buffer_load_b32": {"desc": "Load 32 bits of data from the scalar data cache into a scalar register using a buffer resource descriptor.\n16.6. SMEM Instructions 247 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "SDATA[31 : 0] = MEM[ADDR + 0U].b", "notes": "See S_LOAD_B32 for details on the offset input."}, "s_buffer_load_b64": {"desc": "Load 64 bits of data from the scalar data cache into a scalar register using a buffer resource descriptor.", "code": "SDATA[31 : 0] = MEM[ADDR + 0U].b;\nSDATA[63 : 32] = MEM[ADDR + 4U].b", "notes": "See S_LOAD_B32 for details on the offset input."}, "s_buffer_load_b128": {"desc": "Load 128 bits of data from the scalar data cache into a scalar register using a buffer resource descriptor.", "code": "SDATA[31 : 0] = MEM[ADDR + 0U].b;\nSDATA[63 : 32] = MEM[ADDR + 4U].b;\nSDATA[95 : 64] = MEM[ADDR + 8U].b;\nSDATA[127 : 96] = MEM[ADDR + 12U].b", "notes": "See S_LOAD_B32 for details on the offset input."}, "s_buffer_load_b256": {"desc": "Load 256 bits of data from the scalar data cache into a scalar register using a buffer resource descriptor.\n16.6. SMEM Instructions 248 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "SDATA[31 : 0] = MEM[ADDR + 0U].b;\nSDATA[63 : 32] = MEM[ADDR + 4U].b;\nSDATA[95 : 64] = MEM[ADDR + 8U].b;\nSDATA[127 : 96] = MEM[ADDR + 12U].b;\nSDATA[159 : 128] = MEM[ADDR + 16U].b;\nSDATA[191 : 160] = MEM[ADDR + 20U].b;\nSDATA[223 : 192] = MEM[ADDR + 24U].b;\nSDATA[255 : 224] = MEM[ADDR + 28U].b", "notes": "See S_LOAD_B32 for details on the offset input."}, "s_buffer_load_b512": {"desc": "Load 512 bits of data from the scalar data cache into a scalar register using a buffer resource descriptor.", "code": "SDATA[31 : 0] = MEM[ADDR + 0U].b;\nSDATA[63 : 32] = MEM[ADDR + 4U].b;\nSDATA[95 : 64] = MEM[ADDR + 8U].b;\nSDATA[127 : 96] = MEM[ADDR + 12U].b;\nSDATA[159 : 128] = MEM[ADDR + 16U].b;\nSDATA[191 : 160] = MEM[ADDR + 20U].b;\nSDATA[223 : 192] = MEM[ADDR + 24U].b;\nSDATA[255 : 224] = MEM[ADDR + 28U].b;\nSDATA[287 : 256] = MEM[ADDR + 32U].b;\nSDATA[319 : 288] = MEM[ADDR + 36U].b;\nSDATA[351 : 320] = MEM[ADDR + 40U].b;\nSDATA[383 : 352] = MEM[ADDR + 44U].b;\nSDATA[415 : 384] = MEM[ADDR + 48U].b;\nSDATA[447 : 416] = MEM[ADDR + 52U].b;\nSDATA[479 : 448] = MEM[ADDR + 56U].b;\nSDATA[511 : 480] = MEM[ADDR + 60U].b", "notes": "See S_LOAD_B32 for details on the offset input."}, "s_gl1_inv": {"desc": "Invalidate the GL1 cache only.", "code": "", "notes": ""}, "s_dcache_inv": {"desc": "Invalidate the scalar data L0 cache.\n16.6. SMEM Instructions 249 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "", "notes": "Instructions in this format may use a 32-bit literal constant or DPP that occurs immediately after the\ninstruction."}, "v_cndmask_b32": {"desc": "Copy data from one of two inputs based on the vector condition code and store the result into a vector register.\n\"RDNA3\" Instruction Set Architecture\ninstruction is suitable for negating or taking the absolute value of a floating-point value.", "code": "D0.u = VCC.u64[laneId] ? S1.u : S0.u", "notes": "In VOP3 the VCC source may be a scalar GPR specified in S2.\nFloating-point modifiers are valid for this instruction if S0 and S1 are 32-bit floating point values. This\n16.12. VOP3 & VOP3SD Instructions 392 of 600"}, "v_dot2acc_f32_f16": {"desc": "Dot product of packed FP16 values, accumulate with destination.", "code": "// Accumulate with destination\nD0.f += 32'F(S0[15 : 0].f16) * 32'F(S1[15 : 0].f16);\nD0.f += 32'F(S0[31 : 16].f16) * 32'F(S1[31 : 16].f16)", "notes": ""}, "v_add_f32": {"desc": "Add two floating point inputs and store the result into a vector register.", "code": "D0.f = S0.f + S1.f", "notes": "0.5ULP precision, denormals are supported."}, "v_sub_f32": {"desc": "Subtract the second floating point input from the first input and store the result into a vector register.", "code": "D0.f = S0.f - S1.f", "notes": "0.5ULP precision, denormals are supported."}, "v_subrev_f32": {"desc": "Subtract the first floating point input from the second input and store the result into a vector register.", "code": "D0.f = S1.f - S0.f", "notes": "0.5ULP precision, denormals are supported."}, "v_fmac_dx9_zero_f32": {"desc": "Multiply two single-precision values and accumulate the result with the destination. Follows DX9 rules where\n0.0 times anything produces 0.0 (this is not IEEE compliant).\n16.12. VOP3 & VOP3SD Instructions 393 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "if ((64'F(S0.f) == 0.0) || (64'F(S1.f) == 0.0)) then\n// DX9 rules, 0.0 * x = 0.0\nD0.f = S2.f\nelse\nD0.f = fma(S0.f, S1.f, D0.f)\nendif", "notes": ""}, "v_mul_dx9_zero_f32": {"desc": "Multiply two floating point inputs and store the result in a vector register. Follows DX9 rules where 0.0 times\nanything produces 0.0 (this differs from other APIs when the other input is infinity or NaN).", "code": "if ((64'F(S0.f) == 0.0) || (64'F(S1.f) == 0.0)) then\n// DX9 rules, 0.0 * x = 0.0\nD0.f = 0.0F\nelse\nD0.f = S0.f * S1.f\nendif", "notes": ""}, "v_mul_f32": {"desc": "Multiply two floating point inputs and store the result into a vector register.", "code": "D0.f = S0.f * S1.f", "notes": "0.5ULP precision, denormals are supported."}, "v_mul_i32_i24": {"desc": "Multiply two signed 24 bit integer inputs and store the result as a signed 32 bit integer into a vector register.", "code": "D0.i = 32'I(S0.i24) * 32'I(S1.i24)", "notes": "This opcode is expected to be as efficient as basic single-precision opcodes since it utilizes the single-precision\nfloating point multiplier. See also V_MUL_HI_I32_I24."}, "v_mul_hi_i32_i24": {"desc": "Multiply two signed 24 bit integer inputs and store the high 32 bits of the result as a signed 32 bit integer into a\n16.12. VOP3 & VOP3SD Instructions 394 of 600\n\"RDNA3\" Instruction Set Architecture\nvector register.", "code": "D0.i = 32'I((64'I(S0.i24) * 64'I(S1.i24)) >> 32U)", "notes": "See also V_MUL_I32_I24."}, "v_mul_u32_u24": {"desc": "Multiply two unsigned 24 bit integer inputs and store the result as a unsigned 32 bit integer into a vector\nregister.", "code": "D0.u = 32'U(S0.u24) * 32'U(S1.u24)", "notes": "This opcode is expected to be as efficient as basic single-precision opcodes since it utilizes the single-precision\nfloating point multiplier. See also V_MUL_HI_U32_U24."}, "v_mul_hi_u32_u24": {"desc": "Multiply two unsigned 24 bit integer inputs and store the high 32 bits of the result as a unsigned 32 bit integer\ninto a vector register.", "code": "D0.u = 32'U((64'U(S0.u24) * 64'U(S1.u24)) >> 32U)", "notes": "See also V_MUL_U32_U24."}, "v_min_f32": {"desc": "Select the minimum of two floating point inputs and store the result into a vector register.\n16.12. VOP3 & VOP3SD Instructions 395 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "LT_NEG_ZERO = lambda(a, b) (\n((a < b) || ((64'F(abs(a)) == 0.0) && (64'F(abs(b)) == 0.0) && sign(a) && !sign(b))));\n// Version of comparison where -0.0 < +0.0, differs from IEEE\nif WAVE_MODE.IEEE then\nif isSignalNAN(64'F(S0.f)) then\nD0.f = 32'F(cvtToQuietNAN(64'F(S0.f)))\nelsif isSignalNAN(64'F(S1.f)) then\nD0.f = 32'F(cvtToQuietNAN(64'F(S1.f)))\nelsif isQuietNAN(64'F(S1.f)) then\nD0.f = S0.f\nelsif isQuietNAN(64'F(S0.f)) then\nD0.f = S1.f\nelsif LT_NEG_ZERO(S0.f, S1.f) then\n// NOTE: -0<+0 is TRUE in this comparison\nD0.f = S0.f\nelse\nD0.f = S1.f\nendif\nelse\nif isNAN(64'F(S1.f)) then\nD0.f = S0.f\nelsif isNAN(64'F(S0.f)) then\nD0.f = S1.f\nelsif LT_NEG_ZERO(S0.f, S1.f) then\n// NOTE: -0<+0 is TRUE in this comparison\nD0.f = S0.f\nelse\nD0.f = S1.f\nendif\nendif;\n// Inequalities in the above pseudocode behave differently from IEEE\n// when both inputs are +-0.", "notes": "IEEE compliant. Supports denormals, round mode, exception flags, saturation.\nDenorm flushing for this operation is effectively controlled by the input denorm mode control: If input\ndenorm mode is disabling denorm, the internal result of a min/max operation cannot be a denorm value, so\noutput denorm mode is irrelevant. If input denorm mode is enabling denorm, the internal min/max result can\nbe a denorm and this operation outputs as a denorm regardless of output denorm mode."}, "v_max_f32": {"desc": "Select the maximum of two floating point inputs and store the result into a vector register.\n16.12. VOP3 & VOP3SD Instructions 396 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "GT_NEG_ZERO = lambda(a, b) (\n((a > b) || ((64'F(abs(a)) == 0.0) && (64'F(abs(b)) == 0.0) && !sign(a) && sign(b))));\n// Version of comparison where +0.0 > -0.0, differs from IEEE\nif WAVE_MODE.IEEE then\nif isSignalNAN(64'F(S0.f)) then\nD0.f = 32'F(cvtToQuietNAN(64'F(S0.f)))\nelsif isSignalNAN(64'F(S1.f)) then\nD0.f = 32'F(cvtToQuietNAN(64'F(S1.f)))\nelsif isQuietNAN(64'F(S1.f)) then\nD0.f = S0.f\nelsif isQuietNAN(64'F(S0.f)) then\nD0.f = S1.f\nelsif GT_NEG_ZERO(S0.f, S1.f) then\n// NOTE: +0>-0 is TRUE in this comparison\nD0.f = S0.f\nelse\nD0.f = S1.f\nendif\nelse\nif isNAN(64'F(S1.f)) then\nD0.f = S0.f\nelsif isNAN(64'F(S0.f)) then\nD0.f = S1.f\nelsif GT_NEG_ZERO(S0.f, S1.f) then\n// NOTE: +0>-0 is TRUE in this comparison\nD0.f = S0.f\nelse\nD0.f = S1.f\nendif\nendif;\n// Inequalities in the above pseudocode behave differently from IEEE\n// when both inputs are +-0.", "notes": "IEEE compliant. Supports denormals, round mode, exception flags, saturation.\nDenorm flushing for this operation is effectively controlled by the input denorm mode control: If input\ndenorm mode is disabling denorm, the internal result of a min/max operation cannot be a denorm value, so\noutput denorm mode is irrelevant. If input denorm mode is enabling denorm, the internal min/max result can\nbe a denorm and this operation outputs as a denorm regardless of output denorm mode."}, "v_min_i32": {"desc": "Select the minimum of two signed integers and store the selected value into a vector register.", "code": "D0.i = S0.i < S1.i ? S0.i : S1.i", "notes": ""}, "v_max_i32": {"desc": "Select the maximum of two signed integers and store the selected value into a vector register.", "code": "D0.i = S0.i >= S1.i ? S0.i : S1.i", "notes": ""}, "v_min_u32": {"desc": "Select the minimum of two unsigned integers and store the selected value into a vector register.\n16.12. VOP3 & VOP3SD Instructions 397 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u = S0.u < S1.u ? S0.u : S1.u", "notes": ""}, "v_max_u32": {"desc": "Select the maximum of two unsigned integers and store the selected value into a vector register.", "code": "D0.u = S0.u >= S1.u ? S0.u : S1.u", "notes": ""}, "v_lshlrev_b32": {"desc": "Given a shift count in the first vector input, calculate the logical shift left of the second vector input and store the\nresult into a vector register.", "code": "D0.u = (S1.u << S0[4 : 0].u)", "notes": ""}, "v_lshrrev_b32": {"desc": "Given a shift count in the first vector input, calculate the logical shift right of the second vector input and store\nthe result into a vector register.", "code": "D0.u = (S1.u >> S0[4 : 0].u)", "notes": ""}, "v_ashrrev_i32": {"desc": "Given a shift count in the first vector input, calculate the arithmetic shift right (preserving sign bit) of the second\nvector input and store the result into a vector register.", "code": "D0.i = (S1.i >> S0[4 : 0].u)", "notes": ""}, "v_and_b32": {"desc": "Calculate bitwise AND on two vector inputs and store the result into a vector register.\n16.12. VOP3 & VOP3SD Instructions 398 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u = (S0.u & S1.u)", "notes": "Input and output modifiers not supported."}, "v_or_b32": {"desc": "Calculate bitwise OR on two vector inputs and store the result into a vector register.", "code": "D0.u = (S0.u | S1.u)", "notes": "Input and output modifiers not supported."}, "v_xor_b32": {"desc": "Calculate bitwise XOR on two vector inputs and store the result into a vector register.", "code": "D0.u = (S0.u ^ S1.u)", "notes": "Input and output modifiers not supported."}, "v_xnor_b32": {"desc": "Calculate bitwise XNOR on two vector inputs and store the result into a vector register.", "code": "D0.u = ~(S0.u ^ S1.u)", "notes": "Input and output modifiers not supported."}, "v_add_co_ci_u32": {"desc": "Add two unsigned inputs and a bit from a carry-in mask, store the result into a vector register and store the\ncarry-out mask into a scalar register.\n16.12. VOP3 & VOP3SD Instructions 399 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = 64'U(S0.u) + 64'U(S1.u) + VCC.u64[laneId].u64;\nVCC.u64[laneId] = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\nD0.u = tmp.u", "notes": "In VOP3 the VCC destination may be an arbitrary SGPR-pair, and the VCC source comes from the SGPR-pair at\nS2.u.\nSupports saturation (unsigned 32-bit integer domain)."}, "v_sub_co_ci_u32": {"desc": "Subtract the second unsigned input from the first input, subtract a bit from the carry-in mask, store the result\ninto a vector register and store the carry-out mask to a scalar register.", "code": "tmp = S0.u - S1.u - VCC.u64[laneId].u;\nVCC.u64[laneId] = 64'U(S1.u) + VCC.u64[laneId].u64 > 64'U(S0.u) ? 1'1U : 1'0U;\nD0.u = tmp.u", "notes": "In VOP3 the VCC destination may be an arbitrary SGPR-pair, and the VCC source comes from the SGPR-pair at\nS2.u.\nSupports saturation (unsigned 32-bit integer domain)."}, "v_subrev_co_ci_u32": {"desc": "Subtract the first unsigned input from the second input, subtract a bit from the carry-in mask, store the result\ninto a vector register and store the carry-out mask to a scalar register.", "code": "tmp = S1.u - S0.u - VCC.u64[laneId].u;\nVCC.u64[laneId] = 64'U(S1.u) + VCC.u64[laneId].u64 > 64'U(S0.u) ? 1'1U : 1'0U;\nD0.u = tmp.u", "notes": "In VOP3 the VCC destination may be an arbitrary SGPR-pair, and the VCC source comes from the SGPR-pair at\nS2.u.\nSupports saturation (unsigned 32-bit integer domain)."}, "v_add_nc_u32": {"desc": "16.12. VOP3 & VOP3SD Instructions 400 of 600\n\"RDNA3\" Instruction Set Architecture\nAdd two unsigned inputs and store the result into a vector register. No carry-in or carry-out support.", "code": "D0.u = S0.u + S1.u", "notes": "Supports saturation (unsigned 32-bit integer domain)."}, "v_sub_nc_u32": {"desc": "Subtract the second unsigned input from the first input and store the result into a vector register. No carry-in\nor carry-out support.", "code": "D0.u = S0.u - S1.u", "notes": "Supports saturation (unsigned 32-bit integer domain)."}, "v_subrev_nc_u32": {"desc": "Subtract the first unsigned input from the second input and store the result into a vector register. No carry-in or\ncarry-out support.", "code": "D0.u = S1.u - S0.u", "notes": "Supports saturation (unsigned 32-bit integer domain)."}, "v_fmac_f32": {"desc": "Multiply two floating point inputs and accumulate the result into the destination register using fused multiply-\nadd.", "code": "D0.f = fma(S0.f, S1.f, D0.f)", "notes": ""}, "v_fmamk_f32": {"desc": "Multiply a single-precision float with a literal constant and add a second single-precision float using fused\nmultiply-add.", "code": "D0.f = fma(S0.f, SIMM32.f, S1.f)", "notes": "This opcode cannot use the VOP3 encoding and cannot use input/output modifiers."}, "v_fmaak_f32": {"desc": "Multiply two single-precision floats and add a literal constant using fused multiply-add.\n\"RDNA3\" Instruction Set Architecture", "code": "D0.f = fma(S0.f, S1.f, SIMM32.f)", "notes": "This opcode cannot use the VOP3 encoding and cannot use input/output modifiers.\n16.7. VOP2 Instructions 259 of 600"}, "v_cvt_pk_rtz_f16_f32": {"desc": "16.12. VOP3 & VOP3SD Instructions 401 of 600\n\"RDNA3\" Instruction Set Architecture\nConvert two single-precision float inputs into a packed FP16 result with round toward zero semantics (ignore\nthe current rounding mode), and store the result into a vector register.", "code": "D0[15 : 0].f16 = f32_to_f16(S0.f);\nD0[31 : 16].f16 = f32_to_f16(S1.f);\n// Round-toward-zero regardless of current round mode setting in hardware.", "notes": "This opcode is intended for use with 16-bit compressed exports. See V_CVT_F16_F32 for a version that respects\nthe current rounding mode."}, "v_add_f16": {"desc": "Add two floating point inputs and store the result into a vector register.", "code": "D0.f16 = S0.f16 + S1.f16", "notes": "0.5ULP precision. Supports denormals, round mode, exception flags and saturation."}, "v_sub_f16": {"desc": "Subtract the second floating point input from the first input and store the result into a vector register.", "code": "D0.f16 = S0.f16 - S1.f16", "notes": "0.5ULP precision. Supports denormals, round mode, exception flags and saturation."}, "v_subrev_f16": {"desc": "Subtract the first floating point input from the second input and store the result into a vector register.\n\"RDNA3\" Instruction Set Architecture", "code": "D0.f16 = S1.f16 - S0.f16", "notes": "0.5ULP precision. Supports denormals, round mode, exception flags and saturation.\n16.12. VOP3 & VOP3SD Instructions 402 of 600"}, "v_mul_f16": {"desc": "Multiply two floating point inputs and store the result into a vector register.", "code": "D0.f16 = S0.f16 * S1.f16", "notes": "0.5ULP precision. Supports denormals, round mode, exception flags and saturation."}, "v_fmac_f16": {"desc": "Multiply two floating point inputs and accumulate the result into the destination register using fused multiply-\nadd.", "code": "D0.f16 = fma(S0.f16, S1.f16, D0.f16)", "notes": "0.5ULP precision. Supports denormals, round mode, exception flags and saturation."}, "v_fmamk_f16": {"desc": "Multiply a FP16 value with a literal constant and add a second FP16 value using fused multiply-add.", "code": "D0.f16 = fma(S0.f16, SIMM32.f16, S1.f16)", "notes": "This opcode cannot use the VOP3 encoding and cannot use input/output modifiers. Supports round mode,\nexception flags, saturation."}, "v_fmaak_f16": {"desc": "Multiply two FP16 values and add a literal constant using fused multiply-add.\n16.7. VOP2 Instructions 261 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.f16 = fma(S0.f16, S1.f16, SIMM32.f16)", "notes": "This opcode cannot use the VOP3 encoding and cannot use input/output modifiers. Supports round mode,\nexception flags, saturation."}, "v_max_f16": {"desc": "Select the maximum of two floating point inputs and store the result into a vector register.\n16.12. VOP3 & VOP3SD Instructions 403 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "GT_NEG_ZERO = lambda(a, b) (\n((a > b) || ((64'F(abs(a)) == 0.0) && (64'F(abs(b)) == 0.0) && !sign(a) && sign(b))));\n// Version of comparison where +0.0 > -0.0, differs from IEEE\nif WAVE_MODE.IEEE then\nif isSignalNAN(64'F(S0.f16)) then\nD0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))\nelsif isSignalNAN(64'F(S1.f16)) then\nD0.f16 = 16'F(cvtToQuietNAN(64'F(S1.f16)))\nelsif isQuietNAN(64'F(S1.f16)) then\nD0.f16 = S0.f16\nelsif isQuietNAN(64'F(S0.f16)) then\nD0.f16 = S1.f16\nelsif GT_NEG_ZERO(S0.f16, S1.f16) then\n// NOTE: +0>-0 is TRUE in this comparison\nD0.f16 = S0.f16\nelse\nD0.f16 = S1.f16\nendif\nelse\nif isNAN(64'F(S1.f16)) then\nD0.f16 = S0.f16\nelsif isNAN(64'F(S0.f16)) then\nD0.f16 = S1.f16\nelsif GT_NEG_ZERO(S0.f16, S1.f16) then\n// NOTE: +0>-0 is TRUE in this comparison\nD0.f16 = S0.f16\nelse\nD0.f16 = S1.f16\nendif\nendif;\n// Inequalities in the above pseudocode behave differently from IEEE\n// when both inputs are +-0.", "notes": "IEEE compliant. Supports denormals, round mode, exception flags, saturation.\nDenorm flushing for this operation is effectively controlled by the input denorm mode control: If input\ndenorm mode is disabling denorm, the internal result of a min/max operation cannot be a denorm value, so\noutput denorm mode is irrelevant. If input denorm mode is enabling denorm, the internal min/max result can\nbe a denorm and this operation outputs as a denorm regardless of output denorm mode."}, "v_min_f16": {"desc": "Select the minimum of two floating point inputs and store the result into a vector register.\n16.12. VOP3 & VOP3SD Instructions 404 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "LT_NEG_ZERO = lambda(a, b) (\n((a < b) || ((64'F(abs(a)) == 0.0) && (64'F(abs(b)) == 0.0) && sign(a) && !sign(b))));\n// Version of comparison where -0.0 < +0.0, differs from IEEE\nif WAVE_MODE.IEEE then\nif isSignalNAN(64'F(S0.f16)) then\nD0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))\nelsif isSignalNAN(64'F(S1.f16)) then\nD0.f16 = 16'F(cvtToQuietNAN(64'F(S1.f16)))\nelsif isQuietNAN(64'F(S1.f16)) then\nD0.f16 = S0.f16\nelsif isQuietNAN(64'F(S0.f16)) then\nD0.f16 = S1.f16\nelsif LT_NEG_ZERO(S0.f16, S1.f16) then\n// NOTE: -0<+0 is TRUE in this comparison\nD0.f16 = S0.f16\nelse\nD0.f16 = S1.f16\nendif\nelse\nif isNAN(64'F(S1.f16)) then\nD0.f16 = S0.f16\nelsif isNAN(64'F(S0.f16)) then\nD0.f16 = S1.f16\nelsif LT_NEG_ZERO(S0.f16, S1.f16) then\n// NOTE: -0<+0 is TRUE in this comparison\nD0.f16 = S0.f16\nelse\nD0.f16 = S1.f16\nendif\nendif;\n// Inequalities in the above pseudocode behave differently from IEEE\n// when both inputs are +-0.", "notes": "IEEE compliant. Supports denormals, round mode, exception flags, saturation.\nDenorm flushing for this operation is effectively controlled by the input denorm mode control: If input\ndenorm mode is disabling denorm, the internal result of a min/max operation cannot be a denorm value, so\noutput denorm mode is irrelevant. If input denorm mode is enabling denorm, the internal min/max result can\nbe a denorm and this operation outputs as a denorm regardless of output denorm mode."}, "v_ldexp_f16": {"desc": "Multiply the first input, a floating point value, by an integral power of 2 specified in the second input, a signed\ninteger value, and store the floating point result into a vector register. Compare with the ldexp() function in C.", "code": "D0.f16 = S0.f16 * 16'F(2.0F ** 32'I(S1.i16))", "notes": ""}, "v_pk_fmac_f16": {"desc": "Multiply packed FP16 values and accumulate with destination.\n\"RDNA3\" Instruction Set Architecture", "code": "D0[31 : 16].f16 = fma(S0[31 : 16].f16, S1[31 : 16].f16, D0[31 : 16].f16);\nD0[15 : 0].f16 = fma(S0[15 : 0].f16, S1[15 : 0].f16, D0[15 : 0].f16)", "notes": "VOP2 version of V_PK_FMA_F16 with third source VGPR address is the destination.\n16.7.1. VOP2 using VOP3 or VOP3SD encoding\nInstructions in this format may also be encoded as VOP3. VOP3 allows access to the extra control bits (e.g. ABS,\nOMOD) at the expense of a larger instruction word. The VOP3 opcode is: VOP2 opcode + 0x100.\n16.7. VOP2 Instructions 264 of 600\nInstructions in this format may use a 32-bit literal constant or DPP that occurs immediately after the\ninstruction."}, "v_nop": {"desc": "Do nothing.", "code": "", "notes": ""}, "v_mov_b32": {"desc": "Move data from a vector input into a vector register.\n\"RDNA3\" Instruction Set Architecture", "code": "D0.b = S0.b", "notes": "Floating-point modifiers are valid for this instruction if S0.u is a 32-bit floating point value. This instruction is\nsuitable for negating or taking the absolute value of a floating-point value.\nFunctional examples:\nv_mov_b32 v0, v1 // Move v1 to v0\nv_mov_b32 v0, -v1 // Set v1 to the negation of v0\nv_mov_b32 v0, abs(v1) // Set v1 to the absolute value of v0\n16.12. VOP3 & VOP3SD Instructions 365 of 600"}, "v_readfirstlane_b32": {"desc": "Read the scalar value in the lowest active lane of the input vector register and store it into a scalar register.", "code": "declare lane : 32'U;\nif WAVE64 then\n// 64 lanes\nif EXEC == 0x0LL then\nlane = 0U;\n// Force lane 0 if all lanes are disabled\nelse\nlane = 32'U(s_ff1_i32_b64(EXEC));\n// Lowest active lane\nendif\nelse\n// 32 lanes\nif EXEC_LO.i == 0 then\nlane = 0U;\n// Force lane 0 if all lanes are disabled\nelse\nlane = 32'U(s_ff1_i32_b32(EXEC_LO));\n// Lowest active lane\nendif\nendif;\nD0.b = VGPR[lane][SRC0.u]", "notes": "Overrides EXEC mask for the VGPR read. Input and output modifiers not supported; this is an untyped\noperation."}, "v_cvt_i32_f64": {"desc": "Convert from a double-precision float input to a signed 32-bit integer and store the result into a vector register.", "code": "D0.i = f64_to_i32(S0.f64)", "notes": "0.5ULP accuracy, out-of-range floating point values (including infinity) saturate. NAN is converted to 0.\nGeneration of the INEXACT exception is controlled by the CLAMP bit. INEXACT exceptions are enabled for this\nconversion iff CLAMP == 1."}, "v_cvt_f64_i32": {"desc": "16.12. VOP3 & VOP3SD Instructions 366 of 600\n\"RDNA3\" Instruction Set Architecture\nConvert from a signed 32-bit integer input to a double-precision float and store the result into a vector register.", "code": "D0.f64 = i32_to_f64(S0.i)", "notes": "0ULP accuracy."}, "v_cvt_f32_i32": {"desc": "Convert from a signed 32-bit integer input to a single-precision float and store the result into a vector register.", "code": "D0.f = i32_to_f32(S0.i)", "notes": "0.5ULP accuracy."}, "v_cvt_f32_u32": {"desc": "Convert from an unsigned 32-bit integer input to a single-precision float and store the result into a vector\nregister.", "code": "D0.f = u32_to_f32(S0.u)", "notes": "0.5ULP accuracy."}, "v_cvt_u32_f32": {"desc": "Convert from a single-precision float input to an unsigned 32-bit integer and store the result into a vector\nregister.\n\"RDNA3\" Instruction Set Architecture\nconversion iff CLAMP == 1.", "code": "D0.u = f32_to_u32(S0.f)", "notes": "1ULP accuracy, out-of-range floating point values (including infinity) saturate. NAN is converted to 0.\nGeneration of the INEXACT exception is controlled by the CLAMP bit. INEXACT exceptions are enabled for this\n16.12. VOP3 & VOP3SD Instructions 367 of 600"}, "v_cvt_i32_f32": {"desc": "Convert from a single-precision float input to a signed 32-bit integer and store the result into a vector register.", "code": "D0.i = f32_to_i32(S0.f)", "notes": "1ULP accuracy, out-of-range floating point values (including infinity) saturate. NAN is converted to 0.\nGeneration of the INEXACT exception is controlled by the CLAMP bit. INEXACT exceptions are enabled for this\nconversion iff CLAMP == 1."}, "v_cvt_f16_f32": {"desc": "Convert from a single-precision float input to an FP16 float and store the result into a vector register.", "code": "D0.f16 = f32_to_f16(S0.f)", "notes": "0.5ULP accuracy, supports input modifiers and creates FP16 denormals when appropriate. Flush denorms on\noutput if specified based on DP denorm mode. Output rounding based on DP rounding mode."}, "v_cvt_f32_f16": {"desc": "Convert from an FP16 float input to a single-precision float and store the result into a vector register.", "code": "D0.f = f16_to_f32(S0.f16)", "notes": "0ULP accuracy, FP16 denormal inputs are accepted. Flush denorms on input if specified based on DP denorm\nmode."}, "v_cvt_nearest_i32_f32": {"desc": "Convert from a single-precision float input to a signed 32-bit integer using round-to-nearest-integer semantics\n(ignore the default rounding mode) and store the result into a vector register.\n16.12. VOP3 & VOP3SD Instructions 368 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.i = f32_to_i32(floor(S0.f + 0.5F))", "notes": "0.5ULP accuracy, denormals are supported."}, "v_cvt_floor_i32_f32": {"desc": "Convert from a single-precision float input to a signed 32-bit integer using round-down semantics (ignore the\ndefault rounding mode) and store the result into a vector register.", "code": "D0.i = f32_to_i32(floor(S0.f))", "notes": "1ULP accuracy, denormals are supported."}, "v_cvt_off_f32_i4": {"desc": "Convert from a signed 4-bit integer to a single-precision float using an offset table and store the result into a\nvector register.\nUsed for interpolation in shader. Lookup table on S0[3:0]:\nS0 binary Result\n1000 -0.5000f\n1001 -0.4375f\n1010 -0.3750f\n1011 -0.3125f\n1100 -0.2500f\n1101 -0.1875f\n1110 -0.1250f\n1111 -0.0625f\n0000 +0.0000f\n0001 +0.0625f\n0010 +0.1250f\n0011 +0.1875f\n0100 +0.2500f\n0101 +0.3125f\n0110 +0.3750f\n0111 +0.4375f\n16.12. VOP3 & VOP3SD Instructions 369 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "declare CVT_OFF_TABLE : 32'F[16];\nD0.f = CVT_OFF_TABLE[S0.u[3 : 0]]", "notes": ""}, "v_cvt_f32_f64": {"desc": "Convert from a double-precision float input to a single-precision float and store the result into a vector register.", "code": "D0.f = f64_to_f32(S0.f64)", "notes": "0.5ULP accuracy, denormals are supported."}, "v_cvt_f64_f32": {"desc": "Convert from a single-precision float input to a double-precision float and store the result into a vector register.", "code": "D0.f64 = f32_to_f64(S0.f)", "notes": "0ULP accuracy, denormals are supported."}, "v_cvt_f32_ubyte0": {"desc": "Convert an unsigned byte in byte 0 of the input to a single-precision float and store the result into a vector\nregister.", "code": "D0.f = u32_to_f32(S0.u[7 : 0].u)", "notes": ""}, "v_cvt_f32_ubyte1": {"desc": "Convert an unsigned byte in byte 1 of the input to a single-precision float and store the result into a vector\nregister.", "code": "D0.f = u32_to_f32(S0.u[15 : 8].u)", "notes": ""}, "v_cvt_f32_ubyte2": {"desc": "Convert an unsigned byte in byte 2 of the input to a single-precision float and store the result into a vector\n16.12. VOP3 & VOP3SD Instructions 370 of 600\n\"RDNA3\" Instruction Set Architecture\nregister.", "code": "D0.f = u32_to_f32(S0.u[23 : 16].u)", "notes": ""}, "v_cvt_f32_ubyte3": {"desc": "Convert an unsigned byte in byte 3 of the input to a single-precision float and store the result into a vector\nregister.", "code": "D0.f = u32_to_f32(S0.u[31 : 24].u)", "notes": ""}, "v_cvt_u32_f64": {"desc": "Convert from a double-precision float input to an unsigned 32-bit integer and store the result into a vector\nregister.", "code": "D0.u = f64_to_u32(S0.f64)", "notes": "0.5ULP accuracy, out-of-range floating point values (including infinity) saturate. NAN is converted to 0.\nGeneration of the INEXACT exception is controlled by the CLAMP bit. INEXACT exceptions are enabled for this\nconversion iff CLAMP == 1."}, "v_cvt_f64_u32": {"desc": "Convert from an unsigned 32-bit integer input to a double-precision float and store the result into a vector\nregister.", "code": "D0.f64 = u32_to_f64(S0.u)", "notes": "0ULP accuracy."}, "v_trunc_f64": {"desc": "Compute the integer part of a double-precision float input with round-toward-zero semantics and store the\n16.12. VOP3 & VOP3SD Instructions 371 of 600\n\"RDNA3\" Instruction Set Architecture\nresult in floating point format into a vector register.", "code": "D0.f64 = trunc(S0.f64)", "notes": ""}, "v_ceil_f64": {"desc": "Round the double-precision float input up to next integer and store the result in floating point format into a\nvector register.", "code": "D0.f64 = trunc(S0.f64);\nif ((S0.f64 > 0.0) && (S0.f64 != D0.f64)) then\nD0.f64 += 1.0\nendif", "notes": ""}, "v_rndne_f64": {"desc": "Round the double-precision float input to the nearest even integer and store the result in floating point format\ninto a vector register.", "code": "D0.f64 = floor(S0.f64 + 0.5);\nif (isEven(floor(S0.f64)) && (fract(S0.f64) == 0.5)) then\nD0.f64 -= 1.0\nendif", "notes": ""}, "v_floor_f64": {"desc": "Round the double-precision float input down to previous integer and store the result in floating point format\ninto a vector register.", "code": "D0.f64 = trunc(S0.f64);\nif ((S0.f64 < 0.0) && (S0.f64 != D0.f64)) then\nD0.f64 += -1.0\nendif", "notes": ""}, "v_pipeflush": {"desc": "Flush the VALU destination cache.\n16.12. VOP3 & VOP3SD Instructions 372 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "", "notes": ""}, "v_mov_b16": {"desc": "Move data to a VGPR.", "code": "D0.b16 = S0.b16", "notes": "Floating-point modifiers are valid for this instruction if S0.u16 is a 16-bit floating point value. This instruction is\nsuitable for negating or taking the absolute value of a floating-point value."}, "v_fract_f32": {"desc": "Compute the fractional portion of a single-precision float input and store the result in floating point format into\na vector register.", "code": "D0.f = S0.f + -floor(S0.f)", "notes": "0.5ULP accuracy, denormals are accepted.\nThis is intended to comply with the DX specification of fract where the function behaves like an extension of\ninteger modulus; be aware this may differ from how fract() is defined in other domains. For example: fract(-\n1.2) = 0.8 in DX.\nObey round mode, result clamped to 0x3f7fffff."}, "v_trunc_f32": {"desc": "Compute the integer part of a single-precision float input with round-toward-zero semantics and store the\nresult in floating point format into a vector register.", "code": "D0.f = trunc(S0.f)", "notes": ""}, "v_ceil_f32": {"desc": "Round the single-precision float input up to next integer and store the result in floating point format into a\nvector register.\n16.12. VOP3 & VOP3SD Instructions 373 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.f = trunc(S0.f);\nif ((S0.f > 0.0F) && (S0.f != D0.f)) then\nD0.f += 1.0F\nendif", "notes": ""}, "v_rndne_f32": {"desc": "Round the single-precision float input to the nearest even integer and store the result in floating point format\ninto a vector register.", "code": "D0.f = floor(S0.f + 0.5F);\nif (isEven(64'F(floor(S0.f))) && (fract(S0.f) == 0.5F)) then\nD0.f -= 1.0F\nendif", "notes": ""}, "v_floor_f32": {"desc": "Round the single-precision float input down to previous integer and store the result in floating point format\ninto a vector register.", "code": "D0.f = trunc(S0.f);\nif ((S0.f < 0.0F) && (S0.f != D0.f)) then\nD0.f += -1.0F\nendif", "notes": ""}, "v_exp_f32": {"desc": "Calculate 2 raised to the power of the single-precision float input and store the result into a vector register.\n\"RDNA3\" Instruction Set Architecture", "code": "D0.f = pow(2.0F, S0.f)", "notes": "1ULP accuracy, denormals are flushed.\nFunctional examples:\nV_EXP_F32(0xff800000) => 0x00000000 // exp(-INF) = 0\nV_EXP_F32(0x80000000) => 0x3f800000 // exp(-0.0) = 1\nV_EXP_F32(0x7f800000) => 0x7f800000 // exp(+INF) = +INF\n16.12. VOP3 & VOP3SD Instructions 374 of 600"}, "v_log_f32": {"desc": "Calculate the base 2 logarithm of the single-precision float input and store the result into a vector register.", "code": "D0.f = log2(S0.f)", "notes": "1ULP accuracy, denormals are flushed.\nFunctional examples:\nV_LOG_F32(0xff800000) => 0xffc00000 // log(-INF) = NAN\nV_LOG_F32(0xbf800000) => 0xffc00000 // log(-1.0) = NAN\nV_LOG_F32(0x80000000) => 0xff800000 // log(-0.0) = -INF\nV_LOG_F32(0x00000000) => 0xff800000 // log(+0.0) = -INF\nV_LOG_F32(0x3f800000) => 0x00000000 // log(+1.0) = 0\nV_LOG_F32(0x7f800000) => 0x7f800000 // log(+INF) = +INF"}, "v_rcp_f32": {"desc": "Calculate the reciprocal of the single-precision float input using IEEE rules and store the result into a vector\nregister.", "code": "D0.f = 1.0F / S0.f", "notes": "1ULP accuracy. Accuracy converges to < 0.5ULP when using the Newton-Raphson method and 2 FMA\noperations. Denormals are flushed.\nFunctional examples:\nV_RCP_F32(0xff800000) => 0x80000000 // rcp(-INF) = -0\nV_RCP_F32(0xc0000000) => 0xbf000000 // rcp(-2.0) = -0.5\nV_RCP_F32(0x80000000) => 0xff800000 // rcp(-0.0) = -INF\nV_RCP_F32(0x00000000) => 0x7f800000 // rcp(+0.0) = +INF\nV_RCP_F32(0x7f800000) => 0x00000000 // rcp(+INF) = +0"}, "v_rcp_iflag_f32": {"desc": "Calculate the reciprocal of the vector float input in a manner suitable for integer division and store the result\ninto a vector register. This opcode is intended for use as part of an integer division macro.\n16.12. VOP3 & VOP3SD Instructions 375 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.f = 1.0F / S0.f;\n// Can only raise integer DIV_BY_ZERO exception", "notes": "Can raise integer DIV_BY_ZERO exception but cannot raise floating-point exceptions. To be used in an integer\nreciprocal macro by the compiler with one of the sequences listed below (depending on signed or unsigned\noperation).\nUnsigned usage:\nCVT_F32_U32\nRCP_IFLAG_F32\nMUL_F32 (2**32 - 1)\nCVT_U32_F32\nSigned usage:\nCVT_F32_I32\nRCP_IFLAG_F32\nMUL_F32 (2**31 - 1)\nCVT_I32_F32"}, "v_rsq_f32": {"desc": "Calculate the reciprocal of the square root of the single-precision float input using IEEE rules and store the\nresult into a vector register.", "code": "D0.f = 1.0F / sqrt(S0.f)", "notes": "1ULP accuracy, denormals are flushed.\nFunctional examples:\nV_RSQ_F32(0xff800000) => 0xffc00000 // rsq(-INF) = NAN\nV_RSQ_F32(0x80000000) => 0xff800000 // rsq(-0.0) = -INF\nV_RSQ_F32(0x00000000) => 0x7f800000 // rsq(+0.0) = +INF\nV_RSQ_F32(0x40800000) => 0x3f000000 // rsq(+4.0) = +0.5\nV_RSQ_F32(0x7f800000) => 0x00000000 // rsq(+INF) = +0"}, "v_rcp_f64": {"desc": "Calculate the reciprocal of the double-precision float input using IEEE rules and store the result into a vector\nregister.\n16.12. VOP3 & VOP3SD Instructions 376 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.f64 = 1.0 / S0.f64", "notes": "This opcode has (2**29)ULP accuracy and supports denormals."}, "v_rsq_f64": {"desc": "Calculate the reciprocal of the square root of the double-precision float input using IEEE rules and store the\nresult into a vector register.", "code": "D0.f64 = 1.0 / sqrt(S0.f64)", "notes": "This opcode has (2**29)ULP accuracy and supports denormals."}, "v_sqrt_f32": {"desc": "Calculate the square root of the single-precision float input using IEEE rules and store the result into a vector\nregister.", "code": "D0.f = sqrt(S0.f)", "notes": "1ULP accuracy, denormals are flushed.\nFunctional examples:\nV_SQRT_F32(0xff800000) => 0xffc00000 // sqrt(-INF) = NAN\nV_SQRT_F32(0x80000000) => 0x80000000 // sqrt(-0.0) = -0\nV_SQRT_F32(0x00000000) => 0x00000000 // sqrt(+0.0) = +0\nV_SQRT_F32(0x40800000) => 0x40000000 // sqrt(+4.0) = +2.0\nV_SQRT_F32(0x7f800000) => 0x7f800000 // sqrt(+INF) = +INF"}, "v_sqrt_f64": {"desc": "Calculate the square root of the double-precision float input using IEEE rules and store the result into a vector\nregister.\n16.12. VOP3 & VOP3SD Instructions 377 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.f64 = sqrt(S0.f64)", "notes": "This opcode has (2**29)ULP accuracy and supports denormals."}, "v_sin_f32": {"desc": "Calculate the trigonometric sine of a single-precision float value using IEEE rules and store the result into a\nvector register. The operand is calculated by scaling the vector input by 2 PI.", "code": "D0.f = 32'F(sin(64'F(S0.f) * 2.0 * PI))", "notes": "Denormals are supported. Full range input is supported.\nFunctional examples:\nV_SIN_F32(0xff800000) => 0xffc00000 // sin(-INF) = NAN\nV_SIN_F32(0xff7fffff) => 0x00000000 // -MaxFloat, finite\nV_SIN_F32(0x80000000) => 0x80000000 // sin(-0.0) = -0\nV_SIN_F32(0x3e800000) => 0x3f800000 // sin(0.25) = 1\nV_SIN_F32(0x7f800000) => 0xffc00000 // sin(+INF) = NAN"}, "v_cos_f32": {"desc": "Calculate the trigonometric cosine of a single-precision float value using IEEE rules and store the result into a\nvector register. The operand is calculated by scaling the vector input by 2 PI.\n\"RDNA3\" Instruction Set Architecture", "code": "D0.f = 32'F(cos(64'F(S0.f) * 2.0 * PI))\nV_COS_F32(0x7f800000) => 0xffc00000 // cos(+INF) = NAN", "notes": "Denormals are supported. Full range input is supported.\nFunctional examples:\nV_COS_F32(0xff800000) => 0xffc00000 // cos(-INF) = NAN\nV_COS_F32(0xff7fffff) => 0x3f800000 // -MaxFloat, finite\nV_COS_F32(0x80000000) => 0x3f800000 // cos(-0.0) = 1\nV_COS_F32(0x3e800000) => 0x00000000 // cos(0.25) = 0\n16.12. VOP3 & VOP3SD Instructions 378 of 600"}, "v_not_b32": {"desc": "Calculate bitwise negation on a vector input and store the result into a vector register.", "code": "D0.u = ~S0.u", "notes": "Input and output modifiers not supported."}, "v_bfrev_b32": {"desc": "Reverse the order of bits in a vector input and store the result into a vector register.", "code": "D0.u[31 : 0] = S0.u[0 : 31]", "notes": "Input and output modifiers not supported."}, "v_clz_i32_u32": {"desc": "Count the number of leading \"0\" bits before the first \"1\" in a vector input and store the result into a vector\nregister. Store -1 if there are no \"1\" bits.\n\"RDNA3\" Instruction Set Architecture", "code": "D0.i = -1;\n// Set if no ones are found\nfor i in 0 : 31 do\n// Search from MSB\nif S0.u[31 - i] == 1'1U then\nD0.i = i;\nbreak\nendif\nendfor\nV_CLZ_I32_U32(0x00000000) => 0xffffffff\nV_CLZ_I32_U32(0x800000ff) => 0\nV_CLZ_I32_U32(0x100000ff) => 3\nV_CLZ_I32_U32(0x0000ffff) => 16\nV_CLZ_I32_U32(0x00000001) => 31", "notes": "Compare with S_CLZ_I32_U32, which performs the equivalent operation in the scalar ALU.\nFunctional examples:\n16.12. VOP3 & VOP3SD Instructions 379 of 600"}, "v_ctz_i32_b32": {"desc": "Count the number of trailing \"0\" bits before the first \"1\" in a vector input and store the result into a vector\nregister. Store -1 if there are no \"1\" bits in the input.", "code": "D0.i = -1;\n// Set if no ones are found\nfor i in 0 : 31 do\n// Search from LSB\nif S0.u[i] == 1'1U then\nD0.i = i;\nbreak\nendif\nendfor", "notes": "Compare with S_CTZ_I32_B32, which performs the equivalent operation in the scalar ALU.\nFunctional examples:\nV_CTZ_I32_B32(0x00000000) => 0xffffffff\nV_CTZ_I32_B32(0xff000001) => 0\nV_CTZ_I32_B32(0xff000008) => 3\nV_CTZ_I32_B32(0xffff0000) => 16\nV_CTZ_I32_B32(0x80000000) => 31"}, "v_cls_i32": {"desc": "Count the number of leading bits that are the same as the sign bit of a vector input and store the result into a\nvector register. Store -1 if all input bits are the same.\n16.12. VOP3 & VOP3SD Instructions 380 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.i = -1;\n// Set if all bits are the same\nfor i in 1 : 31 do\n// Search from MSB\nif S0.i[31 - i] != S0.i[31] then\nD0.i = i;\nbreak\nendif\nendfor", "notes": "Compare with S_CLS_I32, which performs the equivalent operation in the scalar ALU.\nFunctional examples:\nV_CLS_I32(0x00000000) => 0xffffffff\nV_CLS_I32(0x40000000) => 1\nV_CLS_I32(0x80000000) => 1\nV_CLS_I32(0x0fffffff) => 4\nV_CLS_I32(0xffff0000) => 16\nV_CLS_I32(0xfffffffe) => 31\nV_CLS_I32(0xffffffff) => 0xffffffff"}, "v_frexp_exp_i32_f64": {"desc": "Extract the exponent of a double-precision float input and store the result as a signed 32-bit integer into a\nvector register.", "code": "if ((S0.f64 == +INF) || (S0.f64 == -INF) || isNAN(S0.f64)) then\nD0.i = 0\nelse\nD0.i = exponent(S0.f64) - 1023 + 1\nendif", "notes": "This operation satisfies the invariant S0.f64 = significand * (2 ** exponent). See also V_FREXP_MANT_F64,\nwhich returns the significand. See the C library function frexp() for more information."}, "v_frexp_mant_f64": {"desc": "Extract the binary significand, or mantissa, of a double-precision float input and store the result as a double-\nprecision float into a vector register.\n\"RDNA3\" Instruction Set Architecture\nThis operation satisfies the invariant S0.f64 = significand * (2 ** exponent). Result range is in (-1.0,-0.5][0.5,1.0)\nin normal cases. See also V_FREXP_EXP_I_F64, which returns integer exponent. See the C library function\nfrexp() for more information.", "code": "if ((S0.f64 == +INF) || (S0.f64 == -INF) || isNAN(S0.f64)) then\nD0.f64 = S0.f64\nelse\nD0.f64 = mantissa(S0.f64)\nendif", "notes": "16.12. VOP3 & VOP3SD Instructions 381 of 600"}, "v_fract_f64": {"desc": "Compute the fractional portion of a double-precision float input and store the result in floating point format\ninto a vector register.", "code": "D0.f64 = S0.f64 + -floor(S0.f64)", "notes": "0.5ULP accuracy, denormals are accepted.\nThis is intended to comply with the DX specification of fract where the function behaves like an extension of\ninteger modulus; be aware this may differ from how fract() is defined in other domains. For example: fract(-\n1.2) = 0.8 in DX.\nObey round mode, result clamped to 0x3fefffffffffffff."}, "v_frexp_exp_i32_f32": {"desc": "Extract the exponent of a single-precision float input and store the result as a signed 32-bit integer into a vector\nregister.", "code": "if ((64'F(S0.f) == +INF) || (64'F(S0.f) == -INF) || isNAN(64'F(S0.f))) then\nD0.i = 0\nelse\nD0.i = exponent(S0.f) - 127 + 1\nendif", "notes": "This operation satisfies the invariant S0.f32 = significand * (2 ** exponent). See also V_FREXP_MANT_F32,\nwhich returns the significand. See the C library function frexp() for more information."}, "v_frexp_mant_f32": {"desc": "Extract the binary significand, or mantissa, of a single-precision float input and store the result as a single-\nprecision float into a vector register.\n16.12. VOP3 & VOP3SD Instructions 382 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "if ((64'F(S0.f) == +INF) || (64'F(S0.f) == -INF) || isNAN(64'F(S0.f))) then\nD0.f = S0.f\nelse\nD0.f = mantissa(S0.f)\nendif", "notes": "This operation satisfies the invariant S0.f32 = significand * (2 ** exponent). Result range is in (-1.0,-0.5][0.5,1.0)\nin normal cases. See also V_FREXP_EXP_I_F32, which returns integer exponent. See the C library function\nfrexp() for more information."}, "v_movreld_b32": {"desc": "Move to a relative destination address.", "code": "addr = DST.u;\n// Raw value from instruction\naddr += M0.u[31 : 0];\nVGPR[laneId][addr].b = S0.b", "notes": "Example: The following instruction sequence performs the move v15 <= v7:\ns_mov_b32 m0, 10\nv_movreld_b32 v5, v7"}, "v_movrels_b32": {"desc": "Move from a relative source address.\n\"RDNA3\" Instruction Set Architecture", "code": "addr = SRC0.u;\n// Raw value from instruction\naddr += M0.u[31 : 0];\nD0.b = VGPR[laneId][addr].b", "notes": "Example: The following instruction sequence performs the move v5 <= v17:\ns_mov_b32 m0, 10\nv_movrels_b32 v5, v7\n16.12. VOP3 & VOP3SD Instructions 383 of 600"}, "v_movrelsd_b32": {"desc": "Move from a relative source address to a relative destination address.", "code": "addrs = SRC0.u;\n// Raw value from instruction\naddrd = DST.u;\n// Raw value from instruction\naddrs += M0.u[31 : 0];\naddrd += M0.u[31 : 0];\nVGPR[laneId][addrd].b = VGPR[laneId][addrs].b", "notes": "Example: The following instruction sequence performs the move v15 <= v17:\ns_mov_b32 m0, 10\nv_movrelsd_b32 v5, v7"}, "v_movrelsd_2_b32": {"desc": "Move from a relative source address to a relative destination address, with different relative offsets.", "code": "addrs = SRC0.u;\n// Raw value from instruction\naddrd = DST.u;\n// Raw value from instruction\naddrs += M0.u[9 : 0].u;\naddrd += M0.u[25 : 16].u;\nVGPR[laneId][addrd].b = VGPR[laneId][addrs].b", "notes": "Example: The following instruction sequence performs the move v25 <= v17:\ns_mov_b32 m0, ((20 << 16) | 10)\nv_movrelsd_2_b32 v5, v7"}, "v_cvt_f16_u16": {"desc": "Convert from an unsigned 16-bit integer input to an FP16 float and store the result into a vector register.\n16.12. VOP3 & VOP3SD Instructions 384 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.f16 = u16_to_f16(S0.u16)", "notes": "0.5ULP accuracy, supports denormals, rounding, exception flags and saturation."}, "v_cvt_f16_i16": {"desc": "Convert from a signed 16-bit integer input to an FP16 float and store the result into a vector register.", "code": "D0.f16 = i16_to_f16(S0.i16)", "notes": "0.5ULP accuracy, supports denormals, rounding, exception flags and saturation."}, "v_cvt_u16_f16": {"desc": "Convert from an FP16 float input to an unsigned 16-bit integer and store the result into a vector register.", "code": "D0.u16 = f16_to_u16(S0.f16)", "notes": "1ULP accuracy, supports rounding, exception flags and saturation. FP16 denormals are accepted. Conversion\nis done with truncation.\nGeneration of the INEXACT exception is controlled by the CLAMP bit. INEXACT exceptions are enabled for this\nconversion iff CLAMP == 1."}, "v_cvt_i16_f16": {"desc": "Convert from an FP16 float input to a signed 16-bit integer and store the result into a vector register.\n\"RDNA3\" Instruction Set Architecture", "code": "D0.i16 = f16_to_i16(S0.f16)", "notes": "1ULP accuracy, supports rounding, exception flags and saturation. FP16 denormals are accepted. Conversion\nis done with truncation.\nGeneration of the INEXACT exception is controlled by the CLAMP bit. INEXACT exceptions are enabled for this\nconversion iff CLAMP == 1.\n16.12. VOP3 & VOP3SD Instructions 385 of 600"}, "v_rcp_f16": {"desc": "Calculate the reciprocal of the half-precision float input using IEEE rules and store the result into a vector\nregister.", "code": "D0.f16 = 16'1.0 / S0.f16", "notes": "0.51ULP accuracy.\nFunctional examples:\nV_RCP_F16(0xfc00) => 0x8000 // rcp(-INF) = -0\nV_RCP_F16(0xc000) => 0xb800 // rcp(-2.0) = -0.5\nV_RCP_F16(0x8000) => 0xfc00 // rcp(-0.0) = -INF\nV_RCP_F16(0x0000) => 0x7c00 // rcp(+0.0) = +INF\nV_RCP_F16(0x7c00) => 0x0000 // rcp(+INF) = +0"}, "v_sqrt_f16": {"desc": "Calculate the square root of the half-precision float input using IEEE rules and store the result into a vector\nregister.", "code": "D0.f16 = sqrt(S0.f16)", "notes": "0.51ULP accuracy, denormals are supported.\nFunctional examples:\nV_SQRT_F16(0xfc00) => 0xfe00 // sqrt(-INF) = NAN\nV_SQRT_F16(0x8000) => 0x8000 // sqrt(-0.0) = -0\nV_SQRT_F16(0x0000) => 0x0000 // sqrt(+0.0) = +0\nV_SQRT_F16(0x4400) => 0x4000 // sqrt(+4.0) = +2.0\nV_SQRT_F16(0x7c00) => 0x7c00 // sqrt(+INF) = +INF"}, "v_rsq_f16": {"desc": "Calculate the reciprocal of the square root of the half-precision float input using IEEE rules and store the result\ninto a vector register.\n16.12. VOP3 & VOP3SD Instructions 386 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.f16 = 16'1.0 / sqrt(S0.f16)", "notes": "0.51ULP accuracy, denormals are supported.\nFunctional examples:\nV_RSQ_F16(0xfc00) => 0xfe00 // rsq(-INF) = NAN\nV_RSQ_F16(0x8000) => 0xfc00 // rsq(-0.0) = -INF\nV_RSQ_F16(0x0000) => 0x7c00 // rsq(+0.0) = +INF\nV_RSQ_F16(0x4400) => 0x3800 // rsq(+4.0) = +0.5\nV_RSQ_F16(0x7c00) => 0x0000 // rsq(+INF) = +0"}, "v_log_f16": {"desc": "Calculate the base 2 logarithm of the half-precision float input and store the result into a vector register.", "code": "D0.f16 = log2(S0.f16)", "notes": "0.51ULP accuracy, denormals are supported.\nFunctional examples:\nV_LOG_F16(0xfc00) => 0xfe00 // log(-INF) = NAN\nV_LOG_F16(0xbc00) => 0xfe00 // log(-1.0) = NAN\nV_LOG_F16(0x8000) => 0xfc00 // log(-0.0) = -INF\nV_LOG_F16(0x0000) => 0xfc00 // log(+0.0) = -INF\nV_LOG_F16(0x3c00) => 0x0000 // log(+1.0) = 0\nV_LOG_F16(0x7c00) => 0x7c00 // log(+INF) = +INF"}, "v_exp_f16": {"desc": "Calculate 2 raised to the power of the half-precision float input and store the result into a vector register.\n\"RDNA3\" Instruction Set Architecture\nFunctional examples:", "code": "D0.f16 = pow(16'2.0, S0.f16)\nV_EXP_F16(0xfc00) => 0x0000 // exp(-INF) = 0\nV_EXP_F16(0x8000) => 0x3c00 // exp(-0.0) = 1\nV_EXP_F16(0x7c00) => 0x7c00 // exp(+INF) = +INF", "notes": "0.51ULP accuracy, denormals are supported.\n16.12. VOP3 & VOP3SD Instructions 387 of 600"}, "v_frexp_mant_f16": {"desc": "Extract the binary significand, or mantissa, of an FP16 float input and store the result as an FP16 float into a\nvector register.", "code": "if ((64'F(S0.f16) == +INF) || (64'F(S0.f16) == -INF) || isNAN(64'F(S0.f16))) then\nD0.f16 = S0.f16\nelse\nD0.f16 = mantissa(S0.f16)\nendif", "notes": "This operation satisfies the invariant S0.f16 = significand * (2 ** exponent). Result range is in (-1.0,-0.5][0.5,1.0)\nin normal cases. See also V_FREXP_EXP_I_F16, which returns integer exponent. See the C library function\nfrexp() for more information."}, "v_frexp_exp_i16_f16": {"desc": "Extract the exponent of an FP16 float input and store the result as a signed 16-bit integer into a vector register.", "code": "if ((64'F(S0.f16) == +INF) || (64'F(S0.f16) == -INF) || isNAN(64'F(S0.f16))) then\nD0.i16 = 16'0\nelse\nD0.i16 = 16'I(exponent(S0.f16) - 15 + 1)\nendif", "notes": "This operation satisfies the invariant S0.f16 = significand * (2 ** exponent). See also V_FREXP_MANT_F16,\nwhich returns the significand. See the C library function frexp() for more information."}, "v_floor_f16": {"desc": "Round the half-precision float input down to previous integer and store the result in floating point format into\na vector register.\n16.12. VOP3 & VOP3SD Instructions 388 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.f16 = trunc(S0.f16);\nif ((S0.f16 < 16'0.0) && (S0.f16 != D0.f16)) then\nD0.f16 += -16'1.0\nendif", "notes": ""}, "v_ceil_f16": {"desc": "Round the half-precision float input up to next integer and store the result in floating point format into a vector\nregister.", "code": "D0.f16 = trunc(S0.f16);\nif ((S0.f16 > 16'0.0) && (S0.f16 != D0.f16)) then\nD0.f16 += 16'1.0\nendif", "notes": ""}, "v_trunc_f16": {"desc": "Compute the integer part of an FP16 float input with round-toward-zero semantics and store the result in\nfloating point format into a vector register.", "code": "D0.f16 = trunc(S0.f16)", "notes": ""}, "v_rndne_f16": {"desc": "Round the half-precision float input to the nearest even integer and store the result in floating point format\ninto a vector register.", "code": "D0.f16 = floor(S0.f16 + 16'0.5);\nif (isEven(64'F(floor(S0.f16))) && (fract(S0.f16) == 16'0.5)) then\nD0.f16 -= 16'1.0\nendif", "notes": ""}, "v_fract_f16": {"desc": "Compute the fractional portion of an FP16 float input and store the result in floating point format into a vector\nregister.\n16.12. VOP3 & VOP3SD Instructions 389 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.f16 = S0.f16 + -floor(S0.f16)", "notes": "0.5ULP accuracy, denormals are accepted.\nThis is intended to comply with the DX specification of fract where the function behaves like an extension of\ninteger modulus; be aware this may differ from how fract() is defined in other domains. For example: fract(-\n1.2) = 0.8 in DX."}, "v_sin_f16": {"desc": "Calculate the trigonometric sine of an FP16 float value using IEEE rules and store the result into a vector\nregister. The operand is calculated by scaling the vector input by 2 PI.", "code": "D0.f16 = 16'F(sin(64'F(S0.f16) * 2.0 * PI))", "notes": "Denormals are supported. Full range input is supported.\nFunctional examples:\nV_SIN_F16(0xfc00) => 0xfe00 // sin(-INF) = NAN\nV_SIN_F16(0xfbff) => 0x0000 // Most negative finite FP16\nV_SIN_F16(0x8000) => 0x8000 // sin(-0.0) = -0\nV_SIN_F16(0x3400) => 0x3c00 // sin(0.25) = 1\nV_SIN_F16(0x7bff) => 0x0000 // Most positive finite FP16\nV_SIN_F16(0x7c00) => 0xfe00 // sin(+INF) = NAN"}, "v_cos_f16": {"desc": "Calculate the trigonometric cosine of an FP16 float value using IEEE rules and store the result into a vector\nregister. The operand is calculated by scaling the vector input by 2 PI.\n\"RDNA3\" Instruction Set Architecture", "code": "D0.f16 = 16'F(cos(64'F(S0.f16) * 2.0 * PI))\nV_COS_F16(0x7bff) => 0x3c00 // Most positive finite FP16\nV_COS_F16(0x7c00) => 0xfe00 // cos(+INF) = NAN", "notes": "Denormals are supported. Full range input is supported.\nFunctional examples:\nV_COS_F16(0xfc00) => 0xfe00 // cos(-INF) = NAN\nV_COS_F16(0xfbff) => 0x3c00 // Most negative finite FP16\nV_COS_F16(0x8000) => 0x3c00 // cos(-0.0) = 1\nV_COS_F16(0x3400) => 0x0000 // cos(0.25) = 0\n16.12. VOP3 & VOP3SD Instructions 390 of 600"}, "v_sat_pk_u8_i16": {"desc": "Given two 16-bit unsigned integer inputs, saturate each input over an 8-bit unsigned range, pack the resulting\nvalues into a 16-bit word and store the result into a vector register.", "code": "SAT8 = lambda(n) (\nif n.i <= 0 then\nreturn 8'0U\nelsif n >= 16'I(0xff) then\nreturn 8'255U\nelse\nreturn n[7 : 0].u8\nendif);\nD0.b16 = { SAT8(S0[31 : 16].i16), SAT8(S0[15 : 0].i16) }", "notes": "Used for 4x16bit data packed as 4x8bit data."}, "v_cvt_norm_i16_f16": {"desc": "Convert from an FP16 float input to a signed normalized short and store the result into a vector register.", "code": "D0.i16 = f16_to_snorm(S0.f16)", "notes": "0.5ULP accuracy, supports rounding, exception flags and saturation, denormals are supported."}, "v_cvt_norm_u16_f16": {"desc": "Convert from an FP16 float input to an unsigned normalized short and store the result into a vector register.\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u16 = f16_to_unorm(S0.f16)", "notes": "0.5ULP accuracy, supports rounding, exception flags and saturation, denormals are supported.\n16.12. VOP3 & VOP3SD Instructions 391 of 600"}, "v_swap_b32": {"desc": "Swap the values in two vector registers.\n16.8. VOP1 Instructions 291 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = D0.b;\nD0.b = S0.b;\nS0.b = tmp", "notes": "Input and output modifiers not supported; this is an untyped operation."}, "v_swap_b16": {"desc": "Swap the values in two vector registers.", "code": "tmp = D0.b16;\nD0.b16 = S0.b16;\nS0.b16 = tmp", "notes": "Input and output modifiers not supported; this is an untyped operation."}, "v_permlane64_b32": {"desc": "Perform a specific permutation across lanes where the high half and low half of a wave64 are swapped.\nPerforms no operation in wave32 mode.\n\"RDNA3\" Instruction Set Architecture\nABS, NEG and OMOD modifiers should all be zeroed for this instruction.", "code": "declare tmp : 32'B[64];\ndeclare lane : 32'U;\nif WAVE32 then\n// Supported in wave64 ONLY\nv_nop()\nelse\nfor lane in 0U : 63U do\n// Copy original S0 in case D==S0\ntmp[lane] = VGPR[lane][SRC0.u]\nendfor;\nfor lane in 0U : 63U do\naltlane = { ~lane[5], lane[4 : 0] };\n// 0<->32, ..., 31<->63\nif EXEC[lane].u1 then\nVGPR[lane][VDST.u] = tmp[altlane]\nendif\nendfor\nendif", "notes": "In wave32 mode this opcode is translated to V_NOP and performs no writes.\nIn wave64 the EXEC mask of the destination lane is used as the read mask for the alternate lane; as a result this\nopcode may read values from disabled lanes.\nThe source must be a VGPR and SVGPRs are not allowed for this opcode.\n16.8. VOP1 Instructions 292 of 600"}, "v_swaprel_b32": {"desc": "Swap values of two operands. The two addresses are relatively indexed using M0.", "code": "addrs = SRC0.u;\n// Raw value from instruction\naddrd = DST.u;\n// Raw value from instruction\naddrs += M0.u[9 : 0].u;\naddrd += M0.u[25 : 16].u;\ntmp = VGPR[laneId][addrd].b;\nVGPR[laneId][addrd].b = VGPR[laneId][addrs].b;\nVGPR[laneId][addrs].b = tmp", "notes": "Input and output modifiers not supported; this is an untyped operation.\nExample: The following instruction sequence swaps v25 and v17:\ns_mov_b32 m0, ((20 << 16) | 10)\nv_swaprel_b32 v5, v7"}, "v_not_b16": {"desc": "Calculate bitwise negation on a vector input and store the result into a vector register.", "code": "D0.u16 = ~S0.u16", "notes": "Input and output modifiers not supported."}, "v_cvt_i32_i16": {"desc": "Convert from an 16-bit signed integer to a 32-bit signed integer, sign extending as needed.", "code": "D0.i = 32'I(signext(S0.i16))", "notes": "To convert in the other direction (from 32-bit to 16-bit integer) use V_MOV_B16."}, "v_cvt_u32_u16": {"desc": "Convert from an 16-bit unsigned integer to a 32-bit unsigned integer, zero extending as needed.", "code": "D0 = { 16'0, S0.u16 }", "notes": "To convert in the other direction (from 32-bit to 16-bit integer) use V_MOV_B16."}, "v_cmp_f_f16": {"desc": "Return 0.", "code": "D0.u64[laneId] = 1'0U;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_lt_f16": {"desc": "Return 1 iff A less than B.", "code": "D0.u64[laneId] = S0.f16 < S1.f16;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_eq_f16": {"desc": "Return 1 iff A equal to B.\n\"RDNA3\" Instruction Set Architecture\nSignal 'invalid' on sNAN's, and also on qNAN's if clamp is set.", "code": "D0.u64[laneId] = S0.f16 == S1.f16;\n// D0 = VCC in VOPC encoding.", "notes": "16.12. VOP3 & VOP3SD Instructions 444 of 600"}, "v_cmp_le_f16": {"desc": "Return 1 iff A less than or equal to B.", "code": "D0.u64[laneId] = S0.f16 <= S1.f16;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_gt_f16": {"desc": "Return 1 iff A greater than B.", "code": "D0.u64[laneId] = S0.f16 > S1.f16;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_lg_f16": {"desc": "Return 1 iff A less than or greater than B.", "code": "D0.u64[laneId] = S0.f16 <> S1.f16;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_ge_f16": {"desc": "Return 1 iff A greater than or equal to B.\n16.12. VOP3 & VOP3SD Instructions 445 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u64[laneId] = S0.f16 >= S1.f16;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_o_f16": {"desc": "Return 1 iff A orderable with B.", "code": "D0.u64[laneId] = (!isNAN(64'F(S0.f16)) && !isNAN(64'F(S1.f16)));\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_u_f16": {"desc": "Return 1 iff A not orderable with B.", "code": "D0.u64[laneId] = (isNAN(64'F(S0.f16)) || isNAN(64'F(S1.f16)));\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_nge_f16": {"desc": "Return 1 iff A not greater than or equal to B.\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u64[laneId] = !(S0.f16 >= S1.f16);\n// With NAN inputs this is not the same operation as <\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.\n16.12. VOP3 & VOP3SD Instructions 446 of 600"}, "v_cmp_nlg_f16": {"desc": "Return 1 iff A not less than or greater than B.", "code": "D0.u64[laneId] = !(S0.f16 <> S1.f16);\n// With NAN inputs this is not the same operation as ==\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_ngt_f16": {"desc": "Return 1 iff A not greater than B.", "code": "D0.u64[laneId] = !(S0.f16 > S1.f16);\n// With NAN inputs this is not the same operation as <=\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_nle_f16": {"desc": "Return 1 iff A not less than or equal to B.", "code": "D0.u64[laneId] = !(S0.f16 <= S1.f16);\n// With NAN inputs this is not the same operation as >\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_neq_f16": {"desc": "Return 1 iff A not equal to B.\n16.12. VOP3 & VOP3SD Instructions 447 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u64[laneId] = !(S0.f16 == S1.f16);\n// With NAN inputs this is not the same operation as !=\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_nlt_f16": {"desc": "Return 1 iff A not less than B.", "code": "D0.u64[laneId] = !(S0.f16 < S1.f16);\n// With NAN inputs this is not the same operation as >=\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_t_f16": {"desc": "Return 1.", "code": "D0.u64[laneId] = 1'1U;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_f_f32": {"desc": "Return 0.\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u64[laneId] = 1'0U;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.\n16.12. VOP3 & VOP3SD Instructions 448 of 600"}, "v_cmp_lt_f32": {"desc": "Return 1 iff A less than B.", "code": "D0.u64[laneId] = S0.f < S1.f;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_eq_f32": {"desc": "Return 1 iff A equal to B.", "code": "D0.u64[laneId] = S0.f == S1.f;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_le_f32": {"desc": "Return 1 iff A less than or equal to B.", "code": "D0.u64[laneId] = S0.f <= S1.f;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_gt_f32": {"desc": "Return 1 iff A greater than B.\n\"RDNA3\" Instruction Set Architecture\nSignal 'invalid' on sNAN's, and also on qNAN's if clamp is set.", "code": "D0.u64[laneId] = S0.f > S1.f;\n// D0 = VCC in VOPC encoding.", "notes": "16.12. VOP3 & VOP3SD Instructions 449 of 600"}, "v_cmp_lg_f32": {"desc": "Return 1 iff A less than or greater than B.", "code": "D0.u64[laneId] = S0.f <> S1.f;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_ge_f32": {"desc": "Return 1 iff A greater than or equal to B.", "code": "D0.u64[laneId] = S0.f >= S1.f;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_o_f32": {"desc": "Return 1 iff A orderable with B.", "code": "D0.u64[laneId] = (!isNAN(64'F(S0.f)) && !isNAN(64'F(S1.f)));\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_u_f32": {"desc": "Return 1 iff A not orderable with B.\n16.12. VOP3 & VOP3SD Instructions 450 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u64[laneId] = (isNAN(64'F(S0.f)) || isNAN(64'F(S1.f)));\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_nge_f32": {"desc": "Return 1 iff A not greater than or equal to B.", "code": "D0.u64[laneId] = !(S0.f >= S1.f);\n// With NAN inputs this is not the same operation as <\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_nlg_f32": {"desc": "Return 1 iff A not less than or greater than B.", "code": "D0.u64[laneId] = !(S0.f <> S1.f);\n// With NAN inputs this is not the same operation as ==\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_ngt_f32": {"desc": "Return 1 iff A not greater than B.\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u64[laneId] = !(S0.f > S1.f);\n// With NAN inputs this is not the same operation as <=\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.\n16.12. VOP3 & VOP3SD Instructions 451 of 600"}, "v_cmp_nle_f32": {"desc": "Return 1 iff A not less than or equal to B.", "code": "D0.u64[laneId] = !(S0.f <= S1.f);\n// With NAN inputs this is not the same operation as >\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_neq_f32": {"desc": "Return 1 iff A not equal to B.", "code": "D0.u64[laneId] = !(S0.f == S1.f);\n// With NAN inputs this is not the same operation as !=\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_nlt_f32": {"desc": "Return 1 iff A not less than B.", "code": "D0.u64[laneId] = !(S0.f < S1.f);\n// With NAN inputs this is not the same operation as >=\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_t_f32": {"desc": "Return 1.\n16.12. VOP3 & VOP3SD Instructions 452 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u64[laneId] = 1'1U;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_f_f64": {"desc": "Return 0.", "code": "D0.u64[laneId] = 1'0U;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_lt_f64": {"desc": "Return 1 iff A less than B.", "code": "D0.u64[laneId] = S0.f64 < S1.f64;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_eq_f64": {"desc": "Return 1 iff A equal to B.", "code": "D0.u64[laneId] = S0.f64 == S1.f64;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_le_f64": {"desc": "Return 1 iff A less than or equal to B.\n16.12. VOP3 & VOP3SD Instructions 453 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u64[laneId] = S0.f64 <= S1.f64;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_gt_f64": {"desc": "Return 1 iff A greater than B.", "code": "D0.u64[laneId] = S0.f64 > S1.f64;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_lg_f64": {"desc": "Return 1 iff A less than or greater than B.", "code": "D0.u64[laneId] = S0.f64 <> S1.f64;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_ge_f64": {"desc": "Return 1 iff A greater than or equal to B.\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u64[laneId] = S0.f64 >= S1.f64;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.\n16.12. VOP3 & VOP3SD Instructions 454 of 600"}, "v_cmp_o_f64": {"desc": "Return 1 iff A orderable with B.", "code": "D0.u64[laneId] = (!isNAN(S0.f64) && !isNAN(S1.f64));\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_u_f64": {"desc": "Return 1 iff A not orderable with B.", "code": "D0.u64[laneId] = (isNAN(S0.f64) || isNAN(S1.f64));\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_nge_f64": {"desc": "Return 1 iff A not greater than or equal to B.", "code": "D0.u64[laneId] = !(S0.f64 >= S1.f64);\n// With NAN inputs this is not the same operation as <\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_nlg_f64": {"desc": "Return 1 iff A not less than or greater than B.\n16.12. VOP3 & VOP3SD Instructions 455 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u64[laneId] = !(S0.f64 <> S1.f64);\n// With NAN inputs this is not the same operation as ==\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_ngt_f64": {"desc": "Return 1 iff A not greater than B.", "code": "D0.u64[laneId] = !(S0.f64 > S1.f64);\n// With NAN inputs this is not the same operation as <=\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_nle_f64": {"desc": "Return 1 iff A not less than or equal to B.", "code": "D0.u64[laneId] = !(S0.f64 <= S1.f64);\n// With NAN inputs this is not the same operation as >\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_neq_f64": {"desc": "Return 1 iff A not equal to B.", "code": "D0.u64[laneId] = !(S0.f64 == S1.f64);\n// With NAN inputs this is not the same operation as !=\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_nlt_f64": {"desc": "16.12. VOP3 & VOP3SD Instructions 456 of 600\n\"RDNA3\" Instruction Set Architecture\nReturn 1 iff A not less than B.", "code": "D0.u64[laneId] = !(S0.f64 < S1.f64);\n// With NAN inputs this is not the same operation as >=\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_t_f64": {"desc": "Return 1.", "code": "D0.u64[laneId] = 1'1U;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_lt_i16": {"desc": "Return 1 iff A less than B.", "code": "D0.u64[laneId] = S0.i16 < S1.i16;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_eq_i16": {"desc": "Return 1 iff A equal to B.\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u64[laneId] = S0.i16 == S1.i16;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.\n16.12. VOP3 & VOP3SD Instructions 457 of 600"}, "v_cmp_le_i16": {"desc": "Return 1 iff A less than or equal to B.", "code": "D0.u64[laneId] = S0.i16 <= S1.i16;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_gt_i16": {"desc": "Return 1 iff A greater than B.", "code": "D0.u64[laneId] = S0.i16 > S1.i16;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_ne_i16": {"desc": "Return 1 iff A not equal to B.", "code": "D0.u64[laneId] = S0.i16 <> S1.i16;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_ge_i16": {"desc": "Return 1 iff A greater than or equal to B.\n16.12. VOP3 & VOP3SD Instructions 458 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u64[laneId] = S0.i16 >= S1.i16;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_lt_u16": {"desc": "Return 1 iff A less than B.", "code": "D0.u64[laneId] = S0.u16 < S1.u16;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_eq_u16": {"desc": "Return 1 iff A equal to B.", "code": "D0.u64[laneId] = S0.u16 == S1.u16;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_le_u16": {"desc": "Return 1 iff A less than or equal to B.", "code": "D0.u64[laneId] = S0.u16 <= S1.u16;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_gt_u16": {"desc": "Return 1 iff A greater than B.\n16.12. VOP3 & VOP3SD Instructions 459 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u64[laneId] = S0.u16 > S1.u16;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_ne_u16": {"desc": "Return 1 iff A not equal to B.", "code": "D0.u64[laneId] = S0.u16 <> S1.u16;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_ge_u16": {"desc": "Return 1 iff A greater than or equal to B.", "code": "D0.u64[laneId] = S0.u16 >= S1.u16;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_f_i32": {"desc": "Return 0.\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u64[laneId] = 1'0U;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.\n16.12. VOP3 & VOP3SD Instructions 460 of 600"}, "v_cmp_lt_i32": {"desc": "Return 1 iff A less than B.", "code": "D0.u64[laneId] = S0.i < S1.i;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_eq_i32": {"desc": "Return 1 iff A equal to B.", "code": "D0.u64[laneId] = S0.i == S1.i;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_le_i32": {"desc": "Return 1 iff A less than or equal to B.", "code": "D0.u64[laneId] = S0.i <= S1.i;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_gt_i32": {"desc": "Return 1 iff A greater than B.\n\"RDNA3\" Instruction Set Architecture\nSignal 'invalid' on sNAN's, and also on qNAN's if clamp is set.", "code": "D0.u64[laneId] = S0.i > S1.i;\n// D0 = VCC in VOPC encoding.", "notes": "16.12. VOP3 & VOP3SD Instructions 461 of 600"}, "v_cmp_ne_i32": {"desc": "Return 1 iff A not equal to B.", "code": "D0.u64[laneId] = S0.i <> S1.i;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_ge_i32": {"desc": "Return 1 iff A greater than or equal to B.", "code": "D0.u64[laneId] = S0.i >= S1.i;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_t_i32": {"desc": "Return 1.", "code": "D0.u64[laneId] = 1'1U;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_f_u32": {"desc": "Return 0.\n16.12. VOP3 & VOP3SD Instructions 462 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u64[laneId] = 1'0U;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_lt_u32": {"desc": "Return 1 iff A less than B.", "code": "D0.u64[laneId] = S0.u < S1.u;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_eq_u32": {"desc": "Return 1 iff A equal to B.", "code": "D0.u64[laneId] = S0.u == S1.u;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_le_u32": {"desc": "Return 1 iff A less than or equal to B.", "code": "D0.u64[laneId] = S0.u <= S1.u;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_gt_u32": {"desc": "16.12. VOP3 & VOP3SD Instructions 463 of 600\n\"RDNA3\" Instruction Set Architecture\nReturn 1 iff A greater than B.", "code": "D0.u64[laneId] = S0.u > S1.u;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_ne_u32": {"desc": "Return 1 iff A not equal to B.", "code": "D0.u64[laneId] = S0.u <> S1.u;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_ge_u32": {"desc": "Return 1 iff A greater than or equal to B.", "code": "D0.u64[laneId] = S0.u >= S1.u;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_t_u32": {"desc": "Return 1.\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u64[laneId] = 1'1U;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.\n16.12. VOP3 & VOP3SD Instructions 464 of 600"}, "v_cmp_f_i64": {"desc": "Return 0.", "code": "D0.u64[laneId] = 1'0U;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_lt_i64": {"desc": "Return 1 iff A less than B.", "code": "D0.u64[laneId] = S0.i64 < S1.i64;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_eq_i64": {"desc": "Return 1 iff A equal to B.", "code": "D0.u64[laneId] = S0.i64 == S1.i64;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_le_i64": {"desc": "Return 1 iff A less than or equal to B.\n16.12. VOP3 & VOP3SD Instructions 465 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u64[laneId] = S0.i64 <= S1.i64;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_gt_i64": {"desc": "Return 1 iff A greater than B.", "code": "D0.u64[laneId] = S0.i64 > S1.i64;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_ne_i64": {"desc": "Return 1 iff A not equal to B.", "code": "D0.u64[laneId] = S0.i64 <> S1.i64;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_ge_i64": {"desc": "Return 1 iff A greater than or equal to B.", "code": "D0.u64[laneId] = S0.i64 >= S1.i64;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_t_i64": {"desc": "Return 1.\n16.12. VOP3 & VOP3SD Instructions 466 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u64[laneId] = 1'1U;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_f_u64": {"desc": "Return 0.", "code": "D0.u64[laneId] = 1'0U;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_lt_u64": {"desc": "Return 1 iff A less than B.", "code": "D0.u64[laneId] = S0.u64 < S1.u64;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_eq_u64": {"desc": "Return 1 iff A equal to B.\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u64[laneId] = S0.u64 == S1.u64;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.\n16.12. VOP3 & VOP3SD Instructions 467 of 600"}, "v_cmp_le_u64": {"desc": "Return 1 iff A less than or equal to B.", "code": "D0.u64[laneId] = S0.u64 <= S1.u64;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_gt_u64": {"desc": "Return 1 iff A greater than B.", "code": "D0.u64[laneId] = S0.u64 > S1.u64;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_ne_u64": {"desc": "Return 1 iff A not equal to B.", "code": "D0.u64[laneId] = S0.u64 <> S1.u64;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_ge_u64": {"desc": "Return 1 iff A greater than or equal to B.\n\"RDNA3\" Instruction Set Architecture\nSignal 'invalid' on sNAN's, and also on qNAN's if clamp is set.", "code": "D0.u64[laneId] = S0.u64 >= S1.u64;\n// D0 = VCC in VOPC encoding.", "notes": "16.12. VOP3 & VOP3SD Instructions 468 of 600"}, "v_cmp_t_u64": {"desc": "Return 1.", "code": "D0.u64[laneId] = 1'1U;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_class_f16": {"desc": "IEEE numeric class function specified in S1.u, performed on S0.f16.\nThe function reports true if the floating point value is any of the numeric types selected in S1.u according to the\nfollowing list:\nS1.u[0] -- value is a signaling NAN.\nS1.u[1] -- value is a quiet NAN.\nS1.u[2] -- value is negative infinity.\nS1.u[3] -- value is a negative normal value.\nS1.u[4] -- value is a negative denormal value.\nS1.u[5] -- value is negative zero.\nS1.u[6] -- value is positive zero.\nS1.u[7] -- value is a positive denormal value.\nS1.u[8] -- value is a positive normal value.\nS1.u[9] -- value is positive infinity.\n16.12. VOP3 & VOP3SD Instructions 469 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "declare result : 1'U;\nif isSignalNAN(64'F(S0.f16)) then\nresult = S1.u[0]\nelsif isQuietNAN(64'F(S0.f16)) then\nresult = S1.u[1]\nelsif exponent(S0.f16) == 31 then\n// +-INF\nresult = S1.u[sign(S0.f16) ? 2 : 9]\nelsif exponent(S0.f16) > 0 then\n// +-normal value\nresult = S1.u[sign(S0.f16) ? 3 : 8]\nelsif 64'F(abs(S0.f16)) > 0.0 then\n// +-denormal value\nresult = S1.u[sign(S0.f16) ? 4 : 7]\nelse\n// +-0.0\nresult = S1.u[sign(S0.f16) ? 5 : 6]\nendif;\nD0.u64[laneId] = result;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmp_class_f32": {"desc": "IEEE numeric class function specified in S1.u, performed on S0.f.\nThe function reports true if the floating point value is any of the numeric types selected in S1.u according to the\nfollowing list:\nS1.u[0] -- value is a signaling NAN.\nS1.u[1] -- value is a quiet NAN.\nS1.u[2] -- value is negative infinity.\nS1.u[3] -- value is a negative normal value.\nS1.u[4] -- value is a negative denormal value.\nS1.u[5] -- value is negative zero.\nS1.u[6] -- value is positive zero.\nS1.u[7] -- value is a positive denormal value.\nS1.u[8] -- value is a positive normal value.\nS1.u[9] -- value is positive infinity.\n\"RDNA3\" Instruction Set Architecture", "code": "declare result : 1'U;\nif isSignalNAN(64'F(S0.f)) then\nresult = S1.u[0]\nelsif isQuietNAN(64'F(S0.f)) then\nresult = S1.u[1]\nelsif exponent(S0.f) == 255 then\n// +-INF\nresult = S1.u[sign(S0.f) ? 2 : 9]\nelsif exponent(S0.f) > 0 then\n// +-normal value\nresult = S1.u[sign(S0.f) ? 3 : 8]\nelsif 64'F(abs(S0.f)) > 0.0 then\n// +-denormal value\nresult = S1.u[sign(S0.f) ? 4 : 7]\nelse\n// +-0.0\nresult = S1.u[sign(S0.f) ? 5 : 6]\nendif;\nD0.u64[laneId] = result;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.\n16.12. VOP3 & VOP3SD Instructions 470 of 600"}, "v_cmp_class_f64": {"desc": "IEEE numeric class function specified in S1.u, performed on S0.f64.\nThe function reports true if the floating point value is any of the numeric types selected in S1.u according to the\nfollowing list:\nS1.u[0] -- value is a signaling NAN.\nS1.u[1] -- value is a quiet NAN.\nS1.u[2] -- value is negative infinity.\nS1.u[3] -- value is a negative normal value.\nS1.u[4] -- value is a negative denormal value.\nS1.u[5] -- value is negative zero.\nS1.u[6] -- value is positive zero.\nS1.u[7] -- value is a positive denormal value.\nS1.u[8] -- value is a positive normal value.\nS1.u[9] -- value is positive infinity.", "code": "declare result : 1'U;\nif isSignalNAN(S0.f64) then\nresult = S1.u[0]\nelsif isQuietNAN(S0.f64) then\nresult = S1.u[1]\nelsif exponent(S0.f64) == 1023 then\n// +-INF\nresult = S1.u[sign(S0.f64) ? 2 : 9]\nelsif exponent(S0.f64) > 0 then\n// +-normal value\nresult = S1.u[sign(S0.f64) ? 3 : 8]\nelsif abs(S0.f64) > 0.0 then\n// +-denormal value\nresult = S1.u[sign(S0.f64) ? 4 : 7]\nelse\n// +-0.0\nresult = S1.u[sign(S0.f64) ? 5 : 6]\nendif;\nD0.u64[laneId] = result;\n// D0 = VCC in VOPC encoding.", "notes": "Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_f_f16": {"desc": "Return 0.\n16.12. VOP3 & VOP3SD Instructions 471 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "EXEC.u64[laneId] = 1'0U", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_lt_f16": {"desc": "Return 1 iff A less than B.", "code": "EXEC.u64[laneId] = S0.f16 < S1.f16", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_eq_f16": {"desc": "Return 1 iff A equal to B.", "code": "EXEC.u64[laneId] = S0.f16 == S1.f16", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_le_f16": {"desc": "Return 1 iff A less than or equal to B.", "code": "EXEC.u64[laneId] = S0.f16 <= S1.f16", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_gt_f16": {"desc": "Return 1 iff A greater than B.\n16.12. VOP3 & VOP3SD Instructions 472 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "EXEC.u64[laneId] = S0.f16 > S1.f16", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_lg_f16": {"desc": "Return 1 iff A less than or greater than B.", "code": "EXEC.u64[laneId] = S0.f16 <> S1.f16", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_ge_f16": {"desc": "Return 1 iff A greater than or equal to B.", "code": "EXEC.u64[laneId] = S0.f16 >= S1.f16", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_o_f16": {"desc": "Return 1 iff A orderable with B.", "code": "EXEC.u64[laneId] = (!isNAN(64'F(S0.f16)) && !isNAN(64'F(S1.f16)))", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_u_f16": {"desc": "Return 1 iff A not orderable with B.\n16.12. VOP3 & VOP3SD Instructions 473 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "EXEC.u64[laneId] = (isNAN(64'F(S0.f16)) || isNAN(64'F(S1.f16)))", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_nge_f16": {"desc": "Return 1 iff A not greater than or equal to B.", "code": "EXEC.u64[laneId] = !(S0.f16 >= S1.f16);\n// With NAN inputs this is not the same operation as <", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_nlg_f16": {"desc": "Return 1 iff A not less than or greater than B.", "code": "EXEC.u64[laneId] = !(S0.f16 <> S1.f16);\n// With NAN inputs this is not the same operation as ==", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_ngt_f16": {"desc": "Return 1 iff A not greater than B.\n\"RDNA3\" Instruction Set Architecture", "code": "EXEC.u64[laneId] = !(S0.f16 > S1.f16);\n// With NAN inputs this is not the same operation as <=", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.\n16.12. VOP3 & VOP3SD Instructions 474 of 600"}, "v_cmpx_nle_f16": {"desc": "Return 1 iff A not less than or equal to B.", "code": "EXEC.u64[laneId] = !(S0.f16 <= S1.f16);\n// With NAN inputs this is not the same operation as >", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_neq_f16": {"desc": "Return 1 iff A not equal to B.", "code": "EXEC.u64[laneId] = !(S0.f16 == S1.f16);\n// With NAN inputs this is not the same operation as !=", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_nlt_f16": {"desc": "Return 1 iff A not less than B.", "code": "EXEC.u64[laneId] = !(S0.f16 < S1.f16);\n// With NAN inputs this is not the same operation as >=", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_t_f16": {"desc": "Return 1.\n\"RDNA3\" Instruction Set Architecture\nWrite only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.", "code": "EXEC.u64[laneId] = 1'1U", "notes": "16.12. VOP3 & VOP3SD Instructions 475 of 600"}, "v_cmpx_f_f32": {"desc": "Return 0.", "code": "EXEC.u64[laneId] = 1'0U", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_lt_f32": {"desc": "Return 1 iff A less than B.", "code": "EXEC.u64[laneId] = S0.f < S1.f", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_eq_f32": {"desc": "Return 1 iff A equal to B.", "code": "EXEC.u64[laneId] = S0.f == S1.f", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_le_f32": {"desc": "Return 1 iff A less than or equal to B.\n\"RDNA3\" Instruction Set Architecture\nWrite only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.", "code": "EXEC.u64[laneId] = S0.f <= S1.f", "notes": "16.12. VOP3 & VOP3SD Instructions 476 of 600"}, "v_cmpx_gt_f32": {"desc": "Return 1 iff A greater than B.", "code": "EXEC.u64[laneId] = S0.f > S1.f", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_lg_f32": {"desc": "Return 1 iff A less than or greater than B.", "code": "EXEC.u64[laneId] = S0.f <> S1.f", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_ge_f32": {"desc": "Return 1 iff A greater than or equal to B.", "code": "EXEC.u64[laneId] = S0.f >= S1.f", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_o_f32": {"desc": "Return 1 iff A orderable with B.\n\"RDNA3\" Instruction Set Architecture\nWrite only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.", "code": "EXEC.u64[laneId] = (!isNAN(64'F(S0.f)) && !isNAN(64'F(S1.f)))", "notes": "16.12. VOP3 & VOP3SD Instructions 477 of 600"}, "v_cmpx_u_f32": {"desc": "Return 1 iff A not orderable with B.", "code": "EXEC.u64[laneId] = (isNAN(64'F(S0.f)) || isNAN(64'F(S1.f)))", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_nge_f32": {"desc": "Return 1 iff A not greater than or equal to B.", "code": "EXEC.u64[laneId] = !(S0.f >= S1.f);\n// With NAN inputs this is not the same operation as <", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_nlg_f32": {"desc": "Return 1 iff A not less than or greater than B.", "code": "EXEC.u64[laneId] = !(S0.f <> S1.f);\n// With NAN inputs this is not the same operation as ==", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_ngt_f32": {"desc": "Return 1 iff A not greater than B.\n16.12. VOP3 & VOP3SD Instructions 478 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "EXEC.u64[laneId] = !(S0.f > S1.f);\n// With NAN inputs this is not the same operation as <=", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_nle_f32": {"desc": "Return 1 iff A not less than or equal to B.", "code": "EXEC.u64[laneId] = !(S0.f <= S1.f);\n// With NAN inputs this is not the same operation as >", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_neq_f32": {"desc": "Return 1 iff A not equal to B.", "code": "EXEC.u64[laneId] = !(S0.f == S1.f);\n// With NAN inputs this is not the same operation as !=", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_nlt_f32": {"desc": "Return 1 iff A not less than B.", "code": "EXEC.u64[laneId] = !(S0.f < S1.f);\n// With NAN inputs this is not the same operation as >=", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_t_f32": {"desc": "16.12. VOP3 & VOP3SD Instructions 479 of 600\n\"RDNA3\" Instruction Set Architecture\nReturn 1.", "code": "EXEC.u64[laneId] = 1'1U", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_f_f64": {"desc": "Return 0.", "code": "EXEC.u64[laneId] = 1'0U", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_lt_f64": {"desc": "Return 1 iff A less than B.", "code": "EXEC.u64[laneId] = S0.f64 < S1.f64", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_eq_f64": {"desc": "Return 1 iff A equal to B.", "code": "EXEC.u64[laneId] = S0.f64 == S1.f64", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_le_f64": {"desc": "16.12. VOP3 & VOP3SD Instructions 480 of 600\n\"RDNA3\" Instruction Set Architecture\nReturn 1 iff A less than or equal to B.", "code": "EXEC.u64[laneId] = S0.f64 <= S1.f64", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_gt_f64": {"desc": "Return 1 iff A greater than B.", "code": "EXEC.u64[laneId] = S0.f64 > S1.f64", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_lg_f64": {"desc": "Return 1 iff A less than or greater than B.", "code": "EXEC.u64[laneId] = S0.f64 <> S1.f64", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_ge_f64": {"desc": "Return 1 iff A greater than or equal to B.", "code": "EXEC.u64[laneId] = S0.f64 >= S1.f64", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_o_f64": {"desc": "16.12. VOP3 & VOP3SD Instructions 481 of 600\n\"RDNA3\" Instruction Set Architecture\nReturn 1 iff A orderable with B.", "code": "EXEC.u64[laneId] = (!isNAN(S0.f64) && !isNAN(S1.f64))", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_u_f64": {"desc": "Return 1 iff A not orderable with B.", "code": "EXEC.u64[laneId] = (isNAN(S0.f64) || isNAN(S1.f64))", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_nge_f64": {"desc": "Return 1 iff A not greater than or equal to B.", "code": "EXEC.u64[laneId] = !(S0.f64 >= S1.f64);\n// With NAN inputs this is not the same operation as <", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_nlg_f64": {"desc": "Return 1 iff A not less than or greater than B.\n\"RDNA3\" Instruction Set Architecture", "code": "EXEC.u64[laneId] = !(S0.f64 <> S1.f64);\n// With NAN inputs this is not the same operation as ==", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.\n16.12. VOP3 & VOP3SD Instructions 482 of 600"}, "v_cmpx_ngt_f64": {"desc": "Return 1 iff A not greater than B.", "code": "EXEC.u64[laneId] = !(S0.f64 > S1.f64);\n// With NAN inputs this is not the same operation as <=", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_nle_f64": {"desc": "Return 1 iff A not less than or equal to B.", "code": "EXEC.u64[laneId] = !(S0.f64 <= S1.f64);\n// With NAN inputs this is not the same operation as >", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_neq_f64": {"desc": "Return 1 iff A not equal to B.", "code": "EXEC.u64[laneId] = !(S0.f64 == S1.f64);\n// With NAN inputs this is not the same operation as !=", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_nlt_f64": {"desc": "Return 1 iff A not less than B.\n\"RDNA3\" Instruction Set Architecture\nWrite only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.", "code": "EXEC.u64[laneId] = !(S0.f64 < S1.f64);\n// With NAN inputs this is not the same operation as >=", "notes": "16.12. VOP3 & VOP3SD Instructions 483 of 600"}, "v_cmpx_t_f64": {"desc": "Return 1.", "code": "EXEC.u64[laneId] = 1'1U", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_lt_i16": {"desc": "Return 1 iff A less than B.", "code": "EXEC.u64[laneId] = S0.i16 < S1.i16", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_eq_i16": {"desc": "Return 1 iff A equal to B.", "code": "EXEC.u64[laneId] = S0.i16 == S1.i16", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_le_i16": {"desc": "Return 1 iff A less than or equal to B.\n\"RDNA3\" Instruction Set Architecture\nWrite only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.", "code": "EXEC.u64[laneId] = S0.i16 <= S1.i16", "notes": "16.12. VOP3 & VOP3SD Instructions 484 of 600"}, "v_cmpx_gt_i16": {"desc": "Return 1 iff A greater than B.", "code": "EXEC.u64[laneId] = S0.i16 > S1.i16", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_ne_i16": {"desc": "Return 1 iff A not equal to B.", "code": "EXEC.u64[laneId] = S0.i16 <> S1.i16", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_ge_i16": {"desc": "Return 1 iff A greater than or equal to B.", "code": "EXEC.u64[laneId] = S0.i16 >= S1.i16", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_lt_u16": {"desc": "Return 1 iff A less than B.\n\"RDNA3\" Instruction Set Architecture\nWrite only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.", "code": "EXEC.u64[laneId] = S0.u16 < S1.u16", "notes": "16.12. VOP3 & VOP3SD Instructions 485 of 600"}, "v_cmpx_eq_u16": {"desc": "Return 1 iff A equal to B.", "code": "EXEC.u64[laneId] = S0.u16 == S1.u16", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_le_u16": {"desc": "Return 1 iff A less than or equal to B.", "code": "EXEC.u64[laneId] = S0.u16 <= S1.u16", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_gt_u16": {"desc": "Return 1 iff A greater than B.", "code": "EXEC.u64[laneId] = S0.u16 > S1.u16", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_ne_u16": {"desc": "Return 1 iff A not equal to B.\n\"RDNA3\" Instruction Set Architecture\nWrite only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.", "code": "EXEC.u64[laneId] = S0.u16 <> S1.u16", "notes": "16.12. VOP3 & VOP3SD Instructions 486 of 600"}, "v_cmpx_ge_u16": {"desc": "Return 1 iff A greater than or equal to B.", "code": "EXEC.u64[laneId] = S0.u16 >= S1.u16", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_f_i32": {"desc": "Return 0.", "code": "EXEC.u64[laneId] = 1'0U", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_lt_i32": {"desc": "Return 1 iff A less than B.", "code": "EXEC.u64[laneId] = S0.i < S1.i", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_eq_i32": {"desc": "Return 1 iff A equal to B.\n\"RDNA3\" Instruction Set Architecture\nWrite only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.", "code": "EXEC.u64[laneId] = S0.i == S1.i", "notes": "16.12. VOP3 & VOP3SD Instructions 487 of 600"}, "v_cmpx_le_i32": {"desc": "Return 1 iff A less than or equal to B.", "code": "EXEC.u64[laneId] = S0.i <= S1.i", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_gt_i32": {"desc": "Return 1 iff A greater than B.", "code": "EXEC.u64[laneId] = S0.i > S1.i", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_ne_i32": {"desc": "Return 1 iff A not equal to B.", "code": "EXEC.u64[laneId] = S0.i <> S1.i", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_ge_i32": {"desc": "Return 1 iff A greater than or equal to B.\n\"RDNA3\" Instruction Set Architecture\nWrite only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.", "code": "EXEC.u64[laneId] = S0.i >= S1.i", "notes": "16.12. VOP3 & VOP3SD Instructions 488 of 600"}, "v_cmpx_t_i32": {"desc": "Return 1.", "code": "EXEC.u64[laneId] = 1'1U", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_f_u32": {"desc": "Return 0.", "code": "EXEC.u64[laneId] = 1'0U", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_lt_u32": {"desc": "Return 1 iff A less than B.", "code": "EXEC.u64[laneId] = S0.u < S1.u", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_eq_u32": {"desc": "Return 1 iff A equal to B.\n\"RDNA3\" Instruction Set Architecture\nWrite only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.", "code": "EXEC.u64[laneId] = S0.u == S1.u", "notes": "16.12. VOP3 & VOP3SD Instructions 489 of 600"}, "v_cmpx_le_u32": {"desc": "Return 1 iff A less than or equal to B.", "code": "EXEC.u64[laneId] = S0.u <= S1.u", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_gt_u32": {"desc": "Return 1 iff A greater than B.", "code": "EXEC.u64[laneId] = S0.u > S1.u", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_ne_u32": {"desc": "Return 1 iff A not equal to B.", "code": "EXEC.u64[laneId] = S0.u <> S1.u", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_ge_u32": {"desc": "Return 1 iff A greater than or equal to B.\n\"RDNA3\" Instruction Set Architecture\nWrite only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.", "code": "EXEC.u64[laneId] = S0.u >= S1.u", "notes": "16.12. VOP3 & VOP3SD Instructions 490 of 600"}, "v_cmpx_t_u32": {"desc": "Return 1.", "code": "EXEC.u64[laneId] = 1'1U", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_f_i64": {"desc": "Return 0.", "code": "EXEC.u64[laneId] = 1'0U", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_lt_i64": {"desc": "Return 1 iff A less than B.", "code": "EXEC.u64[laneId] = S0.i64 < S1.i64", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_eq_i64": {"desc": "Return 1 iff A equal to B.\n\"RDNA3\" Instruction Set Architecture\nWrite only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.", "code": "EXEC.u64[laneId] = S0.i64 == S1.i64", "notes": "16.12. VOP3 & VOP3SD Instructions 491 of 600"}, "v_cmpx_le_i64": {"desc": "Return 1 iff A less than or equal to B.", "code": "EXEC.u64[laneId] = S0.i64 <= S1.i64", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_gt_i64": {"desc": "Return 1 iff A greater than B.", "code": "EXEC.u64[laneId] = S0.i64 > S1.i64", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_ne_i64": {"desc": "Return 1 iff A not equal to B.", "code": "EXEC.u64[laneId] = S0.i64 <> S1.i64", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_ge_i64": {"desc": "Return 1 iff A greater than or equal to B.\n\"RDNA3\" Instruction Set Architecture\nWrite only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.", "code": "EXEC.u64[laneId] = S0.i64 >= S1.i64", "notes": "16.12. VOP3 & VOP3SD Instructions 492 of 600"}, "v_cmpx_t_i64": {"desc": "Return 1.", "code": "EXEC.u64[laneId] = 1'1U", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_f_u64": {"desc": "Return 0.", "code": "EXEC.u64[laneId] = 1'0U", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_lt_u64": {"desc": "Return 1 iff A less than B.", "code": "EXEC.u64[laneId] = S0.u64 < S1.u64", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_eq_u64": {"desc": "Return 1 iff A equal to B.\n\"RDNA3\" Instruction Set Architecture\nWrite only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.", "code": "EXEC.u64[laneId] = S0.u64 == S1.u64", "notes": "16.12. VOP3 & VOP3SD Instructions 493 of 600"}, "v_cmpx_le_u64": {"desc": "Return 1 iff A less than or equal to B.", "code": "EXEC.u64[laneId] = S0.u64 <= S1.u64", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_gt_u64": {"desc": "Return 1 iff A greater than B.", "code": "EXEC.u64[laneId] = S0.u64 > S1.u64", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_ne_u64": {"desc": "Return 1 iff A not equal to B.", "code": "EXEC.u64[laneId] = S0.u64 <> S1.u64", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_ge_u64": {"desc": "Return 1 iff A greater than or equal to B.\n\"RDNA3\" Instruction Set Architecture\nWrite only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.", "code": "EXEC.u64[laneId] = S0.u64 >= S1.u64", "notes": "16.12. VOP3 & VOP3SD Instructions 494 of 600"}, "v_cmpx_t_u64": {"desc": "Return 1.", "code": "EXEC.u64[laneId] = 1'1U", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_class_f16": {"desc": "IEEE numeric class function specified in S1.u, performed on S0.f16.\nThe function reports true if the floating point value is any of the numeric types selected in S1.u according to the\nfollowing list:\nS1.u[0] -- value is a signaling NAN.\nS1.u[1] -- value is a quiet NAN.\nS1.u[2] -- value is negative infinity.\nS1.u[3] -- value is a negative normal value.\nS1.u[4] -- value is a negative denormal value.\nS1.u[5] -- value is negative zero.\nS1.u[6] -- value is positive zero.\nS1.u[7] -- value is a positive denormal value.\nS1.u[8] -- value is a positive normal value.\nS1.u[9] -- value is positive infinity.\n16.12. VOP3 & VOP3SD Instructions 495 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "declare result : 1'U;\nif isSignalNAN(64'F(S0.f16)) then\nresult = S1.u[0]\nelsif isQuietNAN(64'F(S0.f16)) then\nresult = S1.u[1]\nelsif exponent(S0.f16) == 31 then\n// +-INF\nresult = S1.u[sign(S0.f16) ? 2 : 9]\nelsif exponent(S0.f16) > 0 then\n// +-normal value\nresult = S1.u[sign(S0.f16) ? 3 : 8]\nelsif 64'F(abs(S0.f16)) > 0.0 then\n// +-denormal value\nresult = S1.u[sign(S0.f16) ? 4 : 7]\nelse\n// +-0.0\nresult = S1.u[sign(S0.f16) ? 5 : 6]\nendif;\nEXEC.u64[laneId] = result", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set."}, "v_cmpx_class_f32": {"desc": "IEEE numeric class function specified in S1.u, performed on S0.f.\nThe function reports true if the floating point value is any of the numeric types selected in S1.u according to the\nfollowing list:\nS1.u[0] -- value is a signaling NAN.\nS1.u[1] -- value is a quiet NAN.\nS1.u[2] -- value is negative infinity.\nS1.u[3] -- value is a negative normal value.\nS1.u[4] -- value is a negative denormal value.\nS1.u[5] -- value is negative zero.\nS1.u[6] -- value is positive zero.\nS1.u[7] -- value is a positive denormal value.\nS1.u[8] -- value is a positive normal value.\nS1.u[9] -- value is positive infinity.\n\"RDNA3\" Instruction Set Architecture", "code": "declare result : 1'U;\nif isSignalNAN(64'F(S0.f)) then\nresult = S1.u[0]\nelsif isQuietNAN(64'F(S0.f)) then\nresult = S1.u[1]\nelsif exponent(S0.f) == 255 then\n// +-INF\nresult = S1.u[sign(S0.f) ? 2 : 9]\nelsif exponent(S0.f) > 0 then\n// +-normal value\nresult = S1.u[sign(S0.f) ? 3 : 8]\nelsif 64'F(abs(S0.f)) > 0.0 then\n// +-denormal value\nresult = S1.u[sign(S0.f) ? 4 : 7]\nelse\n// +-0.0\nresult = S1.u[sign(S0.f) ? 5 : 6]\nendif;\nEXEC.u64[laneId] = result", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.\n16.12. VOP3 & VOP3SD Instructions 496 of 600"}, "v_cmpx_class_f64": {"desc": "IEEE numeric class function specified in S1.u, performed on S0.f64.\nThe function reports true if the floating point value is any of the numeric types selected in S1.u according to the\nfollowing list:\nS1.u[0] -- value is a signaling NAN.\nS1.u[1] -- value is a quiet NAN.\nS1.u[2] -- value is negative infinity.\nS1.u[3] -- value is a negative normal value.\nS1.u[4] -- value is a negative denormal value.\nS1.u[5] -- value is negative zero.\nS1.u[6] -- value is positive zero.\nS1.u[7] -- value is a positive denormal value.\nS1.u[8] -- value is a positive normal value.\nS1.u[9] -- value is positive infinity.\n\"RDNA3\" Instruction Set Architecture", "code": "declare result : 1'U;\nif isSignalNAN(S0.f64) then\nresult = S1.u[0]\nelsif isQuietNAN(S0.f64) then\nresult = S1.u[1]\nelsif exponent(S0.f64) == 1023 then\n// +-INF\nresult = S1.u[sign(S0.f64) ? 2 : 9]\nelsif exponent(S0.f64) > 0 then\n// +-normal value\nresult = S1.u[sign(S0.f64) ? 3 : 8]\nelsif abs(S0.f64) > 0.0 then\n// +-denormal value\nresult = S1.u[sign(S0.f64) ? 4 : 7]\nelse\n// +-0.0\nresult = S1.u[sign(S0.f64) ? 5 : 6]\nendif;\nEXEC.u64[laneId] = result", "notes": "Write only EXEC. SDST must be set to EXEC_LO. Signal 'invalid' on sNAN's, and also on qNAN's if clamp is set.\n16.12. VOP3 & VOP3SD Instructions 497 of 600\nParameter interpolation VALU instructions."}, "v_pk_mad_i16": {"desc": "Packed multiply-add on signed shorts.", "code": "D0[31 : 16].i16 = S0[31 : 16].i16 * S1[31 : 16].i16 + S2[31 : 16].i16;\nD0[15 : 0].i16 = S0[15 : 0].i16 * S1[15 : 0].i16 + S2[15 : 0].i16", "notes": ""}, "v_pk_mul_lo_u16": {"desc": "Packed multiply on unsigned shorts.", "code": "D0[31 : 16].u16 = S0[31 : 16].u16 * S1[31 : 16].u16;\nD0[15 : 0].u16 = S0[15 : 0].u16 * S1[15 : 0].u16", "notes": ""}, "v_pk_add_i16": {"desc": "Packed addition on signed shorts.", "code": "D0[31 : 16].i16 = S0[31 : 16].i16 + S1[31 : 16].i16;\nD0[15 : 0].i16 = S0[15 : 0].i16 + S1[15 : 0].i16", "notes": ""}, "v_pk_sub_i16": {"desc": "Packed subtraction on signed shorts. The second operand is subtracted from the first.", "code": "D0[31 : 16].i16 = S0[31 : 16].i16 - S1[31 : 16].i16;\nD0[15 : 0].i16 = S0[15 : 0].i16 - S1[15 : 0].i16", "notes": ""}, "v_pk_lshlrev_b16": {"desc": "Packed logical shift left. The shift count is in the first operand.\n16.10. VOP3P Instructions 351 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0[31 : 16].u16 = (S1[31 : 16].u16 << S0.u[19 : 16].u);\nD0[15 : 0].u16 = (S1[15 : 0].u16 << S0.u[3 : 0].u)", "notes": ""}, "v_pk_lshrrev_b16": {"desc": "Packed logical shift right. The shift count is in the first operand.", "code": "D0[31 : 16].u16 = (S1[31 : 16].u16 >> S0.u[19 : 16].u);\nD0[15 : 0].u16 = (S1[15 : 0].u16 >> S0.u[3 : 0].u)", "notes": ""}, "v_pk_ashrrev_i16": {"desc": "Packed arithmetic shift right (preserve sign bit). The shift count is in the first operand.", "code": "D0[31 : 16].i16 = (S1[31 : 16].i16 >> S0.u[19 : 16].u);\nD0[15 : 0].i16 = (S1[15 : 0].i16 >> S0.u[3 : 0].u)", "notes": ""}, "v_pk_max_i16": {"desc": "Packed maximum of signed shorts.", "code": "D0[31 : 16].i16 = S0[31 : 16].i16 >= S1[31 : 16].i16 ? S0[31 : 16].i16 : S1[31 : 16].i16;\nD0[15 : 0].i16 = S0[15 : 0].i16 >= S1[15 : 0].i16 ? S0[15 : 0].i16 : S1[15 : 0].i16", "notes": ""}, "v_pk_min_i16": {"desc": "Packed minimum of signed shorts.", "code": "D0[31 : 16].i16 = S0[31 : 16].i16 < S1[31 : 16].i16 ? S0[31 : 16].i16 : S1[31 : 16].i16;\nD0[15 : 0].i16 = S0[15 : 0].i16 < S1[15 : 0].i16 ? S0[15 : 0].i16 : S1[15 : 0].i16", "notes": ""}, "v_pk_mad_u16": {"desc": "Packed multiply-add on unsigned shorts.\n16.10. VOP3P Instructions 352 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0[31 : 16].u16 = S0[31 : 16].u16 * S1[31 : 16].u16 + S2[31 : 16].u16;\nD0[15 : 0].u16 = S0[15 : 0].u16 * S1[15 : 0].u16 + S2[15 : 0].u16", "notes": ""}, "v_pk_add_u16": {"desc": "Packed addition on unsigned shorts.", "code": "D0[31 : 16].u16 = S0[31 : 16].u16 + S1[31 : 16].u16;\nD0[15 : 0].u16 = S0[15 : 0].u16 + S1[15 : 0].u16", "notes": ""}, "v_pk_sub_u16": {"desc": "Packed subtraction on unsigned shorts. The second operand is subtracted from the first.", "code": "D0[31 : 16].u16 = S0[31 : 16].u16 - S1[31 : 16].u16;\nD0[15 : 0].u16 = S0[15 : 0].u16 - S1[15 : 0].u16", "notes": ""}, "v_pk_max_u16": {"desc": "Packed maximum of unsigned shorts.", "code": "D0[31 : 16].u16 = S0[31 : 16].u16 >= S1[31 : 16].u16 ? S0[31 : 16].u16 : S1[31 : 16].u16;\nD0[15 : 0].u16 = S0[15 : 0].u16 >= S1[15 : 0].u16 ? S0[15 : 0].u16 : S1[15 : 0].u16", "notes": ""}, "v_pk_min_u16": {"desc": "Packed minimum of unsigned shorts.", "code": "D0[31 : 16].u16 = S0[31 : 16].u16 < S1[31 : 16].u16 ? S0[31 : 16].u16 : S1[31 : 16].u16;\nD0[15 : 0].u16 = S0[15 : 0].u16 < S1[15 : 0].u16 ? S0[15 : 0].u16 : S1[15 : 0].u16", "notes": ""}, "v_pk_fma_f16": {"desc": "Packed fused-multiply-add of FP16 values.\n16.10. VOP3P Instructions 353 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0[31 : 16].f16 = fma(S0[31 : 16].f16, S1[31 : 16].f16, S2[31 : 16].f16);\nD0[15 : 0].f16 = fma(S0[15 : 0].f16, S1[15 : 0].f16, S2[15 : 0].f16)", "notes": ""}, "v_pk_add_f16": {"desc": "Packed addition of FP16 values.", "code": "D0[31 : 16].f16 = S0[31 : 16].f16 + S1[31 : 16].f16;\nD0[15 : 0].f16 = S0[15 : 0].f16 + S1[15 : 0].f16", "notes": ""}, "v_pk_mul_f16": {"desc": "Packed multiply of FP16 values.", "code": "D0[31 : 16].f16 = S0[31 : 16].f16 * S1[31 : 16].f16;\nD0[15 : 0].f16 = S0[15 : 0].f16 * S1[15 : 0].f16", "notes": ""}, "v_pk_min_f16": {"desc": "Packed minimum of FP16 values.", "code": "D0[31 : 16].f16 = v_min_f16(S0[31 : 16].f16, S1[31 : 16].f16);\nD0[15 : 0].f16 = v_min_f16(S0[15 : 0].f16, S1[15 : 0].f16)", "notes": ""}, "v_pk_max_f16": {"desc": "Packed maximum of FP16 values.", "code": "D0[31 : 16].f16 = v_max_f16(S0[31 : 16].f16, S1[31 : 16].f16);\nD0[15 : 0].f16 = v_max_f16(S0[15 : 0].f16, S1[15 : 0].f16)", "notes": ""}, "v_dot2_f32_f16": {"desc": "Dot product of packed FP16 values.\n16.10. VOP3P Instructions 354 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = 32'F(S0[15 : 0].f16) * 32'F(S1[15 : 0].f16);\ntmp += 32'F(S0[31 : 16].f16) * 32'F(S1[31 : 16].f16);\ntmp += S2.f;\nD0.f = tmp", "notes": ""}, "v_dot4_i32_iu8": {"desc": "Dot product of signed or unsigned bytes.", "code": "declare A : 32'I[4];\ndeclare B : 32'I[4];\n// Figure out whether inputs are signed/unsigned.\nfor i in 0 : 3 do\nA8 = S0[i * 8 + 7 : i * 8];\nB8 = S1[i * 8 + 7 : i * 8];\nA[i] = NEG[0].u1 ? 32'I(signext(A8.i8)) : 32'I(32'U(A8.u8));\nB[i] = NEG[1].u1 ? 32'I(signext(B8.i8)) : 32'I(32'U(B8.u8))\nendfor;\nC = S2.i;\n// Signed multiplier/adder. Extend unsigned inputs with leading 0.\nD0.i = A[0] * B[0];\nD0.i += A[1] * B[1];\nD0.i += A[2] * B[2];\nD0.i += A[3] * B[3];\nD0.i += C", "notes": "This opcode does not depend on the inference or deep learning features being enabled."}, "v_dot4_u32_u8": {"desc": "Dot product of unsigned bytes.\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = 32'U(S0[7 : 0].u8) * 32'U(S1[7 : 0].u8);\ntmp += 32'U(S0[15 : 8].u8) * 32'U(S1[15 : 8].u8);\ntmp += 32'U(S0[23 : 16].u8) * 32'U(S1[23 : 16].u8);\ntmp += 32'U(S0[31 : 24].u8) * 32'U(S1[31 : 24].u8);\ntmp += S2.u;\nD0.u = tmp", "notes": "This opcode does not depend on the inference or deep learning features being enabled.\n16.10. VOP3P Instructions 355 of 600"}, "v_dot8_i32_iu4": {"desc": "Dot product of signed or unsigned nibbles.", "code": "declare A : 32'I[8];\ndeclare B : 32'I[8];\n// Figure out whether inputs are signed/unsigned.\nfor i in 0 : 7 do\nA4 = S0[i * 4 + 3 : i * 4];\nB4 = S1[i * 4 + 3 : i * 4];\nA[i] = NEG[0].u1 ? 32'I(signext(A4.i4)) : 32'I(32'U(A4.u4));\nB[i] = NEG[1].u1 ? 32'I(signext(B4.i4)) : 32'I(32'U(B4.u4))\nendfor;\nC = S2.i;\n// Signed multiplier/adder. Extend unsigned inputs with leading 0.\nD0.i = A[0] * B[0];\nD0.i += A[1] * B[1];\nD0.i += A[2] * B[2];\nD0.i += A[3] * B[3];\nD0.i += A[4] * B[4];\nD0.i += A[5] * B[5];\nD0.i += A[6] * B[6];\nD0.i += A[7] * B[7];\nD0.i += C", "notes": ""}, "v_dot8_u32_u4": {"desc": "Dot product of unsigned nibbles.", "code": "tmp = 32'U(S0[3 : 0].u4) * 32'U(S1[3 : 0].u4);\ntmp += 32'U(S0[7 : 4].u4) * 32'U(S1[7 : 4].u4);\ntmp += 32'U(S0[11 : 8].u4) * 32'U(S1[11 : 8].u4);\ntmp += 32'U(S0[15 : 12].u4) * 32'U(S1[15 : 12].u4);\ntmp += 32'U(S0[19 : 16].u4) * 32'U(S1[19 : 16].u4);\ntmp += 32'U(S0[23 : 20].u4) * 32'U(S1[23 : 20].u4);\ntmp += 32'U(S0[27 : 24].u4) * 32'U(S1[27 : 24].u4);\ntmp += 32'U(S0[31 : 28].u4) * 32'U(S1[31 : 28].u4);\ntmp += S2.u;\nD0.u = tmp", "notes": ""}, "v_dot2_f32_bf16": {"desc": "Dot product of packed brain-float values.\n16.10. VOP3P Instructions 356 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = 32'F(S0[15 : 0].bf16) * 32'F(S1[15 : 0].bf16);\ntmp += 32'F(S0[31 : 16].bf16) * 32'F(S1[31 : 16].bf16);\ntmp += S2.f;\nD0.f = tmp", "notes": ""}, "v_fma_mix_f32": {"desc": "Fused-multiply-add of single-precision values with MIX encoding.\nSize and location of S0, S1 and S2 controlled by OPSEL: 0=src[31:0], 1=src[31:0], 2=src[15:0], 3=src[31:16]. Also,\nfor FMA_MIX, the NEG_HI field acts instead as an absolute-value modifier.", "code": "declare in : 32'F[3];\ndeclare S : 32'B[3];\nfor i in 0 : 2 do\nif !OPSEL_HI.u3[i] then\nin[i] = S[i].f\nelsif OPSEL.u3[i] then\nin[i] = f16_to_f32(S[i][31 : 16].f16)\nelse\nin[i] = f16_to_f32(S[i][15 : 0].f16)\nendif\nendfor;\nD0[31 : 0].f = fma(in[0], in[1], in[2])", "notes": ""}, "v_fma_mixlo_f16": {"desc": "Fused-multiply-add of FP16 values with MIX encoding, result stored in low 16 bits of destination.\nSize and location of S0, S1 and S2 controlled by OPSEL: 0=src[31:0], 1=src[31:0], 2=src[15:0], 3=src[31:16]. Also,\nfor FMA_MIX, the NEG_HI field acts instead as an absolute-value modifier.", "code": "declare in : 32'F[3];\ndeclare S : 32'B[3];\nfor i in 0 : 2 do\nif !OPSEL_HI.u3[i] then\nin[i] = S[i].f\nelsif OPSEL.u3[i] then\nin[i] = f16_to_f32(S[i][31 : 16].f16)\nelse\nin[i] = f16_to_f32(S[i][15 : 0].f16)\nendif\nendfor;\nD0[15 : 0].f16 = f32_to_f16(fma(in[0], in[1], in[2]))", "notes": ""}, "v_fma_mixhi_f16": {"desc": "Fused-multiply-add of FP16 values with MIX encoding, result stored in HIGH 16 bits of destination.\n16.10. VOP3P Instructions 357 of 600\n\"RDNA3\" Instruction Set Architecture\nSize and location of S0, S1 and S2 controlled by OPSEL: 0=src[31:0], 1=src[31:0], 2=src[15:0], 3=src[31:16]. Also,\nfor FMA_MIX, the NEG_HI field acts instead as an absolute-value modifier.", "code": "declare in : 32'F[3];\ndeclare S : 32'B[3];\nfor i in 0 : 2 do\nif !OPSEL_HI.u3[i] then\nin[i] = S[i].f\nelsif OPSEL.u3[i] then\nin[i] = f16_to_f32(S[i][31 : 16].f16)\nelse\nin[i] = f16_to_f32(S[i][15 : 0].f16)\nendif\nendfor;\nD0[31 : 16].f16 = f32_to_f16(fma(in[0], in[1], in[2]))", "notes": ""}, "v_wmma_f32_16x16x16_f16": {"desc": "WMMA matrix multiplication with F16 multiplicands and single precision result.", "code": "saved_exec = EXEC;\nEXEC = 64'B(-1);\neval \"D0.f32(16x16) = S0.f16(16x16) * S1.f16(16x16) + S2.f32(16x16)\";\nEXEC = saved_exec", "notes": ""}, "v_wmma_f32_16x16x16_bf16": {"desc": "WMMA matrix multiplication with brain float multiplicands and single precision result.", "code": "saved_exec = EXEC;\nEXEC = 64'B(-1);\neval \"D0.f32(16x16) = S0.bf16(16x16) * S1.bf16(16x16) + S2.f32(16x16)\";\nEXEC = saved_exec", "notes": ""}, "v_wmma_f16_16x16x16_f16": {"desc": "WMMA matrix multiplication with F16 multiplicands and F16 result.\n16.10. VOP3P Instructions 358 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "saved_exec = EXEC;\nEXEC = 64'B(-1);\neval \"D0.f16(16x16) = S0.f16(16x16) * S1.f16(16x16) + S2.f16(16x16)\";\nEXEC = saved_exec", "notes": ""}, "v_wmma_bf16_16x16x16_bf16": {"desc": "WMMA matrix multiplication with brain float multiplicands and brain float result.", "code": "saved_exec = EXEC;\nEXEC = 64'B(-1);\neval \"D0.bf16(16x16) = S0.bf16(16x16) * S1.bf16(16x16) + S2.bf16(16x16)\";\nEXEC = saved_exec", "notes": ""}, "v_wmma_i32_16x16x16_iu8": {"desc": "WMMA matrix multiplication with 8-bit integer multiplicands and signed 32-bit integer result.", "code": "saved_exec = EXEC;\nEXEC = 64'B(-1);\neval \"D0.i32(16x16) = S0.iu8(16x16) * S1.iu8(16x16) + S2.i32(16x16)\";\nEXEC = saved_exec", "notes": ""}, "v_wmma_i32_16x16x16_iu4": {"desc": "WMMA matrix multiplication with 4-bit integer multiplicands and signed 32-bit integer result.\n16.10. VOP3P Instructions 359 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "saved_exec = EXEC;\nEXEC = 64'B(-1);\neval \"D0.i32(16x16) = S0.iu4(16x16) * S1.iu4(16x16) + S2.i32(16x16)\";\nEXEC = saved_exec", "notes": "The VOPD encoded describes two VALU opcodes that are executed in parallel.\nFor instruction definitions, refer to the VOP1, VOP2 and VOP3 sections.\n16.11.1. VOPD X-Instructions"}, "v_dual_fmac_f32": {"desc": "Multiply two floating point inputs and accumulate the result into the destination register using fused multiply-\nadd.", "code": "", "notes": ""}, "v_dual_fmaak_f32": {"desc": "Multiply two single-precision floats and add a literal constant using fused multiply-add.", "code": "", "notes": ""}, "v_dual_fmamk_f32": {"desc": "Multiply a single-precision float with a literal constant and add a second single-precision float using fused\nmultiply-add.", "code": "", "notes": ""}, "v_dual_mul_f32": {"desc": "Multiply two floating point inputs and store the result into a vector register.", "code": "", "notes": ""}, "v_dual_add_f32": {"desc": "Add two floating point inputs and store the result into a vector register.", "code": "", "notes": ""}, "v_dual_sub_f32": {"desc": "Subtract the second floating point input from the first input and store the result into a vector register.", "code": "", "notes": ""}, "v_dual_subrev_f32": {"desc": "Subtract the first floating point input from the second input and store the result into a vector register.", "code": "", "notes": ""}, "v_dual_mul_dx9_zero_f32": {"desc": "Multiply two floating point inputs and store the result in a vector register. Follows DX9 rules where 0.0 times\nanything produces 0.0 (this differs from other APIs when the other input is infinity or NaN).\n16.11. VOPD Instructions 362 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "", "notes": ""}, "v_dual_mov_b32": {"desc": "Move data from a vector input into a vector register.", "code": "", "notes": ""}, "v_dual_cndmask_b32": {"desc": "Copy data from one of two inputs based on the vector condition code and store the result into a vector register.", "code": "", "notes": ""}, "v_dual_max_f32": {"desc": "Select the maximum of two floating point inputs and store the result into a vector register.", "code": "", "notes": ""}, "v_dual_min_f32": {"desc": "Select the minimum of two floating point inputs and store the result into a vector register.", "code": "", "notes": ""}, "v_dual_dot2acc_f32_f16": {"desc": "Dot product of packed FP16 values, accumulate with destination. The initial value in D is used as S2.", "code": "", "notes": ""}, "v_dual_dot2acc_f32_bf16": {"desc": "Dot product of packed brain-float values, accumulate with destination. The initial value in D is used as S2.", "code": "", "notes": ""}, "v_dual_add_nc_u32": {"desc": "Add two unsigned inputs and store the result into a vector register. No carry-in or carry-out support.", "code": "", "notes": ""}, "v_dual_lshlrev_b32": {"desc": "Given a shift count in the first vector input, calculate the logical shift left of the second vector input and store the\nresult into a vector register.", "code": "", "notes": ""}, "v_dual_and_b32": {"desc": "Calculate bitwise AND on two vector inputs and store the result into a vector register.\n16.11. VOPD Instructions 363 of 600\n\"RDNA3\" Instruction Set Architecture\n16.11. VOPD Instructions 364 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "", "notes": "VOP3 instructions use one of two encodings:\nVOP3SD this encoding allows specifying a unique scalar destination, and is used only for:\nV_ADD_CO_U32\nV_SUB_CO_U32\nV_SUBREV_CO_U32\nV_ADDC_CO_U32\nV_SUBB_CO_U32\nV_SUBBREV_CO_U32\nV_DIV_SCALE_F32\nV_DIV_SCALE_F64\nV_MAD_U64_U32\nV_MAD_I64_I32\nVOP3 all other VALU instructions use this encoding"}, "v_fma_dx9_zero_f32": {"desc": "Multiply and add single-precision values. Follows DX9 rules where 0.0 times anything produces 0.0 (this is not\nIEEE compliant).", "code": "if ((64'F(S0.f) == 0.0) || (64'F(S1.f) == 0.0)) then\n// DX9 rules, 0.0 * x = 0.0\nD0.f = S2.f\nelse\nD0.f = fma(S0.f, S1.f, S2.f)\nendif", "notes": ""}, "v_mad_i32_i24": {"desc": "Multiply two signed 24-bit integers, add a signed 32-bit integer and store the result as a signed 32-bit integer.\n\"RDNA3\" Instruction Set Architecture\nThis opcode is expected to be as efficient as basic single-precision opcodes since it utilizes the single-precision\nfloating point multiplier.", "code": "D0.i = 32'I(S0.i24) * 32'I(S1.i24) + S2.i", "notes": "16.12. VOP3 & VOP3SD Instructions 405 of 600"}, "v_mad_u32_u24": {"desc": "Multiply two unsigned 24-bit integers, add an unsigned 32-bit integer and store the result as an unsigned 32-bit\ninteger.", "code": "D0.u = 32'U(S0.u24) * 32'U(S1.u24) + S2.u", "notes": "This opcode is expected to be as efficient as basic single-precision opcodes since it utilizes the single-precision\nfloating point multiplier."}, "v_cubeid_f32": {"desc": "Cubemap Face ID determination. Result is a floating point face ID.", "code": "// Set D0.f = cubemap face ID ({0.0, 1.0, ..., 5.0}).\n// XYZ coordinate is given in (S0.f, S1.f, S2.f).\n// S0.f = x\n// S1.f = y\n// S2.f = z\nif ((abs(S2.f) >= abs(S0.f)) && (abs(S2.f) >= abs(S1.f))) then\nif S2.f < 0.0F then\nD0.f = 5.0F\nelse\nD0.f = 4.0F\nendif\nelsif abs(S1.f) >= abs(S0.f) then\nif S1.f < 0.0F then\nD0.f = 3.0F\nelse\nD0.f = 2.0F\nendif\nelse\nif S0.f < 0.0F then\nD0.f = 1.0F\nelse\nD0.f = 0.0F\nendif\nendif", "notes": ""}, "v_cubesc_f32": {"desc": "16.12. VOP3 & VOP3SD Instructions 406 of 600\n\"RDNA3\" Instruction Set Architecture\nCubemap S coordinate.", "code": "// D0.f = cubemap S coordinate.\n// XYZ coordinate is given in (S0.f, S1.f, S2.f).\n// S0.f = x\n// S1.f = y\n// S2.f = z\nif ((abs(S2.f) >= abs(S0.f)) && (abs(S2.f) >= abs(S1.f))) then\nif S2.f < 0.0F then\nD0.f = -S0.f\nelse\nD0.f = S0.f\nendif\nelsif abs(S1.f) >= abs(S0.f) then\nD0.f = S0.f\nelse\nif S0.f < 0.0F then\nD0.f = S2.f\nelse\nD0.f = -S2.f\nendif\nendif", "notes": ""}, "v_cubetc_f32": {"desc": "Cubemap T coordinate.", "code": "// D0.f = cubemap T coordinate.\n// XYZ coordinate is given in (S0.f, S1.f, S2.f).\n// S0.f = x\n// S1.f = y\n// S2.f = z\nif ((abs(S2.f) >= abs(S0.f)) && (abs(S2.f) >= abs(S1.f))) then\nD0.f = -S1.f\nelsif abs(S1.f) >= abs(S0.f) then\nif S1.f < 0.0F then\nD0.f = -S2.f\nelse\nD0.f = S2.f\nendif\nelse\nD0.f = -S1.f\nendif", "notes": ""}, "v_cubema_f32": {"desc": "Determine cubemap major axis.\n16.12. VOP3 & VOP3SD Instructions 407 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "// D0.f = 2.0 * cubemap major axis.\n// XYZ coordinate is given in (S0.f, S1.f, S2.f).\n// S0.f = x\n// S1.f = y\n// S2.f = z\nif ((abs(S2.f) >= abs(S0.f)) && (abs(S2.f) >= abs(S1.f))) then\nD0.f = S2.f * 2.0F\nelsif abs(S1.f) >= abs(S0.f) then\nD0.f = S1.f * 2.0F\nelse\nD0.f = S0.f * 2.0F\nendif", "notes": ""}, "v_bfe_u32": {"desc": "Bitfield extract. Extract unsigned bitfield from first operand using field offset in second operand and field size\nin third operand.", "code": "D0.u = ((S0.u >> S1.u[4 : 0].u) & 32'U((1 << S2.u[4 : 0].u) - 1))", "notes": ""}, "v_bfe_i32": {"desc": "Bitfield extract. Extract signed bitfield from first operand using field offset in second operand and field size in\nthird operand.", "code": "tmp = ((S0.i >> S1.u[4 : 0].u) & ((1 << S2.u[4 : 0].u) - 1));\nD0.i = 32'I(signextFromBit(tmp.i, S2.i[4 : 0].i))", "notes": ""}, "v_bfi_b32": {"desc": "Bitfield insert. Using a bitmask from the first operand, merge bitfield in second operand with packed value in\nthird operand.", "code": "D0.u = ((S0.u & S1.u) | (~S0.u & S2.u))", "notes": ""}, "v_fma_f32": {"desc": "Fused single precision multiply add.\n16.12. VOP3 & VOP3SD Instructions 408 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.f = fma(S0.f, S1.f, S2.f)", "notes": "0.5ULP accuracy, denormals are supported."}, "v_fma_f64": {"desc": "Fused double precision multiply add.", "code": "D0.f64 = fma(S0.f64, S1.f64, S2.f64)", "notes": "0.5ULP precision, denormals are supported."}, "v_lerp_u8": {"desc": "Unsigned 8-bit pixel average on packed unsigned bytes (linear interpolation).\nEach byte in S2 acts as a round mode; if the LSB is set then 0.5 rounds up, otherwise 0.5 truncates.", "code": "D0.u = 32'U((S0.u[31 : 24] + S1.u[31 : 24] + S2.u[24].u8) >> 1U << 24U);\nD0.u += 32'U((S0.u[23 : 16] + S1.u[23 : 16] + S2.u[16].u8) >> 1U << 16U);\nD0.u += 32'U((S0.u[15 : 8] + S1.u[15 : 8] + S2.u[8].u8) >> 1U << 8U);\nD0.u += 32'U((S0.u[7 : 0] + S1.u[7 : 0] + S2.u[0].u8) >> 1U)", "notes": ""}, "v_alignbit_b32": {"desc": "Align a value to the specified bit position.", "code": "D0.u = 32'U(({ S0.u, S1.u } >> S2.u[4 : 0].u) & 0xffffffffLL)", "notes": "\uf12a\nS0 carries the MSBs and S1 carries the LSBs of the value being aligned."}, "v_alignbyte_b32": {"desc": "16.12. VOP3 & VOP3SD Instructions 409 of 600\n\"RDNA3\" Instruction Set Architecture\nAlign a value to the specified byte position.", "code": "D0.u = 32'U(({ S0.u, S1.u } >> (S2.u[1 : 0].u * 8U)) & 0xffffffffLL)", "notes": "\uf12a\nS0 carries the MSBs and S1 carries the LSBs of the value being aligned."}, "v_mullit_f32": {"desc": "Multiply for lighting. Specific rules apply: 0.0 * x = 0.0; specific INF, NAN, overflow rules.", "code": "if ((S1.f == -MAX_FLOAT_F32) || (64'F(S1.f) == -INF) || isNAN(64'F(S1.f)) || (S2.f <= 0.0F) ||\nisNAN(64'F(S2.f))) then\nD0.f = -MAX_FLOAT_F32\nelse\nD0.f = S0.f * S1.f\nendif", "notes": ""}, "v_min3_f32": {"desc": "Return minimum single-precision value of three inputs.", "code": "D0.f = v_min_f32(v_min_f32(S0.f, S1.f), S2.f)", "notes": ""}, "v_min3_i32": {"desc": "Return minimum signed integer value of three inputs.", "code": "D0.i = v_min_i32(v_min_i32(S0.i, S1.i), S2.i)", "notes": ""}, "v_min3_u32": {"desc": "Return minimum unsigned integer value of three inputs.\n16.12. VOP3 & VOP3SD Instructions 410 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u = v_min_u32(v_min_u32(S0.u, S1.u), S2.u)", "notes": ""}, "v_max3_f32": {"desc": "Return maximum single precision value of three inputs.", "code": "D0.f = v_max_f32(v_max_f32(S0.f, S1.f), S2.f)", "notes": ""}, "v_max3_i32": {"desc": "Return maximum signed integer value of three inputs.", "code": "D0.i = v_max_i32(v_max_i32(S0.i, S1.i), S2.i)", "notes": ""}, "v_max3_u32": {"desc": "Return maximum unsigned integer value of three inputs.", "code": "D0.u = v_max_u32(v_max_u32(S0.u, S1.u), S2.u)", "notes": ""}, "v_med3_f32": {"desc": "Return median single precision value of three inputs.", "code": "if (isNAN(64'F(S0.f)) || isNAN(64'F(S1.f)) || isNAN(64'F(S2.f))) then\nD0.f = v_min3_f32(S0.f, S1.f, S2.f)\nelsif v_max3_f32(S0.f, S1.f, S2.f) == S0.f then\nD0.f = v_max_f32(S1.f, S2.f)\nelsif v_max3_f32(S0.f, S1.f, S2.f) == S1.f then\nD0.f = v_max_f32(S0.f, S2.f)\nelse\nD0.f = v_max_f32(S0.f, S1.f)\nendif", "notes": ""}, "v_med3_i32": {"desc": "16.12. VOP3 & VOP3SD Instructions 411 of 600\n\"RDNA3\" Instruction Set Architecture\nReturn median signed integer value of three inputs.", "code": "if v_max3_i32(S0.i, S1.i, S2.i) == S0.i then\nD0.i = v_max_i32(S1.i, S2.i)\nelsif v_max3_i32(S0.i, S1.i, S2.i) == S1.i then\nD0.i = v_max_i32(S0.i, S2.i)\nelse\nD0.i = v_max_i32(S0.i, S1.i)\nendif", "notes": ""}, "v_med3_u32": {"desc": "Return median unsigned integer value of three inputs.", "code": "if v_max3_u32(S0.u, S1.u, S2.u) == S0.u then\nD0.u = v_max_u32(S1.u, S2.u)\nelsif v_max3_u32(S0.u, S1.u, S2.u) == S1.u then\nD0.u = v_max_u32(S0.u, S2.u)\nelse\nD0.u = v_max_u32(S0.u, S1.u)\nendif", "notes": ""}, "v_sad_u8": {"desc": "Sum of absolute differences with accumulation, overflow into upper bits is allowed.", "code": "ABSDIFF = lambda(x, y) (\nx > y ? x - y : y - x);\n// UNSIGNED comparison\nD0.u = S2.u;\nD0.u += 32'U(ABSDIFF(S0.u[31 : 24], S1.u[31 : 24]));\nD0.u += 32'U(ABSDIFF(S0.u[23 : 16], S1.u[23 : 16]));\nD0.u += 32'U(ABSDIFF(S0.u[15 : 8], S1.u[15 : 8]));\nD0.u += 32'U(ABSDIFF(S0.u[7 : 0], S1.u[7 : 0]))", "notes": ""}, "v_sad_hi_u8": {"desc": "Sum of absolute differences with accumulation, accumulate from the higher-order bits of the third source\noperand.\n16.12. VOP3 & VOP3SD Instructions 412 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u = (32'U(v_sad_u8(S0, S1, 0U)) << 16U) + S2.u", "notes": ""}, "v_sad_u16": {"desc": "Short SAD with accumulation.", "code": "ABSDIFF = lambda(x, y) (\nx > y ? x - y : y - x);\n// UNSIGNED comparison\nD0.u = S2.u;\nD0.u += ABSDIFF(S0[31 : 16].u16, S1[31 : 16].u16);\nD0.u += ABSDIFF(S0[15 : 0].u16, S1[15 : 0].u16)", "notes": ""}, "v_sad_u32": {"desc": "Dword SAD with accumulation.", "code": "ABSDIFF = lambda(x, y) (\nx > y ? x - y : y - x);\n// UNSIGNED comparison\nD0.u = ABSDIFF(S0.u, S1.u) + S2.u", "notes": ""}, "v_cvt_pk_u8_f32": {"desc": "Packed float to byte conversion.\nConvert floating point value S0 to 8-bit unsigned integer and pack the result into byte S1 of dword S2.", "code": "D0.u = (S2.u & 32'U(~(0xff << (S1.u[1 : 0].u * 8U))));\nD0.u = (D0.u | ((32'U(f32_to_u8(S0.f)) & 255U) << (S1.u[1 : 0].u * 8U)))", "notes": ""}, "v_div_fixup_f32": {"desc": "Single precision division fixup.\nS0 = Quotient, S1 = Denominator, S2 = Numerator.\nGiven a numerator, denominator, and quotient from a divide, this opcode detects and applies specific case\nnumerics, touching up the quotient if necessary. This opcode also generates invalid, denorm and divide by\nzero exceptions caused by the division.\n16.12. VOP3 & VOP3SD Instructions 413 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "sign_out = (sign(S1.f) ^ sign(S2.f));\nif isNAN(64'F(S2.f)) then\nD0.f = 32'F(cvtToQuietNAN(64'F(S2.f)))\nelsif isNAN(64'F(S1.f)) then\nD0.f = 32'F(cvtToQuietNAN(64'F(S1.f)))\nelsif ((64'F(S1.f) == 0.0) && (64'F(S2.f) == 0.0)) then\n// 0/0\nD0.f = 32'F(0xffc00000)\nelsif ((64'F(abs(S1.f)) == +INF) && (64'F(abs(S2.f)) == +INF)) then\n// inf/inf\nD0.f = 32'F(0xffc00000)\nelsif ((64'F(S1.f) == 0.0) || (64'F(abs(S2.f)) == +INF)) then\n// x/0, or inf/y\nD0.f = sign_out ? -INF.f : +INF.f\nelsif ((64'F(abs(S1.f)) == +INF) || (64'F(S2.f) == 0.0)) then\n// x/inf, 0/y\nD0.f = sign_out ? -0.0F : 0.0F\nelsif exponent(S2.f) - exponent(S1.f) < -150 then\nD0.f = sign_out ? -UNDERFLOW_F32 : UNDERFLOW_F32\nelsif exponent(S1.f) == 255 then\nD0.f = sign_out ? -OVERFLOW_F32 : OVERFLOW_F32\nelse\nD0.f = sign_out ? -abs(S0.f) : abs(S0.f)\nendif", "notes": ""}, "v_div_fixup_f64": {"desc": "Double precision division fixup.\nS0 = Quotient, S1 = Denominator, S2 = Numerator.\nGiven a numerator, denominator, and quotient from a divide, this opcode detects and applies specific case\nnumerics, touching up the quotient if necessary. This opcode also generates invalid, denorm and divide by\nzero exceptions caused by the division.\n16.12. VOP3 & VOP3SD Instructions 414 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "sign_out = (sign(S1.f64) ^ sign(S2.f64));\nif isNAN(S2.f64) then\nD0.f64 = cvtToQuietNAN(S2.f64)\nelsif isNAN(S1.f64) then\nD0.f64 = cvtToQuietNAN(S1.f64)\nelsif ((S1.f64 == 0.0) && (S2.f64 == 0.0)) then\n// 0/0\nD0.f64 = 64'F(0xfff8000000000000LL)\nelsif ((abs(S1.f64) == +INF) && (abs(S2.f64) == +INF)) then\n// inf/inf\nD0.f64 = 64'F(0xfff8000000000000LL)\nelsif ((S1.f64 == 0.0) || (abs(S2.f64) == +INF)) then\n// x/0, or inf/y\nD0.f64 = sign_out ? -INF : +INF\nelsif ((abs(S1.f64) == +INF) || (S2.f64 == 0.0)) then\n// x/inf, 0/y\nD0.f64 = sign_out ? -0.0 : 0.0\nelsif exponent(S2.f64) - exponent(S1.f64) < -1075 then\nD0.f64 = sign_out ? -UNDERFLOW_F64 : UNDERFLOW_F64\nelsif exponent(S1.f64) == 2047 then\nD0.f64 = sign_out ? -OVERFLOW_F64 : OVERFLOW_F64\nelse\nD0.f64 = sign_out ? -abs(S0.f64) : abs(S0.f64)\nendif", "notes": ""}, "v_div_fmas_f32": {"desc": "Single precision FMA with fused scale.\nThis opcode performs a standard Fused Multiply-Add operation and conditionally scales the resulting exponent\nif VCC is set.", "code": "if VCC.u64[laneId] then\nD0.f = 2.0F ** 32 * fma(S0.f, S1.f, S2.f)\nelse\nD0.f = fma(S0.f, S1.f, S2.f)\nendif", "notes": "Input denormals are not flushed, but output flushing is allowed."}, "v_div_fmas_f64": {"desc": "Double precision FMA with fused scale.\nThis opcode performs a standard Fused Multiply-Add operation and conditionally scales the resulting exponent\nif VCC is set.", "code": "if VCC.u64[laneId] then\nD0.f64 = 2.0 ** 64 * fma(S0.f64, S1.f64, S2.f64)\nelse\nD0.f64 = fma(S0.f64, S1.f64, S2.f64)\nendif", "notes": "Input denormals are not flushed, but output flushing is allowed."}, "v_msad_u8": {"desc": "Masked sum of absolute differences with accumulation, overflow into upper bits is allowed.\nComponents where the reference value in S1 is zero are not included in the sum.\n16.12. VOP3 & VOP3SD Instructions 415 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "ABSDIFF = lambda(x, y) (\nx > y ? x - y : y - x);\n// UNSIGNED comparison\nD0.u = S2.u;\nD0.u += S1.u[31 : 24] == 8'0U ? 0U : 32'U(ABSDIFF(S0.u[31 : 24], S1.u[31 : 24]));\nD0.u += S1.u[23 : 16] == 8'0U ? 0U : 32'U(ABSDIFF(S0.u[23 : 16], S1.u[23 : 16]));\nD0.u += S1.u[15 : 8] == 8'0U ? 0U : 32'U(ABSDIFF(S0.u[15 : 8], S1.u[15 : 8]));\nD0.u += S1.u[7 : 0] == 8'0U ? 0U : 32'U(ABSDIFF(S0.u[7 : 0], S1.u[7 : 0]))", "notes": ""}, "v_qsad_pk_u16_u8": {"desc": "Quad-byte SAD with 16-bit packed accumulation.", "code": "D0[63 : 48] = 16'B(v_sad_u8(S0[55 : 24], S1[31 : 0], S2[63 : 48].u));\nD0[47 : 32] = 16'B(v_sad_u8(S0[47 : 16], S1[31 : 0], S2[47 : 32].u));\nD0[31 : 16] = 16'B(v_sad_u8(S0[39 : 8], S1[31 : 0], S2[31 : 16].u));\nD0[15 : 0] = 16'B(v_sad_u8(S0[31 : 0], S1[31 : 0], S2[15 : 0].u))", "notes": ""}, "v_mqsad_pk_u16_u8": {"desc": "Quad-byte masked SAD with 16-bit packed accumulation.", "code": "D0[63 : 48] = 16'B(v_msad_u8(S0[55 : 24], S1[31 : 0], S2[63 : 48].u));\nD0[47 : 32] = 16'B(v_msad_u8(S0[47 : 16], S1[31 : 0], S2[47 : 32].u));\nD0[31 : 16] = 16'B(v_msad_u8(S0[39 : 8], S1[31 : 0], S2[31 : 16].u));\nD0[15 : 0] = 16'B(v_msad_u8(S0[31 : 0], S1[31 : 0], S2[15 : 0].u))", "notes": ""}, "v_mqsad_u32_u8": {"desc": "Quad-byte masked SAD with 32-bit packed accumulation.", "code": "D0[127 : 96] = 32'B(v_msad_u8(S0[55 : 24], S1[31 : 0], S2[127 : 96].u));\nD0[95 : 64] = 32'B(v_msad_u8(S0[47 : 16], S1[31 : 0], S2[95 : 64].u));\nD0[63 : 32] = 32'B(v_msad_u8(S0[39 : 8], S1[31 : 0], S2[63 : 32].u));\nD0[31 : 0] = 32'B(v_msad_u8(S0[31 : 0], S1[31 : 0], S2[31 : 0].u))", "notes": ""}, "v_xor3_b32": {"desc": "Calculate the bitwise XOR of three vector inputs and store the result into a vector register.\n16.12. VOP3 & VOP3SD Instructions 416 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u = (S0.u ^ S1.u ^ S2.u)", "notes": "Input and output modifiers not supported."}, "v_mad_u16": {"desc": "Multiply and add three unsigned short values.", "code": "D0.u16 = S0.u16 * S1.u16 + S2.u16", "notes": "Supports saturation (unsigned 16-bit integer domain)."}, "v_perm_b32": {"desc": "Permute a 64-bit value constructed from two vector inputs using a per-lane selector and store the result into a\nvector register.\n\"RDNA3\" Instruction Set Architecture\nNote the MSBs of the 64-bit value being selected are stored in S0. This is counterintuitive for a little-endian\narchitecture.", "code": "BYTE_PERMUTE = lambda(data, sel) (\ndeclare in : 8'B[8];\nfor i in 0 : 7 do\nin[i] = data[i * 8 + 7 : i * 8].b8\nendfor;\nif sel.u >= 13U then\nreturn 8'0xff\nelsif sel.u == 12U then\nreturn 8'0x0\nelsif sel.u == 11U then\nreturn in[7][7].b8 * 8'0xff\nelsif sel.u == 10U then\nreturn in[5][7].b8 * 8'0xff\nelsif sel.u == 9U then\nreturn in[3][7].b8 * 8'0xff\nelsif sel.u == 8U then\nreturn in[1][7].b8 * 8'0xff\nelse\nreturn in[sel]\nendif);\nD0[31 : 24] = BYTE_PERMUTE({ S0.u, S1.u }, S2.u[31 : 24]);\nD0[23 : 16] = BYTE_PERMUTE({ S0.u, S1.u }, S2.u[23 : 16]);\nD0[15 : 8] = BYTE_PERMUTE({ S0.u, S1.u }, S2.u[15 : 8]);\nD0[7 : 0] = BYTE_PERMUTE({ S0.u, S1.u }, S2.u[7 : 0])", "notes": "Selects 8 through 11 are useful in modeling sign extension of a smaller-precision signed integer to a larger-\nprecision result.\n16.12. VOP3 & VOP3SD Instructions 417 of 600"}, "v_xad_u32": {"desc": "Calculate bitwise XOR of the first two vector inputs, then add the third vector input to the intermediate result,\nthen store the result into a vector register.", "code": "D0.u = (S0.u ^ S1.u) + S2.u", "notes": "No carryin/carryout and no saturation. This opcode is designed to help accelerate the SHA256 hash algorithm."}, "v_lshl_add_u32": {"desc": "Given a shift count in the second input, calculate the logical shift left of the first input, then add the third input\nto the intermediate result, then store the final result into a vector register.", "code": "D0.u = (S0.u << S1.u[4 : 0].u) + S2.u", "notes": ""}, "v_add_lshl_u32": {"desc": "Add the first two integer inputs, then given a shift count in the third input, calculate the logical shift left of the\nintermediate result, then store the final result into a vector register.", "code": "D0.u = ((S0.u + S1.u) << S2.u[4 : 0].u)", "notes": ""}, "v_fma_f16": {"desc": "Fused half precision multiply add.\n\"RDNA3\" Instruction Set Architecture", "code": "D0.f16 = fma(S0.f16, S1.f16, S2.f16)", "notes": "0.5ULP accuracy, denormals are supported.\n16.12. VOP3 & VOP3SD Instructions 418 of 600"}, "v_min3_f16": {"desc": "Return minimum FP16 value of three inputs.", "code": "D0.f16 = v_min_f16(v_min_f16(S0.f16, S1.f16), S2.f16)", "notes": ""}, "v_min3_i16": {"desc": "Return minimum signed short value of three inputs.", "code": "D0.i16 = v_min_i16(v_min_i16(S0.i16, S1.i16), S2.i16)", "notes": ""}, "v_min3_u16": {"desc": "Return minimum unsigned short value of three inputs.", "code": "D0.u16 = v_min_u16(v_min_u16(S0.u16, S1.u16), S2.u16)", "notes": ""}, "v_max3_f16": {"desc": "Return maximum FP16 value of three inputs.", "code": "D0.f16 = v_max_f16(v_max_f16(S0.f16, S1.f16), S2.f16)", "notes": ""}, "v_max3_i16": {"desc": "Return maximum signed short value of three inputs.", "code": "D0.i16 = v_max_i16(v_max_i16(S0.i16, S1.i16), S2.i16)", "notes": ""}, "v_max3_u16": {"desc": "Return maximum unsigned short value of three inputs.\n16.12. VOP3 & VOP3SD Instructions 419 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u16 = v_max_u16(v_max_u16(S0.u16, S1.u16), S2.u16)", "notes": ""}, "v_med3_f16": {"desc": "Return median FP16 value of three inputs.", "code": "if (isNAN(64'F(S0.f16)) || isNAN(64'F(S1.f16)) || isNAN(64'F(S2.f16))) then\nD0.f16 = v_min3_f16(S0.f16, S1.f16, S2.f16)\nelsif v_max3_f16(S0.f16, S1.f16, S2.f16) == S0.f16 then\nD0.f16 = v_max_f16(S1.f16, S2.f16)\nelsif v_max3_f16(S0.f16, S1.f16, S2.f16) == S1.f16 then\nD0.f16 = v_max_f16(S0.f16, S2.f16)\nelse\nD0.f16 = v_max_f16(S0.f16, S1.f16)\nendif", "notes": ""}, "v_med3_i16": {"desc": "Return median signed short value of three inputs.", "code": "if v_max3_i16(S0.i16, S1.i16, S2.i16) == S0.i16 then\nD0.i16 = v_max_i16(S1.i16, S2.i16)\nelsif v_max3_i16(S0.i16, S1.i16, S2.i16) == S1.i16 then\nD0.i16 = v_max_i16(S0.i16, S2.i16)\nelse\nD0.i16 = v_max_i16(S0.i16, S1.i16)\nendif", "notes": ""}, "v_med3_u16": {"desc": "Return median unsigned short value of three inputs.", "code": "if v_max3_u16(S0.u16, S1.u16, S2.u16) == S0.u16 then\nD0.u16 = v_max_u16(S1.u16, S2.u16)\nelsif v_max3_u16(S0.u16, S1.u16, S2.u16) == S1.u16 then\nD0.u16 = v_max_u16(S0.u16, S2.u16)\nelse\nD0.u16 = v_max_u16(S0.u16, S1.u16)\nendif", "notes": ""}, "v_mad_i16": {"desc": "16.12. VOP3 & VOP3SD Instructions 420 of 600\n\"RDNA3\" Instruction Set Architecture\nMultiply and add three signed short values.", "code": "D0.i16 = S0.i16 * S1.i16 + S2.i16", "notes": "Supports saturation (signed 16-bit integer domain)."}, "v_div_fixup_f16": {"desc": "Half precision division fixup.\nS0 = Quotient, S1 = Denominator, S2 = Numerator.\nGiven a numerator, denominator, and quotient from a divide, this opcode detects and applies specific case\nnumerics, touching up the quotient if necessary. This opcode also generates invalid, denorm and divide by\nzero exceptions caused by the division.", "code": "sign_out = (sign(S1.f16) ^ sign(S2.f16));\nif isNAN(64'F(S2.f16)) then\nD0.f16 = 16'F(cvtToQuietNAN(64'F(S2.f16)))\nelsif isNAN(64'F(S1.f16)) then\nD0.f16 = 16'F(cvtToQuietNAN(64'F(S1.f16)))\nelsif ((64'F(S1.f16) == 0.0) && (64'F(S2.f16) == 0.0)) then\n// 0/0\nD0.f16 = 16'F(0xfe00)\nelsif ((64'F(abs(S1.f16)) == +INF) && (64'F(abs(S2.f16)) == +INF)) then\n// inf/inf\nD0.f16 = 16'F(0xfe00)\nelsif ((64'F(S1.f16) == 0.0) || (64'F(abs(S2.f16)) == +INF)) then\n// x/0, or inf/y\nD0.f16 = sign_out ? -INF.f16 : +INF.f16\nelsif ((64'F(abs(S1.f16)) == +INF) || (64'F(S2.f16) == 0.0)) then\n// x/inf, 0/y\nD0.f16 = sign_out ? -16'0.0 : 16'0.0\nelse\nD0.f16 = sign_out ? -abs(S0.f16) : abs(S0.f16)\nendif", "notes": ""}, "v_add3_u32": {"desc": "Add three unsigned integers.\n16.12. VOP3 & VOP3SD Instructions 421 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u = S0.u + S1.u + S2.u", "notes": ""}, "v_lshl_or_b32": {"desc": "Given a shift count in the second input, calculate the logical shift left of the first input, then calculate the\nbitwise OR of the intermediate result and the third input, then store the final result into a vector register.", "code": "D0.u = ((S0.u << S1.u[4 : 0].u) | S2.u)", "notes": ""}, "v_and_or_b32": {"desc": "Calculate bitwise AND on the first two vector inputs, then compute the bitwise OR of the intermediate result\nand the third vector input, then store the result into a vector register.", "code": "D0.u = ((S0.u & S1.u) | S2.u)", "notes": "Input and output modifiers not supported."}, "v_or3_b32": {"desc": "Calculate the bitwise OR of three vector inputs and store the result into a vector register.", "code": "D0.u = (S0.u | S1.u | S2.u)", "notes": "Input and output modifiers not supported."}, "v_mad_u32_u16": {"desc": "Multiply and add unsigned values.", "code": "D0.u = 32'U(S0.u16) * 32'U(S1.u16) + S2.u", "notes": ""}, "v_mad_i32_i16": {"desc": "Multiply and add signed values.\n16.12. VOP3 & VOP3SD Instructions 422 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.i = 32'I(S0.i16) * 32'I(S1.i16) + S2.i", "notes": ""}, "v_permlane16_b32": {"desc": "Perform arbitrary gather-style operation within a row (16 contiguous lanes).\nThe first source must be a VGPR and the second and third sources must be scalar values; the second and third\nsource are combined into a single 64-bit value representing lane selects used to swizzle within each row.\nOPSEL is not used in its typical manner for this instruction. For this instruction OPSEL[0] is overloaded to\nrepresent the DPP 'FI' (Fetch Inactive) bit and OPSEL[1] is overloaded to represent the DPP 'BOUND_CTRL' bit.\nThe remaining OPSEL bits are reserved for this instruction.\nCompare with V_PERMLANEX16_B32.\n\"RDNA3\" Instruction Set Architecture", "code": "declare tmp : 32'B[64];\nlanesel = { S2.u, S1.u };\n// Concatenate lane select bits\nfor i in 0 : WAVE32 ? 31 : 63 do\n// Copy original S0 in case D==S0\ntmp[i] = VGPR[i][SRC0.u]\nendfor;\nfor row in 0 : WAVE32 ? 1 : 3 do\n// Implement arbitrary swizzle within each row\nfor i in 0 : 15 do\nif EXEC[row * 16 + i].u1 then\nVGPR[row * 16 + i][VDST.u] = tmp[64'B(row * 16) + lanesel[i * 4 + 3 : i * 4]]\nendif\nendfor\nendfor\n// ...\n// v1.lane[30] <- v0.lane[31]\n// v1.lane[31] <- v0.lane[16]", "notes": "ABS, NEG and OMOD modifiers should all be zeroed for this instruction.\nExample implementing a rotation within each row:\nv_mov_b32 s0, 0x87654321;\nv_mov_b32 s1, 0x0fedcba9;\nv_permlane16_b32 v1, v0, s0, s1;\n// ROW 0:\n// v1.lane[0] <- v0.lane[1]\n// v1.lane[1] <- v0.lane[2]\n// ...\n// v1.lane[14] <- v0.lane[15]\n// v1.lane[15] <- v0.lane[0]\n//\n// ROW 1:\n// v1.lane[16] <- v0.lane[17]\n// v1.lane[17] <- v0.lane[18]\n16.12. VOP3 & VOP3SD Instructions 423 of 600"}, "v_permlanex16_b32": {"desc": "Perform arbitrary gather-style operation across two rows (each row is 16 contiguous lanes).\nThe first source must be a VGPR and the second and third sources must be scalar values; the second and third\nsource are combined into a single 64-bit value representing lane selects used to swizzle within each row.\nOPSEL is not used in its typical manner for this instruction. For this instruction OPSEL[0] is overloaded to\nrepresent the DPP 'FI' (Fetch Inactive) bit and OPSEL[1] is overloaded to represent the DPP 'BOUND_CTRL' bit.\nThe remaining OPSEL bits are reserved for this instruction.\nCompare with V_PERMLANE16_B32.\n\"RDNA3\" Instruction Set Architecture", "code": "declare tmp : 32'B[64];\nlanesel = { S2.u, S1.u };\n// Concatenate lane select bits\nfor i in 0 : WAVE32 ? 31 : 63 do\n// Copy original S0 in case D==S0\ntmp[i] = VGPR[i][SRC0.u]\nendfor;\nfor row in 0 : WAVE32 ? 1 : 3 do\n// Implement arbitrary swizzle across two rows\naltrow = { row[1], ~row[0] };\n// 1<->0, 3<->2\nfor i in 0 : 15 do\nif EXEC[row * 16 + i].u1 then\nVGPR[row * 16 + i][VDST.u] = tmp[64'B(altrow.i * 16) + lanesel[i * 4 + 3 : i * 4]]\nendif\nendfor\nendfor\n// v1.lane[0] <- v0.lane[1]\n// v1.lane[1] <- v0.lane[2]\n// ...\n// v1.lane[14] <- v0.lane[15] (needs FI to read)\n// v1.lane[15] unset\n//\n// ROW 1:\n// v1.lane[16] <- v0.lane[17]\n// v1.lane[17] <- v0.lane[18]\n// ...\n// v1.lane[30] <- v0.lane[31] (needs FI to read)\n// v1.lane[31] unset\n// Enable only the threads that get data from the other row.\nv_mov_b32 exec_lo, 0x80008000; // Lanes getting data from the other row\nv_permlanex16_b32 v1, v0, s0, s1 fi; // FI bit needed for lanes 15 and 31\n// v1.lane[15] <- v0.lane[16]\n// v1.lane[31] <- v0.lane[0]", "notes": "ABS, NEG and OMOD modifiers should all be zeroed for this instruction.\nExample implementing a rotation across an entire wave32 wavefront:\n// Note for this to work, source and destination VGPRs must be different.\n// For this rotation, lane 15 gets data from lane 16, lane 31 gets data from lane 0.\n// These are the only two lanes that need to use v_permlanex16_b32.\n// Enable only the threads that get data from their own row.\nv_mov_b32 exec_lo, 0x7fff7fff; // Lanes getting data from their own row\nv_mov_b32 s0, 0x87654321;\nv_mov_b32 s1, 0x0fedcba9;\nv_permlane16_b32 v1, v0, s0, s1 fi; // FI bit needed for lanes 14 and 30\n// ROW 0:\n16.12. VOP3 & VOP3SD Instructions 424 of 600"}, "v_cndmask_b16": {"desc": "Copy data from one of two inputs based on the vector condition code and store the result into a vector register.", "code": "D0.u16 = VCC.u64[laneId] ? S1.u16 : S0.u16", "notes": "In VOP3 the VCC source may be a scalar GPR specified in S2.\nFloating-point modifiers are valid for this instruction if S0 and S1 are 16-bit floating point values. This\ninstruction is suitable for negating or taking the absolute value of a floating-point value."}, "v_maxmin_f32": {"desc": "Compute maximum of first two operands, followed by minimum of that result and the third operand.\nThis instruction can emulate an API-level \"clamp\"; unlike MED3 this correctly handles the case where the\nclamp's maxBound < minBound.\n\"RDNA3\" Instruction Set Architecture", "code": "D0.f = v_min_f32(v_max_f32(S0.f, S1.f), S2.f)", "notes": "Support input denorm control, allow output denorm value. Exceptions are supported. Note: +0.0 > -0.0 is true.\n16.12. VOP3 & VOP3SD Instructions 425 of 600"}, "v_minmax_f32": {"desc": "Compute minimum of first two operands, followed by maximum of that result and the third operand.\nThis instruction can emulate an API-level \"clamp\"; unlike MED3 this correctly handles the case where the\nclamp's minBound > maxBound.", "code": "D0.f = v_max_f32(v_min_f32(S0.f, S1.f), S2.f)", "notes": "Support input denorm control, allow output denorm value. Exceptions are supported. Note: +0.0 > -0.0 is true."}, "v_maxmin_f16": {"desc": "Compute maximum of first two operands, followed by minimum of that result and the third operand.\nThis instruction can emulate an API-level \"clamp\"; unlike MED3 this correctly handles the case where the\nclamp's maxBound < minBound.", "code": "D0.f16 = v_min_f16(v_max_f16(S0.f16, S1.f16), S2.f16)", "notes": "Support input denorm control, allow output denorm value. Exceptions are supported. Note: +0.0 > -0.0 is true."}, "v_minmax_f16": {"desc": "Compute minimum of first two operands, followed by maximum of that result and the third operand.\nThis instruction can emulate an API-level \"clamp\"; unlike MED3 this correctly handles the case where the\nclamp's maxBound < minBound.", "code": "D0.f16 = v_max_f16(v_min_f16(S0.f16, S1.f16), S2.f16)", "notes": "Support input denorm control, allow output denorm value. Exceptions are supported. Note: +0.0 > -0.0 is true."}, "v_maxmin_u32": {"desc": "Compute maximum of first two operands, followed by minimum of that result and the third operand.\n16.12. VOP3 & VOP3SD Instructions 426 of 600\n\"RDNA3\" Instruction Set Architecture\nThis instruction can emulate an API-level \"clamp\"; unlike MED3 this correctly handles the case where the\nclamp's maxBound < minBound.", "code": "D0.i = 32'I(v_min_u32(v_max_u32(S0.u, S1.u), S2.u))", "notes": ""}, "v_minmax_u32": {"desc": "Compute minimum of first two operands, followed by maximum of that result and the third operand.\nThis instruction can emulate an API-level \"clamp\"; unlike MED3 this correctly handles the case where the\nclamp's maxBound < minBound.", "code": "D0.i = 32'I(v_max_u32(v_min_u32(S0.u, S1.u), S2.u))", "notes": ""}, "v_maxmin_i32": {"desc": "Compute maximum of first two operands, followed by minimum of that result and the third operand.\nThis instruction can emulate an API-level \"clamp\"; unlike MED3 this correctly handles the case where the\nclamp's maxBound < minBound.", "code": "D0.i = v_min_i32(v_max_i32(S0.i, S1.i), S2.i)", "notes": ""}, "v_minmax_i32": {"desc": "Compute minimum of first two operands, followed by maximum of that result and the third operand.\nThis instruction can emulate an API-level \"clamp\"; unlike MED3 this correctly handles the case where the\nclamp's maxBound < minBound.", "code": "D0.i = v_max_i32(v_min_i32(S0.i, S1.i), S2.i)", "notes": ""}, "v_dot2_f16_f16": {"desc": "Dot product of packed FP16 values.\n16.12. VOP3 & VOP3SD Instructions 427 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = S0[15 : 0].f16 * S1[15 : 0].f16;\ntmp += S0[31 : 16].f16 * S1[31 : 16].f16;\ntmp += S2.f16;\nD0.f16 = tmp", "notes": "OPSEL[2] controls which half of S2 is read and OPSEL[3] controls which half of D is written; OPSEL[1:0] are\nignored."}, "v_dot2_bf16_bf16": {"desc": "Dot product of packed brain-float values.", "code": "tmp = S0[15 : 0].bf16 * S1[15 : 0].bf16;\ntmp += S0[31 : 16].bf16 * S1[31 : 16].bf16;\ntmp += S2.bf16;\nD0.bf16 = tmp", "notes": "OPSEL[2] controls which half of S2 is read and OPSEL[3] controls which half of D is written; OPSEL[1:0] are\nignored."}, "v_div_scale_f32": {"desc": "Single precision division pre-scale.\nS0 = Input to scale (either denominator or numerator), S1 = Denominator, S2 = Numerator.\nGiven a numerator and denominator, this opcode appropriately scales inputs for division to avoid subnormal\nterms during Newton-Raphson correction method. S0 must be the same value as either S1 or S2.\nThis opcode produces a VCC flag for post-scaling of the quotient (using V_DIV_FMAS_F32).\n16.12. VOP3 & VOP3SD Instructions 428 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "VCC = 0x0LL;\nif ((64'F(S2.f) == 0.0) || (64'F(S1.f) == 0.0)) then\nD0.f = NAN.f\nelsif exponent(S2.f) - exponent(S1.f) >= 96 then\n// N/D near MAX_FLOAT_F32\nVCC = 0x1LL;\nif S0.f == S1.f then\n// Only scale the denominator\nD0.f = ldexp(S0.f, 64)\nendif\nelsif S1.f == DENORM.f then\nD0.f = ldexp(S0.f, 64)\nelsif ((1.0 / 64'F(S1.f) == DENORM.f64) && (S2.f / S1.f == DENORM.f)) then\nVCC = 0x1LL;\nif S0.f == S1.f then\n// Only scale the denominator\nD0.f = ldexp(S0.f, 64)\nendif\nelsif 1.0 / 64'F(S1.f) == DENORM.f64 then\nD0.f = ldexp(S0.f, -64)\nelsif S2.f / S1.f == DENORM.f then\nVCC = 0x1LL;\nif S0.f == S2.f then\n// Only scale the numerator\nD0.f = ldexp(S0.f, 64)\nendif\nelsif exponent(S2.f) <= 23 then\n// Numerator is tiny\nD0.f = ldexp(S0.f, 64)\nendif", "notes": ""}, "v_div_scale_f64": {"desc": "Double precision division pre-scale.\nS0 = Input to scale (either denominator or numerator), S1 = Denominator, S2 = Numerator.\nGiven a numerator and denominator, this opcode appropriately scales inputs for division to avoid subnormal\nterms during Newton-Raphson correction method. S0 must be the same value as either S1 or S2.\nThis opcode produces a VCC flag for post-scaling of the quotient (using V_DIV_FMAS_F64).\n16.12. VOP3 & VOP3SD Instructions 429 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "VCC = 0x0LL;\nif ((S2.f64 == 0.0) || (S1.f64 == 0.0)) then\nD0.f64 = NAN.f64\nelsif exponent(S2.f64) - exponent(S1.f64) >= 768 then\n// N/D near MAX_FLOAT_F64\nVCC = 0x1LL;\nif S0.f64 == S1.f64 then\n// Only scale the denominator\nD0.f64 = ldexp(S0.f64, 128)\nendif\nelsif S1.f64 == DENORM.f64 then\nD0.f64 = ldexp(S0.f64, 128)\nelsif ((1.0 / S1.f64 == DENORM.f64) && (S2.f64 / S1.f64 == DENORM.f64)) then\nVCC = 0x1LL;\nif S0.f64 == S1.f64 then\n// Only scale the denominator\nD0.f64 = ldexp(S0.f64, 128)\nendif\nelsif 1.0 / S1.f64 == DENORM.f64 then\nD0.f64 = ldexp(S0.f64, -128)\nelsif S2.f64 / S1.f64 == DENORM.f64 then\nVCC = 0x1LL;\nif S0.f64 == S2.f64 then\n// Only scale the numerator\nD0.f64 = ldexp(S0.f64, 128)\nendif\nelsif exponent(S2.f64) <= 53 then\n// Numerator is tiny\nD0.f64 = ldexp(S0.f64, 128)\nendif", "notes": ""}, "v_mad_u64_u32": {"desc": "Multiply two unsigned integer inputs, add a third unsigned integer input, store the result into a 64-bit vector\nregister and store the overflow/carryout into a scalar mask register.", "code": "{ D1.u1, D0.u64 } = 65'B(65'U(S0.u) * 65'U(S1.u) + 65'U(S2.u64))", "notes": "In VOP3 the VCC destination may be an arbitrary SGPR-pair."}, "v_mad_i64_i32": {"desc": "Multiply two signed integer inputs, add a third signed integer input, store the result into a 64-bit vector register\nand store the overflow/carryout into a scalar mask register.", "code": "{ D1.i1, D0.i64 } = 65'B(65'I(S0.i) * 65'I(S1.i) + 65'I(S2.i64))", "notes": "In VOP3 the VCC destination may be an arbitrary SGPR-pair."}, "v_add_co_u32": {"desc": "Add two unsigned inputs, store the result into a vector register and store the carry-out mask into a scalar\nregister.\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = 64'U(S0.u) + 64'U(S1.u);\nVCC.u64[laneId] = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// VCC is an UNSIGNED overflow/carry-out for V_ADD_CO_CI_U32.\nD0.u = tmp.u", "notes": "In VOP3 the VCC destination may be an arbitrary SGPR-pair.\nSupports saturation (unsigned 32-bit integer domain).\n16.12. VOP3 & VOP3SD Instructions 430 of 600"}, "v_sub_co_u32": {"desc": "Subtract the second unsigned input from the first input, store the result into a vector register and store the\ncarry-out mask into a scalar register.", "code": "tmp = S0.u - S1.u;\nVCC.u64[laneId] = S1.u > S0.u ? 1'1U : 1'0U;\n// VCC is an UNSIGNED overflow/carry-out for V_SUB_CO_CI_U32.\nD0.u = tmp.u", "notes": "In VOP3 the VCC destination may be an arbitrary SGPR-pair.\nSupports saturation (unsigned 32-bit integer domain)."}, "v_subrev_co_u32": {"desc": "Subtract the first unsigned input from the second input, store the result into a vector register and store the\ncarry-out mask into a scalar register.", "code": "tmp = S1.u - S0.u;\nVCC.u64[laneId] = S0.u > S1.u ? 1'1U : 1'0U;\n// VCC is an UNSIGNED overflow/carry-out for V_SUB_CO_CI_U32.\nD0.u = tmp.u", "notes": "In VOP3 the VCC destination may be an arbitrary SGPR-pair.\nSupports saturation (unsigned 32-bit integer domain)."}, "v_add_nc_u16": {"desc": "Add two unsigned inputs and store the result into a vector register. No carry-in or carry-out support.\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u16 = S0.u16 + S1.u16", "notes": "Supports saturation (unsigned 16-bit integer domain).\n16.12. VOP3 & VOP3SD Instructions 431 of 600"}, "v_sub_nc_u16": {"desc": "Subtract the second unsigned input from the first input and store the result into a vector register. No carry-in\nor carry-out support.", "code": "D0.u16 = S0.u16 - S1.u16", "notes": "Supports saturation (unsigned 16-bit integer domain)."}, "v_mul_lo_u16": {"desc": "Multiply two unsigned inputs and store the low bits of the result into a vector register.", "code": "D0.u16 = S0.u16 * S1.u16", "notes": "Supports saturation (unsigned 16-bit integer domain)."}, "v_cvt_pk_i16_f32": {"desc": "Convert two single-precision floats into a packed value of signed words.", "code": "D0[31 : 16] = 16'B(v_cvt_i16_f32(S1.f));\nD0[15 : 0] = 16'B(v_cvt_i16_f32(S0.f))", "notes": ""}, "v_cvt_pk_u16_f32": {"desc": "Convert two single-precision floats into a packed value of unsigned words.", "code": "D0[31 : 16] = 16'B(v_cvt_u16_f32(S1.f));\nD0[15 : 0] = 16'B(v_cvt_u16_f32(S0.f))", "notes": ""}, "v_max_u16": {"desc": "Select the maximum of two unsigned integers and store the selected value into a vector register.\n16.12. VOP3 & VOP3SD Instructions 432 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u16 = S0.u16 >= S1.u16 ? S0.u16 : S1.u16", "notes": ""}, "v_max_i16": {"desc": "Select the maximum of two signed integers and store the selected value into a vector register.", "code": "D0.i16 = S0.i16 >= S1.i16 ? S0.i16 : S1.i16", "notes": ""}, "v_min_u16": {"desc": "Select the minimum of two unsigned integers and store the selected value into a vector register.", "code": "D0.u16 = S0.u16 < S1.u16 ? S0.u16 : S1.u16", "notes": ""}, "v_min_i16": {"desc": "Select the minimum of two signed integers and store the selected value into a vector register.", "code": "D0.i16 = S0.i16 < S1.i16 ? S0.i16 : S1.i16", "notes": ""}, "v_add_nc_i16": {"desc": "Add two signed inputs and store the result into a vector register. No carry-in or carry-out support.", "code": "D0.i16 = S0.i16 + S1.i16", "notes": "Supports saturation (signed 16-bit integer domain)."}, "v_sub_nc_i16": {"desc": "Subtract the second signed input from the first input and store the result into a vector register. No carry-in or\ncarry-out support.\n16.12. VOP3 & VOP3SD Instructions 433 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.i16 = S0.i16 - S1.i16", "notes": "Supports saturation (signed 16-bit integer domain)."}, "v_pack_b32_f16": {"desc": "Pack two FP16 values together.", "code": "D0[31 : 16].f16 = S1.f16;\nD0[15 : 0].f16 = S0.f16", "notes": ""}, "v_cvt_pk_norm_i16_f16": {"desc": "Convert two FP16 values into packed signed normalized shorts.", "code": "D0[15 : 0].i16 = f16_to_snorm(S0[15 : 0].f16);\nD0[31 : 16].i16 = f16_to_snorm(S1[15 : 0].f16)", "notes": ""}, "v_cvt_pk_norm_u16_f16": {"desc": "Convert two FP16 values into packed unsigned normalized shorts.", "code": "D0[15 : 0].u16 = f16_to_unorm(S0[15 : 0].f16);\nD0[31 : 16].u16 = f16_to_unorm(S1[15 : 0].f16)", "notes": ""}, "v_ldexp_f32": {"desc": "Multiply the first input, a floating point value, by an integral power of 2 specified in the second input, a signed\ninteger value, and store the floating point result into a vector register. Compare with the ldexp() function in C.", "code": "D0.f = S0.f * 2.0F ** S1.i", "notes": ""}, "v_bfm_b32": {"desc": "16.12. VOP3 & VOP3SD Instructions 434 of 600\n\"RDNA3\" Instruction Set Architecture\nBitfield modify.\nS0 is the bitfield width and S1 is the bitfield offset.", "code": "D0.u = 32'U(((1 << S0[4 : 0].u) - 1) << S1[4 : 0].u)", "notes": ""}, "v_bcnt_u32_b32": {"desc": "Count the number of \"1\" bits in the vector input and store the result into a vector register.", "code": "D0.u = S1.u;\nfor i in 0 : 31 do\nD0.u += S0[i].u;\n// count i'th bit\nendfor", "notes": ""}, "v_mbcnt_lo_u32_b32": {"desc": "Masked bit count.\nlaneId is the position of this thread in the wavefront (in 0..63). See also V_MBCNT_HI_U32_B32.", "code": "ThreadMask = (1LL << laneId.u) - 1LL;\nMaskedValue = (S0.u & ThreadMask[31 : 0].u);\nD0.u = S1.u;\nfor i in 0 : 31 do\nD0.u += MaskedValue[i] == 1'1U ? 1U : 0U\nendfor", "notes": ""}, "v_mbcnt_hi_u32_b32": {"desc": "Masked bit count, high pass.\nlaneId is the position of this thread in the wavefront (in 0..63). See also V_MBCNT_LO_U32_B32.\n16.12. VOP3 & VOP3SD Instructions 435 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "ThreadMask = (1LL << laneId.u) - 1LL;\nMaskedValue = (S0.u & ThreadMask[63 : 32].u);\nD0.u = S1.u;\nfor i in 0 : 31 do\nD0.u += MaskedValue[i] == 1'1U ? 1U : 0U\nendfor", "notes": "Note that in Wave32 mode ThreadMask[63:32] == 0 and this instruction simply performs a move from S1 to D.\nExample to compute each thread's position in 0..63:\nv_mbcnt_lo_u32_b32 v0, -1, 0\nv_mbcnt_hi_u32_b32 v0, -1, v0\n// v0 now contains laneId"}, "v_cvt_pk_norm_i16_f32": {"desc": "Convert two single-precision floats into a packed signed normalized value.", "code": "D0[15 : 0].i16 = f32_to_snorm(S0.f);\nD0[31 : 16].i16 = f32_to_snorm(S1.f)", "notes": ""}, "v_cvt_pk_norm_u16_f32": {"desc": "Convert two single-precision floats into a packed unsigned normalized value.", "code": "D0[15 : 0].u16 = f32_to_unorm(S0.f);\nD0[31 : 16].u16 = f32_to_unorm(S1.f)", "notes": ""}, "v_cvt_pk_u16_u32": {"desc": "Convert two unsigned integers into a packed unsigned short.", "code": "D0[15 : 0].u16 = u32_to_u16(S0.u);\nD0[31 : 16].u16 = u32_to_u16(S1.u)", "notes": ""}, "v_cvt_pk_i16_i32": {"desc": "Convert two signed integers into a packed signed short.\n16.12. VOP3 & VOP3SD Instructions 436 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0[15 : 0].i16 = i32_to_i16(S0.i);\nD0[31 : 16].i16 = i32_to_i16(S1.i)", "notes": ""}, "v_sub_nc_i32": {"desc": "Subtract the second signed input from the first input and store the result into a vector register. No carry-in or\ncarry-out support.", "code": "D0.i = S0.i - S1.i", "notes": "Supports saturation (signed 32-bit integer domain)."}, "v_add_nc_i32": {"desc": "Add two signed inputs and store the result into a vector register. No carry-in or carry-out support.", "code": "D0.i = S0.i + S1.i", "notes": "Supports saturation (signed 32-bit integer domain)."}, "v_add_f64": {"desc": "Add two floating point inputs and store the result into a vector register.", "code": "D0.f64 = S0.f64 + S1.f64", "notes": "0.5ULP precision, denormals are supported."}, "v_mul_f64": {"desc": "Multiply two floating point inputs and store the result into a vector register.\n\"RDNA3\" Instruction Set Architecture", "code": "D0.f64 = S0.f64 * S1.f64", "notes": "0.5ULP precision, denormals are supported.\n16.12. VOP3 & VOP3SD Instructions 437 of 600"}, "v_min_f64": {"desc": "Select the minimum of two floating point inputs and store the result into a vector register.", "code": "LT_NEG_ZERO = lambda(a, b) (\n((a < b) || ((abs(a) == 0.0) && (abs(b) == 0.0) && sign(a) && !sign(b))));\n// Version of comparison where -0.0 < +0.0, differs from IEEE\nif WAVE_MODE.IEEE then\nif isSignalNAN(S0.f64) then\nD0.f64 = cvtToQuietNAN(S0.f64)\nelsif isSignalNAN(S1.f64) then\nD0.f64 = cvtToQuietNAN(S1.f64)\nelsif isQuietNAN(S1.f64) then\nD0.f64 = S0.f64\nelsif isQuietNAN(S0.f64) then\nD0.f64 = S1.f64\nelsif LT_NEG_ZERO(S0.f64, S1.f64) then\n// NOTE: -0<+0 is TRUE in this comparison\nD0.f64 = S0.f64\nelse\nD0.f64 = S1.f64\nendif\nelse\nif isNAN(S1.f64) then\nD0.f64 = S0.f64\nelsif isNAN(S0.f64) then\nD0.f64 = S1.f64\nelsif LT_NEG_ZERO(S0.f64, S1.f64) then\n// NOTE: -0<+0 is TRUE in this comparison\nD0.f64 = S0.f64\nelse\nD0.f64 = S1.f64\nendif\nendif;\n// Inequalities in the above pseudocode behave differently from IEEE\n// when both inputs are +-0.", "notes": "IEEE compliant. Supports denormals, round mode, exception flags, saturation.\nDenorm flushing for this operation is effectively controlled by the input denorm mode control: If input\ndenorm mode is disabling denorm, the internal result of a min/max operation cannot be a denorm value, so\noutput denorm mode is irrelevant. If input denorm mode is enabling denorm, the internal min/max result can\nbe a denorm and this operation outputs as a denorm regardless of output denorm mode."}, "v_max_f64": {"desc": "Select the maximum of two floating point inputs and store the result into a vector register.\n16.12. VOP3 & VOP3SD Instructions 438 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "GT_NEG_ZERO = lambda(a, b) (\n((a > b) || ((abs(a) == 0.0) && (abs(b) == 0.0) && !sign(a) && sign(b))));\n// Version of comparison where +0.0 > -0.0, differs from IEEE\nif WAVE_MODE.IEEE then\nif isSignalNAN(S0.f64) then\nD0.f64 = cvtToQuietNAN(S0.f64)\nelsif isSignalNAN(S1.f64) then\nD0.f64 = cvtToQuietNAN(S1.f64)\nelsif isQuietNAN(S1.f64) then\nD0.f64 = S0.f64\nelsif isQuietNAN(S0.f64) then\nD0.f64 = S1.f64\nelsif GT_NEG_ZERO(S0.f64, S1.f64) then\n// NOTE: +0>-0 is TRUE in this comparison\nD0.f64 = S0.f64\nelse\nD0.f64 = S1.f64\nendif\nelse\nif isNAN(S1.f64) then\nD0.f64 = S0.f64\nelsif isNAN(S0.f64) then\nD0.f64 = S1.f64\nelsif GT_NEG_ZERO(S0.f64, S1.f64) then\n// NOTE: +0>-0 is TRUE in this comparison\nD0.f64 = S0.f64\nelse\nD0.f64 = S1.f64\nendif\nendif;\n// Inequalities in the above pseudocode behave differently from IEEE\n// when both inputs are +-0.", "notes": "IEEE compliant. Supports denormals, round mode, exception flags, saturation.\nDenorm flushing for this operation is effectively controlled by the input denorm mode control: If input\ndenorm mode is disabling denorm, the internal result of a min/max operation cannot be a denorm value, so\noutput denorm mode is irrelevant. If input denorm mode is enabling denorm, the internal min/max result can\nbe a denorm and this operation outputs as a denorm regardless of output denorm mode."}, "v_ldexp_f64": {"desc": "Multiply the first input, a floating point value, by an integral power of 2 specified in the second input, a signed\ninteger value, and store the floating point result into a vector register. Compare with the ldexp() function in C.\n16.12. VOP3 & VOP3SD Instructions 439 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.f64 = S0.f64 * 2.0 ** S1.i", "notes": ""}, "v_mul_lo_u32": {"desc": "Multiply two unsigned integers.", "code": "D0.u = S0.u * S1.u", "notes": "To multiply integers with small magnitudes consider V_MUL_U32_U24, which is intended to be a more\nefficient implementation."}, "v_mul_hi_u32": {"desc": "Multiply two unsigned integers and store the high 32 bits of the result.", "code": "D0.u = 32'U((64'U(S0.u) * 64'U(S1.u)) >> 32U)", "notes": "To multiply integers with small magnitudes consider V_MUL_HI_U32_U24, which is intended to be a more\nefficient implementation."}, "v_mul_hi_i32": {"desc": "Multiply two signed integers and store the high 32 bits of the result.", "code": "D0.i = 32'I((64'I(S0.i) * 64'I(S1.i)) >> 32U)", "notes": "To multiply integers with small magnitudes consider V_MUL_HI_I32_I24, which is intended to be a more\nefficient implementation."}, "v_trig_preop_f64": {"desc": "Look Up 2/PI (S0.f64) with segment select S1.u[4:0].\nThis operation returns an aligned, double precision segment of 2/PI needed to do range reduction on S0.f64\n(double-precision value). Multiple segments can be specified through S1.u[4:0]. Rounding is round-to-zero.\nLarge inputs (exp > 1968) are scaled to avoid loss of precision through denormalization.\n16.12. VOP3 & VOP3SD Instructions 440 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "shift = 32'I(S1[4 : 0].u) * 53;\nif exponent(S0.f64) > 1077 then\nshift += exponent(S0.f64) - 1077\nendif;\n// (2.0/PI) == 0.{b_1200, b_1199, b_1198, ..., b_1, b_0}\n// b_1200 is the MSB of the fractional part of 2.0/PI\n// Left shift operation indicates which bits are brought\n// into the whole part of the number.\n// Only whole part of result is kept.\nresult = 64'F((1201'B(2.0 / PI)[1200 : 0] << shift.u) & 1201'0x1fffffffffffff);\nscale = -53 - shift;\nif exponent(S0.f64) >= 1968 then\nscale += 128\nendif;\nD0.f64 = ldexp(result, scale)", "notes": ""}, "v_lshlrev_b16": {"desc": "Given a shift count in the first vector input, calculate the logical shift left of the second vector input and store the\nresult into a vector register.", "code": "D0.u[15 : 0] = (S1.u[15 : 0] << S0[3 : 0].u)", "notes": ""}, "v_lshrrev_b16": {"desc": "Given a shift count in the first vector input, calculate the logical shift right of the second vector input and store\nthe result into a vector register.", "code": "D0.u[15 : 0] = (S1.u[15 : 0] >> S0[3 : 0].u)", "notes": ""}, "v_ashrrev_i16": {"desc": "Given a shift count in the first vector input, calculate the arithmetic shift right (preserving sign bit) of the second\nvector input and store the result into a vector register.", "code": "D0.i[15 : 0] = (S1.i[15 : 0] >> S0[3 : 0].u)", "notes": ""}, "v_lshlrev_b64": {"desc": "Given a shift count in the first vector input, calculate the logical shift left of the second vector input and store the\nresult into a vector register.\n16.12. VOP3 & VOP3SD Instructions 441 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u64 = (S1.u64 << S0[5 : 0].u)", "notes": "Only one scalar broadcast constant is allowed."}, "v_lshrrev_b64": {"desc": "Given a shift count in the first vector input, calculate the logical shift right of the second vector input and store\nthe result into a vector register.", "code": "D0.u64 = (S1.u64 >> S0[5 : 0].u)", "notes": "Only one scalar broadcast constant is allowed."}, "v_ashrrev_i64": {"desc": "Given a shift count in the first vector input, calculate the arithmetic shift right (preserving sign bit) of the second\nvector input and store the result into a vector register.", "code": "D0.i64 = (S1.i64 >> S0[5 : 0].u)", "notes": "Only one scalar broadcast constant is allowed."}, "v_readlane_b32": {"desc": "Copy one VGPR value from a single lane to one SGPR.\n16.12. VOP3 & VOP3SD Instructions 442 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "declare lane : 32'U;\nif WAVE32 then\nlane = S1.u[4 : 0].u;\n// Lane select for wave32\nelse\nlane = S1.u[5 : 0].u;\n// Lane select for wave64\nendif;\nD0.b = VGPR[lane][SRC0.u]", "notes": "Ignores EXEC mask for the VGPR read. Input and output modifiers not supported; this is an untyped operation."}, "v_writelane_b32": {"desc": "Write scalar value into one VGPR in one lane.", "code": "declare lane : 32'U;\nif WAVE32 then\nlane = S1.u[4 : 0].u;\n// Lane select for wave32\nelse\nlane = S1.u[5 : 0].u;\n// Lane select for wave64\nendif;\nVGPR[lane][VDST.u] = S0.b", "notes": "Ignores EXEC mask for the VGPR write. Input and output modifiers not supported; this is an untyped\noperation."}, "v_and_b16": {"desc": "Calculate bitwise AND on two vector inputs and store the result into a vector register.", "code": "D0.u16 = (S0.u16 & S1.u16)", "notes": "Input and output modifiers not supported."}, "v_or_b16": {"desc": "Calculate bitwise OR on two vector inputs and store the result into a vector register.\n\"RDNA3\" Instruction Set Architecture", "code": "D0.u16 = (S0.u16 | S1.u16)", "notes": "Input and output modifiers not supported.\n16.12. VOP3 & VOP3SD Instructions 443 of 600"}, "v_xor_b16": {"desc": "Calculate bitwise XOR on two vector inputs and store the result into a vector register.", "code": "D0.u16 = (S0.u16 ^ S1.u16)", "notes": "Input and output modifiers not supported."}, "v_interp_p10_f32": {"desc": "Parameter interpolation, first pass.", "code": "D0.f = S0[lane.i % 4 + 1].f * S1.f + S2[lane.i % 4].f", "notes": "Performs a V_FMA_F32 operation using fixed DPP8 settings. S0 and S2 refer to a VGPR previously loaded with\nLDS_PARAM_LOAD that contains packed interpolation data. S1 is the I/J coordinate.\nS0 uses a fixed DPP8 lane select of {1,1,1,1,5,5,5,5}.\nS2 uses a fixed DPP8 lane select of {0,0,0,0,4,4,4,4}.\nExample usage:\ns_mov_b32 m0, s0 // assume s0 contains newprim mask\nlds_param_load v0, attr0 // v0 is a temporary register\nv_interp_p10_f32 v3, v0, v1, v0 // v1 contains i coordinate\nv_interp_p2_f32 v3, v0, v2, v3 // v2 contains j coordinate"}, "v_interp_p2_f32": {"desc": "Parameter interpolation, second pass.\n\"RDNA3\" Instruction Set Architecture", "code": "D0.f = fma(S0[lane.i % 4 + 2].f, S1.f, S2.f)", "notes": "Performs a V_FMA_F32 operation using fixed DPP8 settings. S0 refers to a VGPR previously loaded with\nLDS_PARAM_LOAD that contains packed interpolation data. S1 is the I/J coordinate. S2 is the result of a\nprevious V_INTERP_P10_F32 instruction.\nS0 uses a fixed DPP8 lane select of {2,2,2,2,6,6,6,6}.\n16.13. VINTERP Instructions 498 of 600"}, "v_interp_p10_f16_f32": {"desc": "Parameter interpolation, first pass.", "code": "D0.f = 32'F(S0[lane.i % 4 + 1].f16) * S1.f + 32'F(S2[lane.i % 4].f16)", "notes": "Performs a hybrid 16/32-bit multiply-add operation using fixed DPP8 settings. S0 and S2 refer to a VGPR\npreviously loaded with LDS_PARAM_LOAD that contains packed interpolation data. S1 is the I/J coordinate.\nS0 uses a fixed DPP8 lane select of {1,1,1,1,5,5,5,5}.\nS2 uses a fixed DPP8 lane select of {0,0,0,0,4,4,4,4}.\nOPSEL is allowed for S0 and S2 to specify which half of the register to read from.\nNote that the I/J coordinate is 32-bit and the destination is also 32-bit."}, "v_interp_p2_f16_f32": {"desc": "Parameter interpolation, second pass.", "code": "D0.f16 = 16'F(32'F(S0[lane.i % 4 + 2].f16) * S1.f + S2.f)", "notes": "Performs a hybrid 16/32-bit multiply-add operation using fixed DPP8 settings. S0 refers to a VGPR previously\nloaded with LDS_PARAM_LOAD that contains packed interpolation data. S1 is the I/J coordinate. S2 is the\nresult of a previous V_INTERP_P10_F16_F32 instruction.\nS0 uses a fixed DPP8 lane select of {2,2,2,2,6,6,6,6}.\nOPSEL is allowed for D and S0 to specify which half of the register to write to/read from.\nNote that the I/J coordinate is 32-bit and the accumulator input is also 32-bit."}, "v_interp_p10_rtz_f16_f32": {"desc": "Same as V_INTERP_P10_F16_F32 except rounding mode is overridden to round toward zero.", "code": "", "notes": ""}, "v_interp_p2_rtz_f16_f32": {"desc": "Same as V_INTERP_P2_F16_F32 except rounding mode is overridden to round toward zero.\n16.13. VINTERP Instructions 499 of 600\n\"RDNA3\" Instruction Set Architecture\n16.13. VINTERP Instructions 500 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "", "notes": "These instructions load data from LDS into a VGPR where the LDS address is derived from wave state and the\nM0 register."}, "lds_param_load": {"desc": "Transfer parameter data from LDS to VGPRs and expand data in LDS using the NewPrimMask (provided in M0)\nto place per-quad data into lanes 0-3 of each quad as follows:\n{P0, P10, P20, 0.0}\nThis data may be extracted using DPP8 for interpolation operations. The V_INTERP_* instructions unpack data\nautomatically.\nWhen loading FP16 parameters, two attributes are loaded into a single VGPR: Attribute 2*ATTR is loaded into\nthe low 16 bits and attribute 2*ATTR+1 is loaded into the high 16 bits.\nThis instruction runs in whole quad mode: if any pixel of a quad is active then all 4 pixels of that quad are\nwritten. This is required for interpolation instructions to have all the parameter information available for the\nquad.", "code": "", "notes": ""}, "lds_direct_load": {"desc": "Read a single 32-bit value from LDS to all lanes. A single DWORD is read from LDS memory at ADDR[M0[15:0]],\nwhere M0[15:0] is a byte address and is dword-aligned. M0[18:16] specify the data type for the read and may be\n0=UBYTE, 1=USHORT, 2=DWORD, 4=SBYTE, 5=SSHORT.\nthat quad are written.\n16.14. Parameter and Direct Load from LDS Instructions 501 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "", "notes": "This suite of instructions operates on data stored within the data share memory. The instructions transfer data\nbetween VGPRs and data share memory.\nThe bitfield map for the LDS/GDS is:\nOFFSET0 = Unsigned byte offset added to the address from the ADDR VGPR.\nOFFSET1 = Unsigned byte offset added to the address from the ADDR VGPR.\nGDS = Set if GDS, cleared if LDS.\nOP = DS instruction opcode\nADDR = Source LDS address VGPR 0 - 255.\nDATA0 = Source data0 VGPR 0 - 255.\nDATA1 = Source data1 VGPR 0 - 255.\nVDST = Destination VGPR 0- 255.\n\uf05a All instructions with RTN in the name return the value that was in memory before the\noperation was performed."}, "ds_add_u32": {"desc": "Add data register to memory value.", "code": "tmp = MEM[ADDR].u;\nMEM[ADDR].u += DATA.u;\nRETURN_DATA.u = tmp", "notes": ""}, "ds_sub_u32": {"desc": "Subtract data register from memory value.", "code": "tmp = MEM[ADDR].u;\nMEM[ADDR].u -= DATA.u;\nRETURN_DATA.u = tmp", "notes": ""}, "ds_rsub_u32": {"desc": "Subtraction with reversed operands.\n16.15. LDS & GDS Instructions 502 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].b;\nMEM[ADDR] = DATA.b - MEM[ADDR].b;\nRETURN_DATA = tmp", "notes": ""}, "ds_inc_u32": {"desc": "Increment memory value with wraparound to zero when incremented to register value.", "code": "tmp = MEM[ADDR].u;\nsrc = DATA.u;\nMEM[ADDR].u = tmp >= src ? 0U : tmp + 1U;\nRETURN_DATA.u = tmp", "notes": ""}, "ds_dec_u32": {"desc": "Decrement memory value with wraparound to register value when decremented below zero.", "code": "tmp = MEM[ADDR].u;\nsrc = DATA.u;\nMEM[ADDR].u = ((tmp == 0U) || (tmp > src)) ? src : tmp - 1U;\nRETURN_DATA.u = tmp", "notes": ""}, "ds_min_i32": {"desc": "Minimum of two signed integer values.", "code": "tmp = MEM[ADDR].i;\nsrc = DATA.i;\nMEM[ADDR].i = src < tmp ? src : tmp;\nRETURN_DATA.i = tmp", "notes": ""}, "ds_max_i32": {"desc": "Maximum of two signed integer values.\n16.15. LDS & GDS Instructions 503 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].i;\nsrc = DATA.i;\nMEM[ADDR].i = src > tmp ? src : tmp;\nRETURN_DATA.i = tmp", "notes": ""}, "ds_min_u32": {"desc": "Minimum of two unsigned integer values.", "code": "tmp = MEM[ADDR].u;\nsrc = DATA.u;\nMEM[ADDR].u = src < tmp ? src : tmp;\nRETURN_DATA.u = tmp", "notes": ""}, "ds_max_u32": {"desc": "Maximum of two unsigned integer values.", "code": "tmp = MEM[ADDR].u;\nsrc = DATA.u;\nMEM[ADDR].u = src > tmp ? src : tmp;\nRETURN_DATA.u = tmp", "notes": ""}, "ds_and_b32": {"desc": "Bitwise AND of register value and memory value.", "code": "tmp = MEM[ADDR].b;\nMEM[ADDR].b = (tmp & DATA.b);\nRETURN_DATA.b = tmp", "notes": ""}, "ds_or_b32": {"desc": "Bitwise OR of register value and memory value.", "code": "tmp = MEM[ADDR].b;\nMEM[ADDR].b = (tmp | DATA.b);\nRETURN_DATA.b = tmp", "notes": ""}, "ds_xor_b32": {"desc": "Bitwise XOR of register value and memory value.\n16.15. LDS & GDS Instructions 504 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].b;\nMEM[ADDR].b = (tmp ^ DATA.b);\nRETURN_DATA.b = tmp", "notes": ""}, "ds_mskor_b32": {"desc": "Masked dword OR, D0 contains the mask and D1 contains the new value.", "code": "tmp = MEM[ADDR].b;\nMEM[ADDR].b = ((tmp & ~DATA.b) | DATA2.b);\nRETURN_DATA.b = tmp", "notes": ""}, "ds_store_b32": {"desc": "Store 32-bit data from a vector register into a given memory location.", "code": "MEM[ADDR] = DATA.b", "notes": ""}, "ds_store_2addr_b32": {"desc": "Write 2 dwords.", "code": "MEM[ADDR_BASE.u + OFFSET0.u * 4U] = DATA.b;\nMEM[ADDR_BASE.u + OFFSET1.u * 4U] = DATA2.b", "notes": ""}, "ds_store_2addr_stride64_b32": {"desc": "Write 2 dwords with larger stride.", "code": "MEM[ADDR_BASE.u + OFFSET0.u * 4U * 64U] = DATA.b;\nMEM[ADDR_BASE.u + OFFSET1.u * 4U * 64U] = DATA2.b", "notes": ""}, "ds_cmpstore_b32": {"desc": "Compare and store.\n16.15. LDS & GDS Instructions 505 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].b;\nsrc = DATA.b;\ncmp = DATA2.b;\nMEM[ADDR].b = tmp == cmp ? src : tmp;\nRETURN_DATA.b = tmp", "notes": "In this architecture the order of src and cmp agree with the BUFFER_ATOMIC_CMPSWAP opcode."}, "ds_cmpstore_f32": {"desc": "Floating point compare and store that handles NAN/INF/denormal values.", "code": "tmp = MEM[ADDR].f;\nsrc = DATA.f;\ncmp = DATA2.f;\nMEM[ADDR].f = tmp == cmp ? src : tmp;\nRETURN_DATA.f = tmp", "notes": "In this architecture the order of src and cmp agree with the BUFFER_ATOMIC_CMPSWAP opcode."}, "ds_min_f32": {"desc": "Minimum of two floating-point values.", "code": "tmp = MEM[ADDR].f;\nsrc = DATA.f;\nMEM[ADDR].f = src < tmp ? src : tmp;\nRETURN_DATA = tmp", "notes": "Floating-point compare handles NAN/INF/denorm."}, "ds_max_f32": {"desc": "Maximum of two floating-point values.\n16.15. LDS & GDS Instructions 506 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].f;\nsrc = DATA.f;\nMEM[ADDR].f = src > tmp ? src : tmp;\nRETURN_DATA = tmp", "notes": "Floating-point compare handles NAN/INF/denorm."}, "ds_nop": {"desc": "Do nothing.", "code": "", "notes": ""}, "ds_add_f32": {"desc": "Add data register to floating-point memory value.", "code": "tmp = MEM[ADDR].f;\nsrc = DATA.f;\nMEM[ADDR].f = src + tmp;\nRETURN_DATA.f = tmp", "notes": "Floating-point addition handles NAN/INF/denorm."}, "ds_store_b8": {"desc": "Byte write.", "code": "MEM[ADDR].b8 = DATA[7 : 0].b8", "notes": ""}, "ds_store_b16": {"desc": "Short write.", "code": "MEM[ADDR].b16 = DATA[15 : 0].b16", "notes": ""}, "ds_add_rtn_u32": {"desc": "16.15. LDS & GDS Instructions 507 of 600\n\"RDNA3\" Instruction Set Architecture\nAdd data register to memory value.", "code": "tmp = MEM[ADDR].u;\nMEM[ADDR].u += DATA.u;\nRETURN_DATA.u = tmp", "notes": ""}, "ds_sub_rtn_u32": {"desc": "Subtract data register from memory value.", "code": "tmp = MEM[ADDR].u;\nMEM[ADDR].u -= DATA.u;\nRETURN_DATA.u = tmp", "notes": ""}, "ds_rsub_rtn_u32": {"desc": "Subtraction with reversed operands.", "code": "tmp = MEM[ADDR].b;\nMEM[ADDR] = DATA.b - MEM[ADDR].b;\nRETURN_DATA = tmp", "notes": ""}, "ds_inc_rtn_u32": {"desc": "Increment memory value with wraparound to zero when incremented to register value.", "code": "tmp = MEM[ADDR].u;\nsrc = DATA.u;\nMEM[ADDR].u = tmp >= src ? 0U : tmp + 1U;\nRETURN_DATA.u = tmp", "notes": ""}, "ds_dec_rtn_u32": {"desc": "Decrement memory value with wraparound to register value when decremented below zero.\n16.15. LDS & GDS Instructions 508 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].u;\nsrc = DATA.u;\nMEM[ADDR].u = ((tmp == 0U) || (tmp > src)) ? src : tmp - 1U;\nRETURN_DATA.u = tmp", "notes": ""}, "ds_min_rtn_i32": {"desc": "Minimum of two signed integer values.", "code": "tmp = MEM[ADDR].i;\nsrc = DATA.i;\nMEM[ADDR].i = src < tmp ? src : tmp;\nRETURN_DATA.i = tmp", "notes": ""}, "ds_max_rtn_i32": {"desc": "Maximum of two signed integer values.", "code": "tmp = MEM[ADDR].i;\nsrc = DATA.i;\nMEM[ADDR].i = src > tmp ? src : tmp;\nRETURN_DATA.i = tmp", "notes": ""}, "ds_min_rtn_u32": {"desc": "Minimum of two unsigned integer values.", "code": "tmp = MEM[ADDR].u;\nsrc = DATA.u;\nMEM[ADDR].u = src < tmp ? src : tmp;\nRETURN_DATA.u = tmp", "notes": ""}, "ds_max_rtn_u32": {"desc": "Maximum of two unsigned integer values.", "code": "tmp = MEM[ADDR].u;\nsrc = DATA.u;\nMEM[ADDR].u = src > tmp ? src : tmp;\nRETURN_DATA.u = tmp", "notes": ""}, "ds_and_rtn_b32": {"desc": "16.15. LDS & GDS Instructions 509 of 600\n\"RDNA3\" Instruction Set Architecture\nBitwise AND of register value and memory value.", "code": "tmp = MEM[ADDR].b;\nMEM[ADDR].b = (tmp & DATA.b);\nRETURN_DATA.b = tmp", "notes": ""}, "ds_or_rtn_b32": {"desc": "Bitwise OR of register value and memory value.", "code": "tmp = MEM[ADDR].b;\nMEM[ADDR].b = (tmp | DATA.b);\nRETURN_DATA.b = tmp", "notes": ""}, "ds_xor_rtn_b32": {"desc": "Bitwise XOR of register value and memory value.", "code": "tmp = MEM[ADDR].b;\nMEM[ADDR].b = (tmp ^ DATA.b);\nRETURN_DATA.b = tmp", "notes": ""}, "ds_mskor_rtn_b32": {"desc": "Masked dword OR, D0 contains the mask and D1 contains the new value.", "code": "tmp = MEM[ADDR].b;\nMEM[ADDR].b = ((tmp & ~DATA.b) | DATA2.b);\nRETURN_DATA.b = tmp", "notes": ""}, "ds_storexchg_rtn_b32": {"desc": "Write-exchange operation.\n16.15. LDS & GDS Instructions 510 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].b;\nMEM[ADDR].b = DATA.b;\nRETURN_DATA.b = tmp", "notes": ""}, "ds_storexchg_2addr_rtn_b32": {"desc": "Write-exchange 2 separate dwords.", "code": "addr1 = ADDR_BASE.u + OFFSET0.u * 4U;\naddr2 = ADDR_BASE.u + OFFSET1.u * 4U;\ntmp1 = MEM[addr1].b;\ntmp2 = MEM[addr2].b;\nMEM[addr1].b = DATA.b;\nMEM[addr2].b = DATA2.b;\n// Note DATA2 can be any other register\nRETURN_DATA[31 : 0] = tmp1;\nRETURN_DATA[63 : 32] = tmp2", "notes": ""}, "ds_storexchg_2addr_stride64_rtn_b32": {"desc": "Write-exchange 2 separate dwords with a stride of 64 dwords.", "code": "addr1 = ADDR_BASE.u + OFFSET0.u * 4U * 64U;\naddr2 = ADDR_BASE.u + OFFSET1.u * 4U * 64U;\ntmp1 = MEM[addr1].b;\ntmp2 = MEM[addr2].b;\nMEM[addr1].b = DATA.b;\nMEM[addr2].b = DATA2.b;\n// Note DATA2 can be any other register\nRETURN_DATA[31 : 0] = tmp1;\nRETURN_DATA[63 : 32] = tmp2", "notes": ""}, "ds_cmpstore_rtn_b32": {"desc": "Compare and store.", "code": "tmp = MEM[ADDR].b;\nsrc = DATA.b;\ncmp = DATA2.b;\nMEM[ADDR].b = tmp == cmp ? src : tmp;\nRETURN_DATA.b = tmp", "notes": "In this architecture the order of src and cmp agree with the BUFFER_ATOMIC_CMPSWAP opcode."}, "ds_cmpstore_rtn_f32": {"desc": "16.15. LDS & GDS Instructions 511 of 600\n\"RDNA3\" Instruction Set Architecture\nFloating point compare and store that handles NAN/INF/denormal values.", "code": "tmp = MEM[ADDR].f;\nsrc = DATA.f;\ncmp = DATA2.f;\nMEM[ADDR].f = tmp == cmp ? src : tmp;\nRETURN_DATA.f = tmp", "notes": "In this architecture the order of src and cmp agree with the BUFFER_ATOMIC_CMPSWAP opcode."}, "ds_min_rtn_f32": {"desc": "Minimum of two floating-point values.", "code": "tmp = MEM[ADDR].f;\nsrc = DATA.f;\nMEM[ADDR].f = src < tmp ? src : tmp;\nRETURN_DATA = tmp", "notes": "Floating-point compare handles NAN/INF/denorm."}, "ds_max_rtn_f32": {"desc": "Maximum of two floating-point values.", "code": "tmp = MEM[ADDR].f;\nsrc = DATA.f;\nMEM[ADDR].f = src > tmp ? src : tmp;\nRETURN_DATA = tmp", "notes": "Floating-point compare handles NAN/INF/denorm."}, "ds_wrap_rtn_b32": {"desc": "Wrap calculation. Intended for use in ring buffer management.\n16.15. LDS & GDS Instructions 512 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].u;\nMEM[ADDR].u = tmp >= DATA.u ? tmp - DATA.u : tmp + DATA2.u;\nRETURN_DATA = tmp", "notes": ""}, "ds_swizzle_b32": {"desc": "Dword swizzle, no data is written to LDS memory.\nSwizzles input thread data based on offset mask and returns; note does not read or write the DS memory banks.\nNote that reading from an invalid thread results in 0x0.\nThis opcode supports two specific modes, FFT and rotate, plus two basic modes which swizzle in groups of 4 or\n32 consecutive threads.\nThe FFT mode (offset >= 0xe000) swizzles the input based on offset[4:0] to support FFT calculation. Example\nswizzles using input {1, 2, \u2026 20} are:\nOffset[4:0]: Swizzle\n0x00: {1,11,9,19,5,15,d,1d,3,13,b,1b,7,17,f,1f,2,12,a,1a,6,16,e,1e,4,14,c,1c,8,18,10,20}\n0x10: {1,9,5,d,3,b,7,f,2,a,6,e,4,c,8,10,11,19,15,1d,13,1b,17,1f,12,1a,16,1e,14,1c,18,20}\n0x1f: No swizzle\nThe rotate mode (offset >= 0xc000 and offset < 0xe000) rotates the input either left (offset[10] == 0) or right\n(offset[10] == 1) a number of threads equal to offset[9:5]. The rotate mode also uses a mask value which can\nalter the rotate result. For example, mask == 1 swaps the odd threads across every other even thread (rotate\nleft), or even threads across every other odd thread (rotate right).\nOffset[9:5]: Swizzle\n0x01, mask=0, rotate left: {2,3,4,5,6,7,8,9,a,b,c,d,e,f,10,11,12,13,14,15,16,17,18,19,1a,1b,1c,1d,1e,1f,20,1}\n0x01, mask=0, rotate right: {20,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f,10,11,12,13,14,15,16,17,18,19,1a,1b,1c,1d,1e,1f}\n0x01, mask=1, rotate left: {2,1,4,7,6,5,8,b,a,9,c,f,e,d,10,13,12,11,14,17,16,15,18,1b,1a,19,1c,1f,1e,1d,20,3}\n0x01, mask=1, rotate right: {1e,1,4,3,2,5,8,7,6,9,c,b,a,d,10,f,e,11,14,13,12,15,18,17,16,19,1c,1b,1a,1d,20,1f}\nIf offset < 0xc000, one of the basic swizzle modes is used based on offset[15]. If offset[15] == 1, groups of 4\nconsecutive threads are swizzled together. If offset[15] == 0, all 32 threads are swizzled together.\nThe first basic swizzle mode (when offset[15] == 1) allows full data sharing between a group of 4 consecutive\nthreads. Any thread within the group of 4 can get data from any other thread within the group of 4, specified by\nthe corresponding offset bits --- [1:0] for the first thread, [3:2] for the second thread, [5:4] for the third thread,\n[7:6] for the fourth thread. Note that the offset bits apply to all groups of 4 within a wavefront; thus if offset[1:0]\n== 1, then thread0 grabs thread1, thread4 grabs thread5, etc.\nThe second basic swizzle mode (when offset[15] == 0) allows limited data sharing between 32 consecutive\nthreads. In this case, the offset is used to specify a 5-bit xor-mask, 5-bit or-mask, and 5-bit and-mask used to\ngenerate a thread mapping. Note that the offset bits apply to each group of 32 within a wavefront. The details of\nthe thread mapping are listed below. Some example usages:\nSWAPX16 : xor_mask = 0x10, or_mask = 0x00, and_mask = 0x1f\nSWAPX8 : xor_mask = 0x08, or_mask = 0x00, and_mask = 0x1f\n16.15. LDS & GDS Instructions 513 of 600\n\"RDNA3\" Instruction Set Architecture\nSWAPX4 : xor_mask = 0x04, or_mask = 0x00, and_mask = 0x1f\nSWAPX2 : xor_mask = 0x02, or_mask = 0x00, and_mask = 0x1f\nSWAPX1 : xor_mask = 0x01, or_mask = 0x00, and_mask = 0x1f\nREVERSEX32 : xor_mask = 0x1f, or_mask = 0x00, and_mask = 0x1f\nREVERSEX16 : xor_mask = 0x0f, or_mask = 0x00, and_mask = 0x1f\nREVERSEX8 : xor_mask = 0x07, or_mask = 0x00, and_mask = 0x1f\nREVERSEX4 : xor_mask = 0x03, or_mask = 0x00, and_mask = 0x1f\nREVERSEX2 : xor_mask = 0x01 or_mask = 0x00, and_mask = 0x1f\nBCASTX32: xor_mask = 0x00, or_mask = thread, and_mask = 0x00\nBCASTX16: xor_mask = 0x00, or_mask = thread, and_mask = 0x10\nBCASTX8: xor_mask = 0x00, or_mask = thread, and_mask = 0x18\nBCASTX4: xor_mask = 0x00, or_mask = thread, and_mask = 0x1c\nBCASTX2: xor_mask = 0x00, or_mask = thread, and_mask = 0x1e\nPseudocode follows:\n16.15. LDS & GDS Instructions 514 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "offset = offset1:offset0;\nif (offset >= 0xe000) {\n// FFT decomposition\nmask = offset[4:0];\nfor (i = 0; i < 64; i++) {\nj = reverse_bits(i & 0x1f);\nj = (j >> count_ones(mask));\nj |= (i & mask);\nj |= i & 0x20;\nthread_out[i] = thread_valid[j] ? thread_in[j] : 0;\n}\n} elsif (offset >= 0xc000) {\n// rotate\nrotate = offset[9:5];\nmask = offset[4:0];\nif (offset[10]) {\nrotate = -rotate;\n}\nfor (i = 0; i < 64; i++) {\nj = (i & mask) | ((i + rotate) & ~mask);\nj |= i & 0x20;\nthread_out[i] = thread_valid[j] ? thread_in[j] : 0;\n}\n} elsif (offset[15]) {\n// full data sharing within 4 consecutive threads\nfor (i = 0; i < 64; i+=4) {\nthread_out[i+0] = thread_valid[i+offset[1:0]]?thread_in[i+offset[1:0]]:0;\nthread_out[i+1] = thread_valid[i+offset[3:2]]?thread_in[i+offset[3:2]]:0;\nthread_out[i+2] = thread_valid[i+offset[5:4]]?thread_in[i+offset[5:4]]:0;\nthread_out[i+3] = thread_valid[i+offset[7:6]]?thread_in[i+offset[7:6]]:0;\n}\n} else { // offset[15] == 0\n// limited data sharing within 32 consecutive threads\nxor_mask = offset[14:10];\nor_mask = offset[9:5];\nand_mask = offset[4:0];\nfor (i = 0; i < 64; i++) {\nj = (((i & 0x1f) & and_mask) | or_mask) ^ xor_mask;\nj |= (i & 0x20); // which group of 32\nthread_out[i] = thread_valid[j] ? thread_in[j] : 0;\n}\n}", "notes": ""}, "ds_load_b32": {"desc": "Load 32-bit data from a given memory location into a vector register.", "code": "RETURN_DATA = MEM[ADDR].b", "notes": ""}, "ds_load_2addr_b32": {"desc": "Read 2 dwords.", "code": "RETURN_DATA[31 : 0] = MEM[ADDR_BASE.u + OFFSET0.u * 4U].b;\nRETURN_DATA[63 : 32] = MEM[ADDR_BASE.u + OFFSET1.u * 4U].b", "notes": ""}, "ds_load_2addr_stride64_b32": {"desc": "Read 2 dwords with a larger stride.\n16.15. LDS & GDS Instructions 515 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "RETURN_DATA[31 : 0] = MEM[ADDR_BASE.u + OFFSET0.u * 4U * 64U].b;\nRETURN_DATA[63 : 32] = MEM[ADDR_BASE.u + OFFSET1.u * 4U * 64U].b", "notes": ""}, "ds_load_i8": {"desc": "Signed byte read.", "code": "RETURN_DATA.i = 32'I(signext(MEM[ADDR][7 : 0].i8))", "notes": ""}, "ds_load_u8": {"desc": "Unsigned byte read.", "code": "RETURN_DATA.u = 32'U({ 24'0, MEM[ADDR][7 : 0].u8 })", "notes": ""}, "ds_load_i16": {"desc": "Signed short read.", "code": "RETURN_DATA.i = 32'I(signext(MEM[ADDR][15 : 0].i16))", "notes": ""}, "ds_load_u16": {"desc": "Unsigned short read.", "code": "RETURN_DATA.u = 32'U({ 16'0, MEM[ADDR][15 : 0].u16 })", "notes": ""}, "ds_consume": {"desc": "LDS & GDS. Subtract (count_bits(exec_mask)) from the value stored in DS memory at (M0.base + instr_offset).\nReturn the pre-operation value to VGPRs.\nThe DS subtracts count_bits(vector valid mask) from the value stored at address M0.base + instruction based\noffset and returns the pre-op value to all valid lanes. This op can be used in both the LDS and GDS. In the LDS\nthis address is an offset to HWBASE and clamped by M0.size, but in the GDS the M0.base constant has the\nphysical GDS address and the compiler must force offset to zero. In GDS it is for the traditional append buffer\noperations. In LDS it is for local thread group appends and can be used to regroup divergent threads. The use\n16.15. LDS & GDS Instructions 516 of 600\n\"RDNA3\" Instruction Set Architecture\nof the M0 register enables the compiler to do indexing of UAV append/consume counters.\nFor GDS (system wide) consume, the compiler must use a zero for {offset1,offset0}, for LDS the compiler uses\n{offset1,offset0} to provide the relative address to the append counter in the LDS for runtime index offset or\nindex.\nInside DS, do one atomic add for first valid lane and broadcast result to all valid lanes. Offset = 0ffset1:offset0;\nInterpreted as byte offset. Only aligned atomics are supported, so 2 lsbs of offset must be set to zero.", "code": "addr = M0.base + offset; // offset by LDS HWBASE, limit to M.size\nrtnval = LDS(addr);\nLDS(addr) = LDS(addr) - countbits(valid mask);\nGPR[VDST] = rtnval; // return to all valid threads", "notes": ""}, "ds_append": {"desc": "LDS & GDS. Add (count_bits(exec_mask)) to the value stored in DS memory at (M0.base + instr_offset). Return\nthe pre-operation value to VGPRs.\nThe DS adds count_bits(vector valid mask) from the value stored at address M0.base + instruction based offset\nand return the pre-op value to all valid lanes. This op can be used in both the LDS and GDS. In the LDS this\naddress is an offset to HWBASE and clamped by M0.size, but in the GDS the M0.base constant has the physical\nGDS address and the compiler must set offset to zero. In GDS it is for the traditional append buffer operations.\nIn LDS it is for local thread group appends and can be used to regroup divergent threads. The use of the M0\nregister enables the compiler to do indexing of UAV append/consume counters.\nFor GDS (system wide) consume, the compiler must use a zero for {offset1,offset0}, for LDS the compiler uses\n{offset1,offset0} to provide the relative address to the append counter in the LDS for runtime index offset or\nindex.\nInside DS, do one atomic add for first valid lane and broadcast result to all valid lanes. Offset = 0ffset1:offset0;\nInterpreted as byte offset. Only aligned atomics are supported, so 2 lsbs of offset must be set to zero.", "code": "addr = M0.base + offset; // offset by LDS HWBASE, limit to M.size\nrtnval = LDS(addr);\nLDS(addr) = LDS(addr) + countbits(valid mask);\nGPR[VDST] = rtnval; // return to all valid threads", "notes": ""}, "ds_ordered_count": {"desc": "GDS-only: Intercepted by GDS and processed by ordered append module. The ordered append module queues\nrequest until this request wave is the oldest in the queue at which time the oldest wave request is dispatched to\nthe DS with an atomic opcode indicated by OFFSET1[5:4].\nUnlike append/consume this operation is sent even if there are no valid lanes when it is issued. The GDS adds\nzero and advances the tracking walker that needs to match up with the dispatch counter.\n16.15. LDS & GDS Instructions 517 of 600\n\"RDNA3\" Instruction Set Architecture\nThe following attributes are encoded in the instruction:\n\u2022 OFFSET0[7:2] contains the ordered_count_index (in dwords).\n\u2022 OFFSET1[0] contains the wave_release flag.\n\u2022 OFFSET1[1] contains the wave_done flag.\n\u2022 OFFSET1[5:4] contains the ord_idx_opcode: 2'b00 = DS_ADD_RTN_U32, 2'b01 = DS_STOREXCHG_RTN_B32,\n2'b11 = DS_WRAP_RTN_B32.\n\u2022 VGPR_DST is the VGPR the result is written to.\n\u2022 VGPR_ADDR specifies the increment in the first valid lane. If no lanes are valid (EXEC = 0) then the\nincrement is zero.\n\u2022 M0 normally carries {16'gds_base, 16'gds_size} for GDS usage. gds_base[15:2] is ordered_count_base[13:0]\n(in dwords) and gds_size is used to hold the logical_wave_id, the width is based on total number of waves\nin the chip.\nThe wave type is determined automatically based on the ME_ID and QUEUE_ID of the wavefront.", "code": "", "notes": ""}, "ds_add_u64": {"desc": "Add data register to 64-bit memory value.", "code": "tmp = MEM[ADDR].u64;\nMEM[ADDR].u64 += DATA.u64;\nRETURN_DATA.u64 = tmp", "notes": ""}, "ds_sub_u64": {"desc": "Subtract data register from 64-bit memory value.", "code": "tmp = MEM[ADDR].u64;\nMEM[ADDR].u64 -= DATA.u64;\nRETURN_DATA.u64 = tmp", "notes": ""}, "ds_rsub_u64": {"desc": "Subtraction with reversed operands.\n16.15. LDS & GDS Instructions 518 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = DATA.b64 - tmp;\nRETURN_DATA.b64 = tmp", "notes": ""}, "ds_inc_u64": {"desc": "Increment 64-bit memory value with wraparound to zero when incremented to register value.", "code": "tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = tmp >= src ? 0ULL : tmp + 1ULL;\nRETURN_DATA.u64 = tmp", "notes": ""}, "ds_dec_u64": {"desc": "Decrement 64-bit memory value with wraparound to register value when decremented below zero.", "code": "tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = ((tmp == 0ULL) || (tmp > src)) ? src : tmp - 1ULL;\nRETURN_DATA.u64 = tmp", "notes": ""}, "ds_min_i64": {"desc": "Minimum of two signed 64-bit integer values.", "code": "tmp = MEM[ADDR].i64;\nsrc = DATA.i64;\nMEM[ADDR].i64 = src < tmp ? src : tmp;\nRETURN_DATA.i64 = tmp", "notes": ""}, "ds_max_i64": {"desc": "Maximum of two signed 64-bit integer values.", "code": "tmp = MEM[ADDR].i64;\nsrc = DATA.i64;\nMEM[ADDR].i64 = src > tmp ? src : tmp;\nRETURN_DATA.i64 = tmp", "notes": ""}, "ds_min_u64": {"desc": "Minimum of two unsigned 64-bit integer values.\n16.15. LDS & GDS Instructions 519 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = src < tmp ? src : tmp;\nRETURN_DATA.u64 = tmp", "notes": ""}, "ds_max_u64": {"desc": "Maximum of two unsigned 64-bit integer values.", "code": "tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = src > tmp ? src : tmp;\nRETURN_DATA.u64 = tmp", "notes": ""}, "ds_and_b64": {"desc": "Bitwise AND of register value and 64-bit memory value.", "code": "tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp & DATA.b64);\nRETURN_DATA.b64 = tmp", "notes": ""}, "ds_or_b64": {"desc": "Bitwise OR of register value and 64-bit memory value.", "code": "tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp | DATA.b64);\nRETURN_DATA.b64 = tmp", "notes": ""}, "ds_xor_b64": {"desc": "Bitwise XOR of register value and 64-bit memory value.\n16.15. LDS & GDS Instructions 520 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp ^ DATA.b64);\nRETURN_DATA.b64 = tmp", "notes": ""}, "ds_mskor_b64": {"desc": "Masked dword OR, D0 contains the mask and D1 contains the new value.", "code": "tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = ((tmp & ~DATA.b64) | DATA2.b64);\nRETURN_DATA.b64 = tmp", "notes": ""}, "ds_store_b64": {"desc": "Write qword.", "code": "MEM[ADDR].b64 = DATA.b64", "notes": ""}, "ds_store_2addr_b64": {"desc": "Write 2 qwords.", "code": "MEM[ADDR_BASE.u + OFFSET0.u * 8U].b64 = DATA.b64;\nMEM[ADDR_BASE.u + OFFSET1.u * 8U].b64 = DATA2.b64", "notes": ""}, "ds_store_2addr_stride64_b64": {"desc": "Write 2 qwords with a larger stride.", "code": "MEM[ADDR_BASE.u + OFFSET0.u * 8U * 64U].b64 = DATA.b64;\nMEM[ADDR_BASE.u + OFFSET1.u * 8U * 64U].b64 = DATA2.b64", "notes": ""}, "ds_cmpstore_b64": {"desc": "Compare and store.\n16.15. LDS & GDS Instructions 521 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].b64;\nsrc = DATA.b64;\ncmp = DATA2.b64;\nMEM[ADDR].b64 = tmp == cmp ? src : tmp;\nRETURN_DATA.b64 = tmp", "notes": "In this architecture the order of src and cmp agree with the BUFFER_ATOMIC_CMPSWAP opcode."}, "ds_cmpstore_f64": {"desc": "Floating point compare and store that handles NAN/INF/denormal values.", "code": "tmp = MEM[ADDR].f64;\nsrc = DATA.f64;\ncmp = DATA2.f64;\nMEM[ADDR].f64 = tmp == cmp ? src : tmp;\nRETURN_DATA.f64 = tmp", "notes": "In this architecture the order of src and cmp agree with the BUFFER_ATOMIC_CMPSWAP opcode."}, "ds_min_f64": {"desc": "Minimum of two floating-point values.", "code": "tmp = MEM[ADDR].f64;\nsrc = DATA.f64;\nMEM[ADDR].f64 = src < tmp ? src : tmp;\nRETURN_DATA.f64 = tmp", "notes": "Floating-point compare handles NAN/INF/denorm."}, "ds_max_f64": {"desc": "Maximum of two floating-point values.\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].f64;\nsrc = DATA.f64;\nMEM[ADDR].f64 = src > tmp ? src : tmp;\nRETURN_DATA.f64 = tmp", "notes": "Floating-point compare handles NAN/INF/denorm.\n16.15. LDS & GDS Instructions 522 of 600"}, "ds_add_rtn_u64": {"desc": "Add data register to 64-bit memory value.", "code": "tmp = MEM[ADDR].u64;\nMEM[ADDR].u64 += DATA.u64;\nRETURN_DATA.u64 = tmp", "notes": ""}, "ds_sub_rtn_u64": {"desc": "Subtract data register from 64-bit memory value.", "code": "tmp = MEM[ADDR].u64;\nMEM[ADDR].u64 -= DATA.u64;\nRETURN_DATA.u64 = tmp", "notes": ""}, "ds_rsub_rtn_u64": {"desc": "Subtraction with reversed operands.", "code": "tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = DATA.b64 - tmp;\nRETURN_DATA.b64 = tmp", "notes": ""}, "ds_inc_rtn_u64": {"desc": "Increment 64-bit memory value with wraparound to zero when incremented to register value.", "code": "tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = tmp >= src ? 0ULL : tmp + 1ULL;\nRETURN_DATA.u64 = tmp", "notes": ""}, "ds_dec_rtn_u64": {"desc": "Decrement 64-bit memory value with wraparound to register value when decremented below zero.\n16.15. LDS & GDS Instructions 523 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = ((tmp == 0ULL) || (tmp > src)) ? src : tmp - 1ULL;\nRETURN_DATA.u64 = tmp", "notes": ""}, "ds_min_rtn_i64": {"desc": "Minimum of two signed 64-bit integer values.", "code": "tmp = MEM[ADDR].i64;\nsrc = DATA.i64;\nMEM[ADDR].i64 = src < tmp ? src : tmp;\nRETURN_DATA.i64 = tmp", "notes": ""}, "ds_max_rtn_i64": {"desc": "Maximum of two signed 64-bit integer values.", "code": "tmp = MEM[ADDR].i64;\nsrc = DATA.i64;\nMEM[ADDR].i64 = src > tmp ? src : tmp;\nRETURN_DATA.i64 = tmp", "notes": ""}, "ds_min_rtn_u64": {"desc": "Minimum of two unsigned 64-bit integer values.", "code": "tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = src < tmp ? src : tmp;\nRETURN_DATA.u64 = tmp", "notes": ""}, "ds_max_rtn_u64": {"desc": "Maximum of two unsigned 64-bit integer values.\n16.15. LDS & GDS Instructions 524 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = src > tmp ? src : tmp;\nRETURN_DATA.u64 = tmp", "notes": ""}, "ds_and_rtn_b64": {"desc": "Bitwise AND of register value and 64-bit memory value.", "code": "tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp & DATA.b64);\nRETURN_DATA.b64 = tmp", "notes": ""}, "ds_or_rtn_b64": {"desc": "Bitwise OR of register value and 64-bit memory value.", "code": "tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp | DATA.b64);\nRETURN_DATA.b64 = tmp", "notes": ""}, "ds_xor_rtn_b64": {"desc": "Bitwise XOR of register value and 64-bit memory value.", "code": "tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp ^ DATA.b64);\nRETURN_DATA.b64 = tmp", "notes": ""}, "ds_mskor_rtn_b64": {"desc": "Masked dword OR, D0 contains the mask and D1 contains the new value.", "code": "tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = ((tmp & ~DATA.b64) | DATA2.b64);\nRETURN_DATA.b64 = tmp", "notes": ""}, "ds_storexchg_rtn_b64": {"desc": "Write-exchange operation.\n16.15. LDS & GDS Instructions 525 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = DATA.b64;\nRETURN_DATA.b64 = tmp", "notes": ""}, "ds_storexchg_2addr_rtn_b64": {"desc": "Write-exchange 2 separate qwords.", "code": "addr1 = ADDR_BASE.u + OFFSET0.u * 8U;\naddr2 = ADDR_BASE.u + OFFSET1.u * 8U;\ntmp1 = MEM[addr1].b64;\ntmp2 = MEM[addr2].b64;\nMEM[addr1].b64 = DATA.b64;\nMEM[addr2].b64 = DATA2.b64;\n// Note DATA2 can be any other register\nRETURN_DATA[63 : 0] = tmp1;\nRETURN_DATA[127 : 64] = tmp2", "notes": ""}, "ds_storexchg_2addr_stride64_rtn_b64": {"desc": "Write-exchange 2 qwords with a stride of 64 qwords.", "code": "addr1 = ADDR_BASE.u + OFFSET0.u * 8U * 64U;\naddr2 = ADDR_BASE.u + OFFSET1.u * 8U * 64U;\ntmp1 = MEM[addr1].b64;\ntmp2 = MEM[addr2].b64;\nMEM[addr1].b64 = DATA.b64;\nMEM[addr2].b64 = DATA2.b64;\n// Note DATA2 can be any other register\nRETURN_DATA[63 : 0] = tmp1;\nRETURN_DATA[127 : 64] = tmp2", "notes": ""}, "ds_cmpstore_rtn_b64": {"desc": "Compare and store.\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].b64;\nsrc = DATA.b64;\ncmp = DATA2.b64;\nMEM[ADDR].b64 = tmp == cmp ? src : tmp;\nRETURN_DATA.b64 = tmp", "notes": "In this architecture the order of src and cmp agree with the BUFFER_ATOMIC_CMPSWAP opcode.\n16.15. LDS & GDS Instructions 526 of 600"}, "ds_cmpstore_rtn_f64": {"desc": "Floating point compare and store that handles NAN/INF/denormal values.", "code": "tmp = MEM[ADDR].f64;\nsrc = DATA.f64;\ncmp = DATA2.f64;\nMEM[ADDR].f64 = tmp == cmp ? src : tmp;\nRETURN_DATA.f64 = tmp", "notes": "In this architecture the order of src and cmp agree with the BUFFER_ATOMIC_CMPSWAP opcode."}, "ds_min_rtn_f64": {"desc": "Minimum of two floating-point values.", "code": "tmp = MEM[ADDR].f64;\nsrc = DATA.f64;\nMEM[ADDR].f64 = src < tmp ? src : tmp;\nRETURN_DATA.f64 = tmp", "notes": "Floating-point compare handles NAN/INF/denorm."}, "ds_max_rtn_f64": {"desc": "Maximum of two floating-point values.", "code": "tmp = MEM[ADDR].f64;\nsrc = DATA.f64;\nMEM[ADDR].f64 = src > tmp ? src : tmp;\nRETURN_DATA.f64 = tmp", "notes": "Floating-point compare handles NAN/INF/denorm."}, "ds_load_b64": {"desc": "16.15. LDS & GDS Instructions 527 of 600\n\"RDNA3\" Instruction Set Architecture\nRead 1 qword.", "code": "RETURN_DATA = MEM[ADDR].b64", "notes": ""}, "ds_load_2addr_b64": {"desc": "Read 2 qwords.", "code": "RETURN_DATA[63 : 0] = MEM[ADDR_BASE.u + OFFSET0.u * 8U].b64;\nRETURN_DATA[127 : 64] = MEM[ADDR_BASE.u + OFFSET1.u * 8U].b64", "notes": ""}, "ds_load_2addr_stride64_b64": {"desc": "Read 2 qwords with a larger stride.", "code": "RETURN_DATA[63 : 0] = MEM[ADDR_BASE.u + OFFSET0.u * 8U * 64U].b64;\nRETURN_DATA[127 : 64] = MEM[ADDR_BASE.u + OFFSET1.u * 8U * 64U].b64", "notes": ""}, "ds_add_rtn_f32": {"desc": "Add data register to floating-point memory value.", "code": "tmp = MEM[ADDR].f;\nsrc = DATA.f;\nMEM[ADDR].f = src + tmp;\nRETURN_DATA.f = tmp", "notes": "Floating-point addition handles NAN/INF/denorm."}, "ds_add_gs_reg_rtn": {"desc": "Perform an atomic add to data in specific registers embedded in GDS rather than operating on GDS memory\ndirectly. This instruction returns the pre-op value. This instruction is only used by the GS stage and is used to\nfacilitate streamout.\nThe return value may be 32 bits or 64 bits depending on the GS register accessed. The data value is 32 bits.\n16.15. LDS & GDS Instructions 528 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "if OFFSET0[5:2] > 7\n// 64-bit GS register access\naddr = (OFFSET0[5:2] - 8) * 2 + 8;\nVDST[0] = GS_REGS(addr + 0);\nVDST[1] = GS_REGS(addr + 1);\n{GS_REGS(addr + 1), GS_REGS(addr)} += DATA0[0]; // source is 32 bit\nelse\naddr = OFFSET0[5:2];\nVDST[0] = GS_REGS(addr);\nGS_REGS(addr) += DATA0[0];\nendif.", "notes": "offset[5:2] Register\n0 GDS_STRMOUT_BUFFER_FILLED_SIZE_0\n1 GDS_STRMOUT_BUFFER_FILLED_SIZE_1\n2 GDS_STRMOUT_BUFFER_FILLED_SIZE_2\n3 GDS_STRMOUT_BUFFER_FILLED_SIZE_3\n4 GDS_GS_0\n5 GDS_GS_1\n6 GDS_GS_2\n7 GDS_GS_3\n64-bit GS registers:\noffset[5:2] Register\n8 GDS_STRMOUT_PRIMS_NEEDED_0\n9 GDS_STRMOUT_PRIMS_WRITTEN_0\n10 GDS_STRMOUT_PRIMS_NEEDED_1\n11 GDS_STRMOUT_PRIMS_WRITTEN_1\n12 GDS_STRMOUT_PRIMS_NEEDED_2\n13 GDS_STRMOUT_PRIMS_WRITTEN_2\n14 GDS_STRMOUT_PRIMS_NEEDED_3\n15 GDS_STRMOUT_PRIMS_WRITTEN_3"}, "ds_sub_gs_reg_rtn": {"desc": "Perform an atomic subtraction from data in specific registers embedded in GDS rather than operating on GDS\nmemory directly. This instruction returns the pre-op value. This instruction is only used by the GS stage and is\nused to facilitate streamout.\nThe return value may be 32 bits or 64 bits depending on the GS register accessed. The data value is 32 bits.\n16.15. LDS & GDS Instructions 529 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "if OFFSET0[5:2] > 7\n// 64-bit GS register access\naddr = (OFFSET0[5:2] - 8) * 2 + 8;\nVDST[0] = GS_REGS(addr + 0);\nVDST[1] = GS_REGS(addr + 1);\n{GS_REGS(addr + 1), GS_REGS(addr)} -= DATA0[0]; // source is 32 bit\nelse\naddr = OFFSET0[5:2];\nVDST[0] = GS_REGS(addr);\nGS_REGS(addr) -= DATA0[0];\nendif.", "notes": "offset[5:2] Register\n0 GDS_STRMOUT_BUFFER_FILLED_SIZE_0\n1 GDS_STRMOUT_BUFFER_FILLED_SIZE_1\n2 GDS_STRMOUT_BUFFER_FILLED_SIZE_2\n3 GDS_STRMOUT_BUFFER_FILLED_SIZE_3\n4 GDS_GS_0\n5 GDS_GS_1\n6 GDS_GS_2\n7 GDS_GS_3\n64-bit GS registers:\noffset[5:2] Register\n8 GDS_STRMOUT_PRIMS_NEEDED_0\n9 GDS_STRMOUT_PRIMS_WRITTEN_0\n10 GDS_STRMOUT_PRIMS_NEEDED_1\n11 GDS_STRMOUT_PRIMS_WRITTEN_1\n12 GDS_STRMOUT_PRIMS_NEEDED_2\n13 GDS_STRMOUT_PRIMS_WRITTEN_2\n14 GDS_STRMOUT_PRIMS_NEEDED_3\n15 GDS_STRMOUT_PRIMS_WRITTEN_3"}, "ds_condxchg32_rtn_b64": {"desc": "Conditional write exchange.\n16.15. LDS & GDS Instructions 530 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "declare OFFSET0 : 8'U;\ndeclare OFFSET1 : 8'U;\ndeclare RETURN_DATA : 32'U[2];\nADDR = S0.u;\nDATA = S1.u64;\noffset = { OFFSET1, OFFSET0 };\nADDR0 = ((ADDR + offset.u) & 0xfff8U);\nADDR1 = ADDR0 + 4U;\nRETURN_DATA[0] = LDS[ADDR0].u;\nif DATA[31] then\nLDS[ADDR0] = { 1'0, DATA[30 : 0] }\nendif;\nRETURN_DATA[1] = LDS[ADDR1].u;\nif DATA[63] then\nLDS[ADDR1] = { 1'0, DATA[62 : 32] }\nendif", "notes": ""}, "ds_store_b8_d16_hi": {"desc": "Byte write in to high word.", "code": "MEM[ADDR].b8 = DATA[23 : 16].b8", "notes": ""}, "ds_store_b16_d16_hi": {"desc": "Short write in to high word.", "code": "MEM[ADDR].b16 = DATA[31 : 16].b16", "notes": ""}, "ds_load_u8_d16": {"desc": "Unsigned byte read with masked return to lower word.", "code": "RETURN_DATA[15 : 0].u16 = 16'U({ 8'0U, MEM[ADDR][7 : 0].u8 })", "notes": ""}, "ds_load_u8_d16_hi": {"desc": "Unsigned byte read with masked return to upper word.", "code": "RETURN_DATA[31 : 16].u16 = 16'U({ 8'0U, MEM[ADDR][7 : 0].u8 })", "notes": ""}, "ds_load_i8_d16": {"desc": "Signed byte read with masked return to lower word.", "code": "RETURN_DATA[15 : 0].i16 = 16'I(signext(MEM[ADDR][7 : 0].i8))", "notes": ""}, "ds_load_i8_d16_hi": {"desc": "16.15. LDS & GDS Instructions 531 of 600\n\"RDNA3\" Instruction Set Architecture\nSigned byte read with masked return to upper word.", "code": "RETURN_DATA[31 : 16].i16 = 16'I(signext(MEM[ADDR][7 : 0].i8))", "notes": ""}, "ds_load_u16_d16": {"desc": "Unsigned short read with masked return to lower word.", "code": "RETURN_DATA[15 : 0].u16 = MEM[ADDR][15 : 0].u16", "notes": ""}, "ds_load_u16_d16_hi": {"desc": "Unsigned short read with masked return to upper word.", "code": "RETURN_DATA[31 : 16].u16 = MEM[ADDR][15 : 0].u16", "notes": ""}, "ds_bvh_stack_rtn_b32": {"desc": "Ray tracing involves traversing a BVH which is a kind of tree where nodes have up to 4 children. Each shader\nthread processes one child at a time, and overflow nodes are stored temporarily in LDS using a stack. This\ninstruction supports pushing/popping the stack to reduce the number of VALU instructions required per\ntraversal and reduce VMEM bandwidth requirements.\nThe LDS stack address is computed using values packed into ADDR and part of OFFSET1. ADDR carries the\nstack address for the lane. OFFSET1[5:4] contains stack_size[1:0] -- this value is constant for all lanes and is\npatched into the shader by software. Valid stack sizes are {8, 16, 32, 64}.\nA new stack address is returned to ADDR --- note that this VGPR is an in-out operand.\nDATA0 contains the last node pointer for BVH.\nDATA1 contains up to 4 valid data DWORDs for each thread. At a high level the first 3 DWORDs (DATA1[0:2]) is\npushed to the stack if they are valid, and the last DWORD (DATA1[3]) is returned. If the last DWORD is invalid\nthen pop the stack and return the value from memory.\nIn general this instruction performs the following :\n16.15. LDS & GDS Instructions 532 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "(stack_base, stack_index) = DECODE_ADDR(ADDR, OFFSET1);\nlast_node_ptr = DATA0;\n// First 3 passes: push data onto stack\nfor i = 0..2 do\nif DATA_VALID(DATA1[i])\nMEM[stack_base + stack_index] = DATA1[i];\nIncrement stack_index\nelsif DATA1[i] == last_node_ptr\n// Treat all further data as invalid as well.\nbreak\nendif\nendfor\n// Fourth pass: return data or pop\nif DATA_VALID(DATA1[3])\nVGPR_RTN = DATA1[3]\nelse\nVGPR_RTN = MEM[stack_base + stack_index];\nMEM[stack_base + stack_index] = INVALID_NODE;\nDecrement stack_index\nendif\nADDR = ENCODE_ADDR(stack_base, stack_index).\nfunction DATA_VALID(data):\nif data == INVALID_NODE\nreturn false\nelsif last_node_ptr != INVALID_NODE && data == last_node_ptr\n// Match last_node_ptr\nreturn false\nelse\nreturn true\nendif\nendfunction.", "notes": ""}, "ds_store_addtid_b32": {"desc": "Write dword with thread ID offset.", "code": "declare OFFSET0 : 8'U;\ndeclare OFFSET1 : 8'U;\nMEM[32'I({ OFFSET1, OFFSET0 } + M0[15 : 0]) + laneID.i * 4].u = DATA0.u", "notes": ""}, "ds_load_addtid_b32": {"desc": "Read dword with thread ID offset.", "code": "declare OFFSET0 : 8'U;\ndeclare OFFSET1 : 8'U;\nRETURN_DATA.u = MEM[32'I({ OFFSET1, OFFSET0 } + M0[15 : 0]) + laneID.i * 4].u", "notes": ""}, "ds_permute_b32": {"desc": "16.15. LDS & GDS Instructions 533 of 600\n\"RDNA3\" Instruction Set Architecture\nForward permute. This does not access LDS memory and may be called even if no LDS memory is allocated to\nthe wave. It uses LDS to implement an arbitrary swizzle across threads in a wavefront.\nNote the address passed in is the thread ID multiplied by 4.\nIf multiple sources map to the same destination lane, it is not deterministic which source lane writes to the\ndestination lane.\nSee also DS_BPERMUTE_B32.\n\"RDNA3\" Instruction Set Architecture", "code": "// VGPR[laneId][index] is the VGPR RAM\n// VDST, ADDR and DATA0 are from the microcode DS encoding\ndeclare tmp : 32'B[64];\ndeclare OFFSET : 16'U;\ndeclare DATA0 : 32'U;\ndeclare VDST : 32'U;\nfor i in 0 : WAVE64 ? 63 : 31 do\ntmp[i] = 0x0\nendfor;\nfor i in 0 : WAVE64 ? 63 : 31 do\n// If a source thread is disabled, it does not propagate data.\nif EXEC[i].u1 then\n// ADDR needs to be divided by 4.\n// High-order bits are ignored.\n// NOTE: destination lane is MOD 32 regardless of wave size.\ndst_lane = 32'I(VGPR[i][ADDR] + OFFSET.b) / 4 % 32;\ntmp[dst_lane] = VGPR[i][DATA0]\nendif\nendfor;\n// Copy data into destination VGPRs. If multiple sources\n// select the same destination thread, the highest-numbered\n// source thread wins.\nfor i in 0 : WAVE64 ? 63 : 31 do\nif EXEC[i].u1 then\nVGPR[i][VDST] = tmp[i]\nendif\nendfor", "notes": "Examples (simplified 4-thread wavefronts):\nVGPR[SRC0] = { A, B, C, D }\nVGPR[ADDR] = { 0, 0, 12, 4 }\nEXEC = 0xF, OFFSET = 0\nVGPR[VDST] = { B, D, 0, C }\nVGPR[SRC0] = { A, B, C, D }\nVGPR[ADDR] = { 0, 0, 12, 4 }\nEXEC = 0xA, OFFSET = 0\nVGPR[VDST] = { -, D, -, 0 }\n16.15. LDS & GDS Instructions 534 of 600"}, "ds_bpermute_b32": {"desc": "Backward permute. This does not access LDS memory and may be called even if no LDS memory is allocated to\nthe wave. It uses LDS hardware to implement an arbitrary swizzle across threads in a wavefront.\nNote the address passed in is the thread ID multiplied by 4.\nNote that EXEC mask is applied to both VGPR read and write. If src_lane selects a disabled thread then zero is\nreturned.\nSee also DS_PERMUTE_B32.\n\"RDNA3\" Instruction Set Architecture", "code": "// VGPR[laneId][index] is the VGPR RAM\n// VDST, ADDR and DATA0 are from the microcode DS encoding\ndeclare tmp : 32'B[64];\ndeclare OFFSET : 16'U;\ndeclare DATA0 : 32'U;\ndeclare VDST : 32'U;\nfor i in 0 : WAVE64 ? 63 : 31 do\ntmp[i] = 0x0\nendfor;\nfor i in 0 : WAVE64 ? 63 : 31 do\n// ADDR needs to be divided by 4.\n// High-order bits are ignored.\n// NOTE: destination lane is MOD 32 regardless of wave size.\nsrc_lane = 32'I(VGPR[i][ADDR] + OFFSET.b) / 4 % 32;\n// EXEC is applied to the source VGPR reads.\nif EXEC[src_lane].u1 then\ntmp[i] = VGPR[src_lane][DATA0]\nendif\nendfor;\n// Copy data into destination VGPRs. Some source\n// data may be broadcast to multiple lanes.\nfor i in 0 : WAVE64 ? 63 : 31 do\nif EXEC[i].u1 then\nVGPR[i][VDST] = tmp[i]\nendif\nendfor\nEXEC = 0xA, OFFSET = 0\nVGPR[VDST] = { -, 0, -, B }", "notes": "Examples (simplified 4-thread wavefronts):\nVGPR[SRC0] = { A, B, C, D }\nVGPR[ADDR] = { 0, 0, 12, 4 }\nEXEC = 0xF, OFFSET = 0\nVGPR[VDST] = { A, A, D, B }\nVGPR[SRC0] = { A, B, C, D }\nVGPR[ADDR] = { 0, 0, 12, 4 }\n16.15. LDS & GDS Instructions 535 of 600"}, "ds_store_b96": {"desc": "Tri-dword write.", "code": "MEM[ADDR + 0U].b = DATA[31 : 0];\nMEM[ADDR + 4U].b = DATA[63 : 32];\nMEM[ADDR + 8U].b = DATA[95 : 64]", "notes": ""}, "ds_store_b128": {"desc": "Quad-dword write.", "code": "MEM[ADDR + 0U].b = DATA[31 : 0];\nMEM[ADDR + 4U].b = DATA[63 : 32];\nMEM[ADDR + 8U].b = DATA[95 : 64];\nMEM[ADDR + 12U].b = DATA[127 : 96]", "notes": ""}, "ds_load_b96": {"desc": "Tri-dword read.", "code": "RETURN_DATA[31 : 0] = MEM[ADDR + 0U].b;\nRETURN_DATA[63 : 32] = MEM[ADDR + 4U].b;\nRETURN_DATA[95 : 64] = MEM[ADDR + 8U].b", "notes": ""}, "ds_load_b128": {"desc": "Quad-dword read.\n16.15. LDS & GDS Instructions 536 of 600\n\"RDNA3\" Instruction Set Architecture\n\"RDNA3\" Instruction Set Architecture", "code": "RETURN_DATA[31 : 0] = MEM[ADDR + 0U].b;\nRETURN_DATA[63 : 32] = MEM[ADDR + 4U].b;\nRETURN_DATA[95 : 64] = MEM[ADDR + 8U].b;\nRETURN_DATA[127 : 96] = MEM[ADDR + 12U].b", "notes": "Some of the DS instructions are available only to GDS, not LDS. These are:\n\u2022 DS_GWS_SEMA_RELEASE_ALL\n\u2022 DS_GWS_INIT\n\u2022 DS_GWS_SEMA_V\n\u2022 DS_GWS_SEMA_BR\n\u2022 DS_GWS_SEMA_P\n\u2022 DS_GWS_BARRIER\n\u2022 DS_ORDERED_COUNT\n16.15. LDS & GDS Instructions 537 of 600\nThe bitfield map of the MUBUF format is:"}, "buffer_load_format_x": {"desc": "Untyped buffer load 1 component with format conversion.", "code": "VDATA[31 : 0].b = ConvertFromFormat(MEM[TADDR.X]);\n// Mem access size depends on format", "notes": ""}, "buffer_load_format_xy": {"desc": "Untyped buffer load 2 components with format conversion.", "code": "VDATA[31 : 0].b = ConvertFromFormat(MEM[TADDR.X]);\n// Mem access size depends on format\nVDATA[63 : 32].b = ConvertFromFormat(MEM[TADDR.Y])", "notes": ""}, "buffer_load_format_xyz": {"desc": "Untyped buffer load 3 components with format conversion.", "code": "VDATA[31 : 0].b = ConvertFromFormat(MEM[TADDR.X]);\n// Mem access size depends on format\nVDATA[63 : 32].b = ConvertFromFormat(MEM[TADDR.Y]);\nVDATA[95 : 64].b = ConvertFromFormat(MEM[TADDR.Z])", "notes": ""}, "buffer_load_format_xyzw": {"desc": "Untyped buffer load 4 components with format conversion.\n16.16. MUBUF Instructions 538 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "VDATA[31 : 0].b = ConvertFromFormat(MEM[TADDR.X]);\n// Mem access size depends on format\nVDATA[63 : 32].b = ConvertFromFormat(MEM[TADDR.Y]);\nVDATA[95 : 64].b = ConvertFromFormat(MEM[TADDR.Z]);\nVDATA[127 : 96].b = ConvertFromFormat(MEM[TADDR.W])", "notes": ""}, "buffer_store_format_x": {"desc": "Untyped buffer store 1 component with format conversion.", "code": "MEM[TADDR.X] = ConvertToFormat(VDATA[31 : 0].b);\n// Mem access size depends on format", "notes": ""}, "buffer_store_format_xy": {"desc": "Untyped buffer store 2 components with format conversion.", "code": "MEM[TADDR.X] = ConvertToFormat(VDATA[31 : 0].b);\n// Mem access size depends on format\nMEM[TADDR.Y] = ConvertToFormat(VDATA[63 : 32].b)", "notes": ""}, "buffer_store_format_xyz": {"desc": "Untyped buffer store 3 components with format conversion.", "code": "MEM[TADDR.X] = ConvertToFormat(VDATA[31 : 0].b);\n// Mem access size depends on format\nMEM[TADDR.Y] = ConvertToFormat(VDATA[63 : 32].b);\nMEM[TADDR.Z] = ConvertToFormat(VDATA[95 : 64].b)", "notes": ""}, "buffer_store_format_xyzw": {"desc": "Untyped buffer store 4 components with format conversion.", "code": "MEM[TADDR.X] = ConvertToFormat(VDATA[31 : 0].b);\n// Mem access size depends on format\nMEM[TADDR.Y] = ConvertToFormat(VDATA[63 : 32].b);\nMEM[TADDR.Z] = ConvertToFormat(VDATA[95 : 64].b);\nMEM[TADDR.W] = ConvertToFormat(VDATA[127 : 96].b)", "notes": ""}, "buffer_load_d16_format_x": {"desc": "16.16. MUBUF Instructions 539 of 600\n\"RDNA3\" Instruction Set Architecture\nUntyped buffer load 1 component with format conversion, packed 16-bit components in data register.", "code": "VDATA[15 : 0].b16 = 16'B(ConvertFromFormat(MEM[TADDR.X]));\n// Mem access size depends on format\n// VDATA[31:16].b16 is preserved.", "notes": ""}, "buffer_load_d16_format_xy": {"desc": "Untyped buffer load 2 components with format conversion, packed 16-bit components in data register.", "code": "VDATA[15 : 0].b16 = 16'B(ConvertFromFormat(MEM[TADDR.X]));\n// Mem access size depends on format\nVDATA[31 : 16].b16 = 16'B(ConvertFromFormat(MEM[TADDR.Y]))", "notes": ""}, "buffer_load_d16_format_xyz": {"desc": "Untyped buffer load 3 components with format conversion, packed 16-bit components in data register.", "code": "VDATA[15 : 0].b16 = 16'B(ConvertFromFormat(MEM[TADDR.X]));\n// Mem access size depends on format\nVDATA[31 : 16].b16 = 16'B(ConvertFromFormat(MEM[TADDR.Y]));\nVDATA[47 : 32].b16 = 16'B(ConvertFromFormat(MEM[TADDR.Z]));\n// VDATA[63:48].b16 is preserved.", "notes": ""}, "buffer_load_d16_format_xyzw": {"desc": "Untyped buffer load 4 components with format conversion, packed 16-bit components in data register.", "code": "VDATA[15 : 0].b16 = 16'B(ConvertFromFormat(MEM[TADDR.X]));\n// Mem access size depends on format\nVDATA[31 : 16].b16 = 16'B(ConvertFromFormat(MEM[TADDR.Y]));\nVDATA[47 : 32].b16 = 16'B(ConvertFromFormat(MEM[TADDR.Z]));\nVDATA[63 : 48].b16 = 16'B(ConvertFromFormat(MEM[TADDR.W]))", "notes": ""}, "buffer_store_d16_format_x": {"desc": "Untyped buffer store 1 component with format conversion, packed 16-bit components in data register.\n16.16. MUBUF Instructions 540 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "MEM[TADDR.X] = ConvertToFormat(32'B(VDATA[15 : 0].b16));\n// Mem access size depends on format", "notes": ""}, "buffer_store_d16_format_xy": {"desc": "Untyped buffer store 2 components with format conversion, packed 16-bit components in data register.", "code": "MEM[TADDR.X] = ConvertToFormat(32'B(VDATA[15 : 0].b16));\n// Mem access size depends on format\nMEM[TADDR.Y] = ConvertToFormat(32'B(VDATA[31 : 16].b16))", "notes": ""}, "buffer_store_d16_format_xyz": {"desc": "Untyped buffer store 3 components with format conversion, packed 16-bit components in data register.", "code": "MEM[TADDR.X] = ConvertToFormat(32'B(VDATA[15 : 0].b16));\n// Mem access size depends on format\nMEM[TADDR.Y] = ConvertToFormat(32'B(VDATA[31 : 16].b16));\nMEM[TADDR.Z] = ConvertToFormat(32'B(VDATA[47 : 32].b16))", "notes": ""}, "buffer_store_d16_format_xyzw": {"desc": "Untyped buffer store 4 components with format conversion, packed 16-bit components in data register.", "code": "MEM[TADDR.X] = ConvertToFormat(32'B(VDATA[15 : 0].b16));\n// Mem access size depends on format\nMEM[TADDR.Y] = ConvertToFormat(32'B(VDATA[31 : 16].b16));\nMEM[TADDR.Z] = ConvertToFormat(32'B(VDATA[47 : 32].b16));\nMEM[TADDR.W] = ConvertToFormat(32'B(VDATA[63 : 48].b16))", "notes": ""}, "buffer_load_u8": {"desc": "Untyped buffer load unsigned byte, zero extend in data register.", "code": "VDATA.u = 32'U({ 24'0, MEM[ADDR].u8 })", "notes": ""}, "buffer_load_i8": {"desc": "16.16. MUBUF Instructions 541 of 600\n\"RDNA3\" Instruction Set Architecture\nUntyped buffer load signed byte, sign extend in data register.", "code": "VDATA.i = 32'I(signext(MEM[ADDR].i8))", "notes": ""}, "buffer_load_u16": {"desc": "Untyped buffer load unsigned short, zero extend in data register.", "code": "VDATA.u = 32'U({ 16'0, MEM[ADDR].u16 })", "notes": ""}, "buffer_load_i16": {"desc": "Untyped buffer load signed short, sign extend in data register.", "code": "VDATA.i = 32'I(signext(MEM[ADDR].i16))", "notes": ""}, "buffer_load_b32": {"desc": "Untyped buffer load dword.", "code": "VDATA.b = MEM[ADDR].b", "notes": ""}, "buffer_load_b64": {"desc": "Untyped buffer load 2 dwords.", "code": "VDATA[31 : 0] = MEM[ADDR + 0U].b;\nVDATA[63 : 32] = MEM[ADDR + 4U].b", "notes": ""}, "buffer_load_b96": {"desc": "Untyped buffer load 3 dwords.\n16.16. MUBUF Instructions 542 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "VDATA[31 : 0] = MEM[ADDR + 0U].b;\nVDATA[63 : 32] = MEM[ADDR + 4U].b;\nVDATA[95 : 64] = MEM[ADDR + 8U].b", "notes": ""}, "buffer_load_b128": {"desc": "Untyped buffer load 4 dwords.", "code": "VDATA[31 : 0] = MEM[ADDR + 0U].b;\nVDATA[63 : 32] = MEM[ADDR + 4U].b;\nVDATA[95 : 64] = MEM[ADDR + 8U].b;\nVDATA[127 : 96] = MEM[ADDR + 12U].b", "notes": ""}, "buffer_store_b8": {"desc": "Untyped buffer store byte.", "code": "MEM[ADDR].b8 = VDATA[7 : 0]", "notes": ""}, "buffer_store_b16": {"desc": "Untyped buffer store short.", "code": "MEM[ADDR].b16 = VDATA[15 : 0]", "notes": ""}, "buffer_store_b32": {"desc": "Untyped buffer store dword.", "code": "MEM[ADDR].b = VDATA[31 : 0]", "notes": ""}, "buffer_store_b64": {"desc": "Untyped buffer store 2 dwords.\n16.16. MUBUF Instructions 543 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "MEM[ADDR + 0U].b = VDATA[31 : 0];\nMEM[ADDR + 4U].b = VDATA[63 : 32]", "notes": ""}, "buffer_store_b96": {"desc": "Untyped buffer store 3 dwords.", "code": "MEM[ADDR + 0U].b = VDATA[31 : 0];\nMEM[ADDR + 4U].b = VDATA[63 : 32];\nMEM[ADDR + 8U].b = VDATA[95 : 64]", "notes": ""}, "buffer_store_b128": {"desc": "Untyped buffer store 4 dwords.", "code": "MEM[ADDR + 0U].b = VDATA[31 : 0];\nMEM[ADDR + 4U].b = VDATA[63 : 32];\nMEM[ADDR + 8U].b = VDATA[95 : 64];\nMEM[ADDR + 12U].b = VDATA[127 : 96]", "notes": ""}, "buffer_load_d16_u8": {"desc": "Untyped buffer load unsigned byte, use low 16 bits of data register.", "code": "VDATA[15 : 0].u16 = 16'U({ 8'0, MEM[ADDR].u8 });\n// VDATA[31:16] is preserved.", "notes": ""}, "buffer_load_d16_i8": {"desc": "Untyped buffer load signed byte, use low 16 bits of data register.", "code": "VDATA[15 : 0].i16 = 16'I(signext(MEM[ADDR].i8));\n// VDATA[31:16] is preserved.", "notes": ""}, "buffer_load_d16_b16": {"desc": "Untyped buffer load short, use low 16 bits of data register.\n16.16. MUBUF Instructions 544 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "VDATA[15 : 0].b16 = MEM[ADDR].b16;\n// VDATA[31:16] is preserved.", "notes": ""}, "buffer_load_d16_hi_u8": {"desc": "Untyped buffer load unsigned byte, use high 16 bits of data register.", "code": "VDATA[31 : 16].u16 = 16'U({ 8'0, MEM[ADDR].u8 });\n// VDATA[15:0] is preserved.", "notes": ""}, "buffer_load_d16_hi_i8": {"desc": "Untyped buffer load signed byte, use high 16 bits of data register.", "code": "VDATA[31 : 16].i16 = 16'I(signext(MEM[ADDR].i8));\n// VDATA[15:0] is preserved.", "notes": ""}, "buffer_load_d16_hi_b16": {"desc": "Untyped buffer load short, use high 16 bits of data register.", "code": "VDATA[31 : 16].b16 = MEM[ADDR].b16;\n// VDATA[15:0] is preserved.", "notes": ""}, "buffer_store_d16_hi_b8": {"desc": "Untyped buffer store byte, use high 16 bits of data register.", "code": "MEM[ADDR].b8 = VDATA[23 : 16].b8", "notes": ""}, "buffer_store_d16_hi_b16": {"desc": "Untyped buffer store short, use high 16 bits of data register.\n16.16. MUBUF Instructions 545 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "MEM[ADDR].b16 = VDATA[31 : 16].b16", "notes": ""}, "buffer_load_d16_hi_format_x": {"desc": "Untyped buffer load 1 dword with format conversion, use high 16 bits of data register.", "code": "VDATA[31 : 16].b16 = 16'B(ConvertFromFormat(MEM[TADDR.X]));\n// Mem access size depends on format\n// VDATA[15:0].b16 is preserved.", "notes": ""}, "buffer_store_d16_hi_format_x": {"desc": "Untyped buffer store 1 dword with format conversion, use high 16 bits of data register.", "code": "MEM[TADDR.X] = ConvertToFormat(32'B(VDATA[31 : 16].b16));\n// Mem access size depends on format", "notes": ""}, "buffer_gl0_inv": {"desc": "Write back and invalidate the shader L0. Returns ACK to shader.", "code": "", "notes": ""}, "buffer_gl1_inv": {"desc": "Invalidate the GL1 cache only. Returns ACK to shader.", "code": "", "notes": ""}, "buffer_atomic_swap_b32": {"desc": "Swap values in data register and memory.", "code": "tmp = MEM[ADDR].b;\nMEM[ADDR].b = DATA.b;\nRETURN_DATA.b = tmp", "notes": ""}, "buffer_atomic_cmpswap_b32": {"desc": "Compare and swap with memory value.\n16.16. MUBUF Instructions 546 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].b;\nsrc = DATA[31 : 0].b;\ncmp = DATA[63 : 32].b;\nMEM[ADDR].b = tmp == cmp ? src : tmp;\nRETURN_DATA.b = tmp", "notes": ""}, "buffer_atomic_add_u32": {"desc": "Add data register to memory value.", "code": "tmp = MEM[ADDR].u;\nMEM[ADDR].u += DATA.u;\nRETURN_DATA.u = tmp", "notes": ""}, "buffer_atomic_sub_u32": {"desc": "Subtract data register from memory value.", "code": "tmp = MEM[ADDR].u;\nMEM[ADDR].u -= DATA.u;\nRETURN_DATA.u = tmp", "notes": ""}, "buffer_atomic_csub_u32": {"desc": "Subtract data register from memory value, clamp to zero.", "code": "declare new_value : 32'U;\nold_value = MEM[ADDR].u;\nif old_value < DATA.u then\nnew_value = 0U\nelse\nnew_value = old_value - DATA.u\nendif;\nMEM[ADDR].u = new_value;\nRETURN_DATA.u = old_value", "notes": ""}, "buffer_atomic_min_i32": {"desc": "Minimum of two signed integer values.\n16.16. MUBUF Instructions 547 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].i;\nsrc = DATA.i;\nMEM[ADDR].i = src < tmp ? src : tmp;\nRETURN_DATA.i = tmp", "notes": ""}, "buffer_atomic_min_u32": {"desc": "Minimum of two unsigned integer values.", "code": "tmp = MEM[ADDR].u;\nsrc = DATA.u;\nMEM[ADDR].u = src < tmp ? src : tmp;\nRETURN_DATA.u = tmp", "notes": ""}, "buffer_atomic_max_i32": {"desc": "Maximum of two signed integer values.", "code": "tmp = MEM[ADDR].i;\nsrc = DATA.i;\nMEM[ADDR].i = src > tmp ? src : tmp;\nRETURN_DATA.i = tmp", "notes": ""}, "buffer_atomic_max_u32": {"desc": "Maximum of two unsigned integer values.", "code": "tmp = MEM[ADDR].u;\nsrc = DATA.u;\nMEM[ADDR].u = src > tmp ? src : tmp;\nRETURN_DATA.u = tmp", "notes": ""}, "buffer_atomic_and_b32": {"desc": "Bitwise AND of register value and memory value.\n16.16. MUBUF Instructions 548 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].b;\nMEM[ADDR].b = (tmp & DATA.b);\nRETURN_DATA.b = tmp", "notes": ""}, "buffer_atomic_or_b32": {"desc": "Bitwise OR of register value and memory value.", "code": "tmp = MEM[ADDR].b;\nMEM[ADDR].b = (tmp | DATA.b);\nRETURN_DATA.b = tmp", "notes": ""}, "buffer_atomic_xor_b32": {"desc": "Bitwise XOR of register value and memory value.", "code": "tmp = MEM[ADDR].b;\nMEM[ADDR].b = (tmp ^ DATA.b);\nRETURN_DATA.b = tmp", "notes": ""}, "buffer_atomic_inc_u32": {"desc": "Increment memory value with wraparound to zero when incremented to register value.", "code": "tmp = MEM[ADDR].u;\nsrc = DATA.u;\nMEM[ADDR].u = tmp >= src ? 0U : tmp + 1U;\nRETURN_DATA.u = tmp", "notes": ""}, "buffer_atomic_dec_u32": {"desc": "Decrement memory value with wraparound to register value when decremented below zero.", "code": "tmp = MEM[ADDR].u;\nsrc = DATA.u;\nMEM[ADDR].u = ((tmp == 0U) || (tmp > src)) ? src : tmp - 1U;\nRETURN_DATA.u = tmp", "notes": ""}, "buffer_atomic_swap_b64": {"desc": "Swap 64-bit values in data register and memory.\n16.16. MUBUF Instructions 549 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = DATA.b64;\nRETURN_DATA.b64 = tmp", "notes": ""}, "buffer_atomic_cmpswap_b64": {"desc": "Compare and swap with 64-bit memory value.", "code": "tmp = MEM[ADDR].b64;\nsrc = DATA[63 : 0].b64;\ncmp = DATA[127 : 64].b64;\nMEM[ADDR].b64 = tmp == cmp ? src : tmp;\nRETURN_DATA.b64 = tmp", "notes": ""}, "buffer_atomic_add_u64": {"desc": "Add data register to 64-bit memory value.", "code": "tmp = MEM[ADDR].u64;\nMEM[ADDR].u64 += DATA.u64;\nRETURN_DATA.u64 = tmp", "notes": ""}, "buffer_atomic_sub_u64": {"desc": "Subtract data register from 64-bit memory value.", "code": "tmp = MEM[ADDR].u64;\nMEM[ADDR].u64 -= DATA.u64;\nRETURN_DATA.u64 = tmp", "notes": ""}, "buffer_atomic_min_i64": {"desc": "Minimum of two signed 64-bit integer values.\n16.16. MUBUF Instructions 550 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].i64;\nsrc = DATA.i64;\nMEM[ADDR].i64 = src < tmp ? src : tmp;\nRETURN_DATA.i64 = tmp", "notes": ""}, "buffer_atomic_min_u64": {"desc": "Minimum of two unsigned 64-bit integer values.", "code": "tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = src < tmp ? src : tmp;\nRETURN_DATA.u64 = tmp", "notes": ""}, "buffer_atomic_max_i64": {"desc": "Maximum of two signed 64-bit integer values.", "code": "tmp = MEM[ADDR].i64;\nsrc = DATA.i64;\nMEM[ADDR].i64 = src > tmp ? src : tmp;\nRETURN_DATA.i64 = tmp", "notes": ""}, "buffer_atomic_max_u64": {"desc": "Maximum of two unsigned 64-bit integer values.", "code": "tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = src > tmp ? src : tmp;\nRETURN_DATA.u64 = tmp", "notes": ""}, "buffer_atomic_and_b64": {"desc": "Bitwise AND of register value and 64-bit memory value.", "code": "tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp & DATA.b64);\nRETURN_DATA.b64 = tmp", "notes": ""}, "buffer_atomic_or_b64": {"desc": "Bitwise OR of register value and 64-bit memory value.\n16.16. MUBUF Instructions 551 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp | DATA.b64);\nRETURN_DATA.b64 = tmp", "notes": ""}, "buffer_atomic_xor_b64": {"desc": "Bitwise XOR of register value and 64-bit memory value.", "code": "tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp ^ DATA.b64);\nRETURN_DATA.b64 = tmp", "notes": ""}, "buffer_atomic_inc_u64": {"desc": "Increment 64-bit memory value with wraparound to zero when incremented to register value.", "code": "tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = tmp >= src ? 0ULL : tmp + 1ULL;\nRETURN_DATA.u64 = tmp", "notes": ""}, "buffer_atomic_dec_u64": {"desc": "Decrement 64-bit memory value with wraparound to register value when decremented below zero.", "code": "tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = ((tmp == 0ULL) || (tmp > src)) ? src : tmp - 1ULL;\nRETURN_DATA.u64 = tmp", "notes": ""}, "buffer_atomic_cmpswap_f32": {"desc": "Compare and swap with floating-point memory value.\n16.16. MUBUF Instructions 552 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].f;\nsrc = DATA[31 : 0].f;\ncmp = DATA[63 : 32].f;\nMEM[ADDR].f = tmp == cmp ? src : tmp;\nRETURN_DATA.f = tmp", "notes": "Floating-point compare handles NAN/INF/denorm."}, "buffer_atomic_min_f32": {"desc": "Minimum of two floating-point values.", "code": "tmp = MEM[ADDR].f;\nsrc = DATA.f;\nMEM[ADDR].f = src < tmp ? src : tmp;\nRETURN_DATA = tmp", "notes": "Floating-point compare handles NAN/INF/denorm."}, "buffer_atomic_max_f32": {"desc": "Maximum of two floating-point values.", "code": "tmp = MEM[ADDR].f;\nsrc = DATA.f;\nMEM[ADDR].f = src > tmp ? src : tmp;\nRETURN_DATA = tmp", "notes": "Floating-point compare handles NAN/INF/denorm."}, "buffer_atomic_add_f32": {"desc": "Add data register to floating-point memory value.\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].f;\nsrc = DATA.f;\nMEM[ADDR].f = src + tmp;\nRETURN_DATA.f = tmp", "notes": "Floating-point addition handles NAN/INF/denorm.\n16.16. MUBUF Instructions 553 of 600\nThe bitfield map of the MTBUF format is:"}, "tbuffer_load_format_x": {"desc": "Typed buffer load 1 component with format conversion.", "code": "VDATA[31 : 0].b = ConvertFromFormat(MEM[TADDR.X]);\n// Mem access size depends on format", "notes": ""}, "tbuffer_load_format_xy": {"desc": "Typed buffer load 2 components with format conversion.", "code": "VDATA[31 : 0].b = ConvertFromFormat(MEM[TADDR.X]);\n// Mem access size depends on format\nVDATA[63 : 32].b = ConvertFromFormat(MEM[TADDR.Y])", "notes": ""}, "tbuffer_load_format_xyz": {"desc": "Typed buffer load 3 components with format conversion.", "code": "VDATA[31 : 0].b = ConvertFromFormat(MEM[TADDR.X]);\n// Mem access size depends on format\nVDATA[63 : 32].b = ConvertFromFormat(MEM[TADDR.Y]);\nVDATA[95 : 64].b = ConvertFromFormat(MEM[TADDR.Z])", "notes": ""}, "tbuffer_load_format_xyzw": {"desc": "Typed buffer load 4 components with format conversion.\n16.17. MTBUF Instructions 554 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "VDATA[31 : 0].b = ConvertFromFormat(MEM[TADDR.X]);\n// Mem access size depends on format\nVDATA[63 : 32].b = ConvertFromFormat(MEM[TADDR.Y]);\nVDATA[95 : 64].b = ConvertFromFormat(MEM[TADDR.Z]);\nVDATA[127 : 96].b = ConvertFromFormat(MEM[TADDR.W])", "notes": ""}, "tbuffer_store_format_x": {"desc": "Typed buffer store 1 component with format conversion.", "code": "MEM[TADDR.X] = ConvertToFormat(VDATA[31 : 0].b);\n// Mem access size depends on format", "notes": ""}, "tbuffer_store_format_xy": {"desc": "Typed buffer store 2 components with format conversion.", "code": "MEM[TADDR.X] = ConvertToFormat(VDATA[31 : 0].b);\n// Mem access size depends on format\nMEM[TADDR.Y] = ConvertToFormat(VDATA[63 : 32].b)", "notes": ""}, "tbuffer_store_format_xyz": {"desc": "Typed buffer store 3 components with format conversion.", "code": "MEM[TADDR.X] = ConvertToFormat(VDATA[31 : 0].b);\n// Mem access size depends on format\nMEM[TADDR.Y] = ConvertToFormat(VDATA[63 : 32].b);\nMEM[TADDR.Z] = ConvertToFormat(VDATA[95 : 64].b)", "notes": ""}, "tbuffer_store_format_xyzw": {"desc": "Typed buffer store 4 components with format conversion.", "code": "MEM[TADDR.X] = ConvertToFormat(VDATA[31 : 0].b);\n// Mem access size depends on format\nMEM[TADDR.Y] = ConvertToFormat(VDATA[63 : 32].b);\nMEM[TADDR.Z] = ConvertToFormat(VDATA[95 : 64].b);\nMEM[TADDR.W] = ConvertToFormat(VDATA[127 : 96].b)", "notes": ""}, "tbuffer_load_d16_format_x": {"desc": "16.17. MTBUF Instructions 555 of 600\n\"RDNA3\" Instruction Set Architecture\nTyped buffer load 1 component with format conversion, packed 16-bit components in data register.", "code": "VDATA[15 : 0].b16 = 16'B(ConvertFromFormat(MEM[TADDR.X]));\n// Mem access size depends on format\n// VDATA[31:16].b16 is preserved.", "notes": ""}, "tbuffer_load_d16_format_xy": {"desc": "Typed buffer load 2 components with format conversion, packed 16-bit components in data register.", "code": "VDATA[15 : 0].b16 = 16'B(ConvertFromFormat(MEM[TADDR.X]));\n// Mem access size depends on format\nVDATA[31 : 16].b16 = 16'B(ConvertFromFormat(MEM[TADDR.Y]))", "notes": ""}, "tbuffer_load_d16_format_xyz": {"desc": "Typed buffer load 3 components with format conversion, packed 16-bit components in data register.", "code": "VDATA[15 : 0].b16 = 16'B(ConvertFromFormat(MEM[TADDR.X]));\n// Mem access size depends on format\nVDATA[31 : 16].b16 = 16'B(ConvertFromFormat(MEM[TADDR.Y]));\nVDATA[47 : 32].b16 = 16'B(ConvertFromFormat(MEM[TADDR.Z]));\n// VDATA[63:48].b16 is preserved.", "notes": ""}, "tbuffer_load_d16_format_xyzw": {"desc": "Typed buffer load 4 components with format conversion, packed 16-bit components in data register.", "code": "VDATA[15 : 0].b16 = 16'B(ConvertFromFormat(MEM[TADDR.X]));\n// Mem access size depends on format\nVDATA[31 : 16].b16 = 16'B(ConvertFromFormat(MEM[TADDR.Y]));\nVDATA[47 : 32].b16 = 16'B(ConvertFromFormat(MEM[TADDR.Z]));\nVDATA[63 : 48].b16 = 16'B(ConvertFromFormat(MEM[TADDR.W]))", "notes": ""}, "tbuffer_store_d16_format_x": {"desc": "Typed buffer store 1 component with format conversion, packed 16-bit components in data register.\n16.17. MTBUF Instructions 556 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "MEM[TADDR.X] = ConvertToFormat(32'B(VDATA[15 : 0].b16));\n// Mem access size depends on format", "notes": ""}, "tbuffer_store_d16_format_xy": {"desc": "Typed buffer store 2 components with format conversion, packed 16-bit components in data register.", "code": "MEM[TADDR.X] = ConvertToFormat(32'B(VDATA[15 : 0].b16));\n// Mem access size depends on format\nMEM[TADDR.Y] = ConvertToFormat(32'B(VDATA[31 : 16].b16))", "notes": ""}, "tbuffer_store_d16_format_xyz": {"desc": "Typed buffer store 3 components with format conversion, packed 16-bit components in data register.", "code": "MEM[TADDR.X] = ConvertToFormat(32'B(VDATA[15 : 0].b16));\n// Mem access size depends on format\nMEM[TADDR.Y] = ConvertToFormat(32'B(VDATA[31 : 16].b16));\nMEM[TADDR.Z] = ConvertToFormat(32'B(VDATA[47 : 32].b16))", "notes": ""}, "tbuffer_store_d16_format_xyzw": {"desc": "Typed buffer store 4 components with format conversion, packed 16-bit components in data register.\n16.17. MTBUF Instructions 557 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "MEM[TADDR.X] = ConvertToFormat(32'B(VDATA[15 : 0].b16));\n// Mem access size depends on format\nMEM[TADDR.Y] = ConvertToFormat(32'B(VDATA[31 : 16].b16));\nMEM[TADDR.Z] = ConvertToFormat(32'B(VDATA[47 : 32].b16));\nMEM[TADDR.W] = ConvertToFormat(32'B(VDATA[63 : 48].b16))", "notes": "The bitfield map of the MIMG format is:"}, "image_load": {"desc": "Load element from largest miplevel in resource view, with format conversion specified in the resource\nconstant. No sampler.", "code": "", "notes": ""}, "image_load_mip": {"desc": "Load element from user-specified miplevel in resource view, with format conversion specified in the resource\nconstant. No sampler.", "code": "", "notes": ""}, "image_load_pck": {"desc": "Load element from largest miplevel in resource view, without format conversion. 8- and 16-bit elements are\nnot sign-extended. No sampler.", "code": "", "notes": ""}, "image_load_pck_sgn": {"desc": "Load element from largest miplevel in resource view, without format conversion. 8- and 16-bit elements are\nsign-extended. No sampler.", "code": "", "notes": ""}, "image_load_mip_pck": {"desc": "Load element from user-supplied miplevel in resource view, without format conversion. 8- and 16-bit elements\nare not sign-extended. No sampler.", "code": "", "notes": ""}, "image_load_mip_pck_sgn": {"desc": "Load element from user-supplied miplevel in resource view, without format conversion. 8- and 16-bit elements\nare sign-extended. No sampler.\n16.18. MIMG Instructions 558 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "", "notes": ""}, "image_store": {"desc": "Store element to largest miplevel in resource view, with format conversion specified in resource constant. No\nsampler.", "code": "", "notes": ""}, "image_store_mip": {"desc": "Store element to user-specified miplevel in resource view, with format conversion specified in resource\nconstant. No sampler.", "code": "", "notes": ""}, "image_store_pck": {"desc": "Store element to largest miplevel in resource view, without format conversion. No sampler.", "code": "", "notes": ""}, "image_store_mip_pck": {"desc": "Store element to user-specified miplevel in resource view, without format conversion. No sampler.", "code": "", "notes": ""}, "image_atomic_swap": {"desc": "Swap values in data register and memory.", "code": "tmp = MEM[ADDR].b;\nMEM[ADDR].b = DATA.b;\nRETURN_DATA.b = tmp", "notes": ""}, "image_atomic_cmpswap": {"desc": "Compare and swap with memory value.", "code": "tmp = MEM[ADDR].b;\nsrc = DATA[31 : 0].b;\ncmp = DATA[63 : 32].b;\nMEM[ADDR].b = tmp == cmp ? src : tmp;\nRETURN_DATA.b = tmp", "notes": ""}, "image_atomic_add": {"desc": "16.18. MIMG Instructions 559 of 600\n\"RDNA3\" Instruction Set Architecture\nAdd data register to memory value.", "code": "tmp = MEM[ADDR].u;\nMEM[ADDR].u += DATA.u;\nRETURN_DATA.u = tmp", "notes": ""}, "image_atomic_sub": {"desc": "Subtract data register from memory value.", "code": "tmp = MEM[ADDR].u;\nMEM[ADDR].u -= DATA.u;\nRETURN_DATA.u = tmp", "notes": ""}, "image_atomic_smin": {"desc": "Minimum of two signed integer values.", "code": "tmp = MEM[ADDR].i;\nsrc = DATA.i;\nMEM[ADDR].i = src < tmp ? src : tmp;\nRETURN_DATA.i = tmp", "notes": ""}, "image_atomic_umin": {"desc": "Minimum of two unsigned integer values.", "code": "tmp = MEM[ADDR].u;\nsrc = DATA.u;\nMEM[ADDR].u = src < tmp ? src : tmp;\nRETURN_DATA.u = tmp", "notes": ""}, "image_atomic_smax": {"desc": "Maximum of two signed integer values.\n16.18. MIMG Instructions 560 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].i;\nsrc = DATA.i;\nMEM[ADDR].i = src > tmp ? src : tmp;\nRETURN_DATA.i = tmp", "notes": ""}, "image_atomic_umax": {"desc": "Maximum of two unsigned integer values.", "code": "tmp = MEM[ADDR].u;\nsrc = DATA.u;\nMEM[ADDR].u = src > tmp ? src : tmp;\nRETURN_DATA.u = tmp", "notes": ""}, "image_atomic_and": {"desc": "Bitwise AND of register value and memory value.", "code": "tmp = MEM[ADDR].b;\nMEM[ADDR].b = (tmp & DATA.b);\nRETURN_DATA.b = tmp", "notes": ""}, "image_atomic_or": {"desc": "Bitwise OR of register value and memory value.", "code": "tmp = MEM[ADDR].b;\nMEM[ADDR].b = (tmp | DATA.b);\nRETURN_DATA.b = tmp", "notes": ""}, "image_atomic_xor": {"desc": "Bitwise XOR of register value and memory value.", "code": "tmp = MEM[ADDR].b;\nMEM[ADDR].b = (tmp ^ DATA.b);\nRETURN_DATA.b = tmp", "notes": ""}, "image_atomic_inc": {"desc": "16.18. MIMG Instructions 561 of 600\n\"RDNA3\" Instruction Set Architecture\nIncrement memory value with wraparound to zero when incremented to register value.", "code": "tmp = MEM[ADDR].u;\nsrc = DATA.u;\nMEM[ADDR].u = tmp >= src ? 0U : tmp + 1U;\nRETURN_DATA.u = tmp", "notes": ""}, "image_atomic_dec": {"desc": "Decrement memory value with wraparound to register value when decremented below zero.", "code": "tmp = MEM[ADDR].u;\nsrc = DATA.u;\nMEM[ADDR].u = ((tmp == 0U) || (tmp > src)) ? src : tmp - 1U;\nRETURN_DATA.u = tmp", "notes": ""}, "image_get_resinfo": {"desc": "Return resource info for a given mip level specified in the address vgpr. No sampler. Returns 4 integer values\ninto VGPRs 3-0: {num_mip_levels, depth, height, width}.", "code": "", "notes": ""}, "image_msaa_load": {"desc": "Load up to 4 samples of 1 component from an MSAA resource with a user-specified fragment ID. No sampler.", "code": "", "notes": ""}, "image_bvh_intersect_ray": {"desc": "Intersection test on bound volume hierarchy nodes for ray tracing acceleration. 32-bit node pointer. No\nsampler.\n\"RDNA3\" Instruction Set Architecture\n11 address VGPRs contain the ray data and BVH node pointer for the intersection test. The data is laid out as\nfollows (dependent on NSA mode):\n\u2022 NSA=0 NSA=1 Value\nVADDR[0] VADDR[0] = node_pointer (uint32)\nVADDR[1] VADDRA[0] = ray_extent (float32)\nVADDR[2] VADDRB[0] = ray_origin.x (float32)\nVADDR[3] VADDRB[1] = ray_origin.y (float32)\nVADDR[4] VADDRB[2] = ray_origin.z (float32)\nVADDR[5] VADDRC[0] = ray_dir.x (float32)\nVADDR[6] VADDRC[1] = ray_dir.y (float32)\nVADDR[7] VADDRC[2] = ray_dir.z (float32)\nVADDR[8] VADDRD[0] = ray_inv_dir.x (float32)\nVADDR[9] VADDRD[1] = ray_inv_dir.y (float32)\nVADDR[10] VADDRD[2] = ray_inv_dir.z (float32)\n\"RDNA3\" Instruction Set Architecture\nany other undefined behavior, if the above fields do not match their specified values for these instructions.\nThe HW also has some additional restrictions on the BVH instructions when they are issued:\n\u2022 The HW ignores the return order settings of the BVH ops and schedules them in the in order read return\nqueue when fetching data from the texture pipe.", "code": "", "notes": "The destination VGPRs contain the results of intersection testing. The values returned here are different\ndepending on the type of BVH node that was fetched.\nFor box nodes the results contain the 4 pointers of the children boxes in intersection time sorted order.\nFor triangle BVH nodes the results contain the intersection time and triangle ID of the triangle tested.\nThe address GPR packing varies based on addressing mode (A16) and NSA mode.\nADDR (A16 = 0):\n16.18. MIMG Instructions 562 of 600\nFor performance and power optimization, the instruction can be encoded to use 16 bit floats for ray_dir and\nray_inv_dir by setting A16 to 1. When the instruction is encoded with 16 bit addresses only 8 address VGPRs are\nused as follows (dependent on NSA mode):\n\u2022 NSA=0 NSA=1 Value\nVADDR[0] VADDR[0] = node_pointer (uint32)\nVADDR[1] VADDRA[0] = ray_extent (float32)\nVADDR[2] VADDRB[0] = ray_origin.x (float32)\nVADDR[3] VADDRB[1] = ray_origin.y (float32)\nVADDR[4] VADDRB[2] = ray_origin.z (float32)\nVADDR[5] VADDRC[0] = {ray_inv_dir.x, ray_dir.x} (2x float16)\nVADDR[6] VADDRC[1] = {ray_inv_dir.y, ray_dir.y} (2x float16)\nVADDR[7] VADDRC[2] = {ray_inv_dir.z, ray_dir.z} (2x float16)\nRSRC:\nThe resource is the texture descriptor for the operation. The instruction must be encoded with r128=1.\nRESTRICTIONS:\nThe image_bvh_intersect_ray and image_bvh64_intersect_ray opcode do not support all of the features of a\nstandard MIMG instruction. This puts some restrictions on how the instruction is encoded:\n\u2022 DMASK must be set to 0xf (instruction returns all four DWORDs)\n\u2022 D16 must be set to 0 (16 bit return data is not supported)\n\u2022 R128 must be set to 1 (256 bit T#s are not supported)\n\u2022 UNRM must be set to 1 (only unnormalized coordinates are supported)\n\u2022 DIM must be set to 0 (BVH textures are 1D)\n\u2022 LWE must be set to 0 (LOD warn is not supported)\n\u2022 TFE must be set to 0 (no support for writing out the extra DWORD for the PRT hit status)\nThese restrictions must be respected by the SW/compiler, and are not enforced by HW. HW is allowed to\nassume that these values are encoded according to the above restrictions, and ignore improper values, or do\n16.18. MIMG Instructions 563 of 600"}, "image_bvh64_intersect_ray": {"desc": "Intersection test on bound volume hierarchy nodes for ray tracing acceleration. 64-bit node pointer. No\nsampler.\nThis instruction allows support for very large BVHs (larger than 32 GBs) that may occur in workstation\nworkloads. See IMAGE_BVH_INTERSECT_RAY for basic information including restrictions. Only differences\nare described here.\n\"RDNA3\" Instruction Set Architecture", "code": "", "notes": "12 address VGPRs contain the ray data and BVH node pointer for the intersection test. The data is laid out as\nfollows (dependent on NSA mode):\n\u2022 NSA=0 NSA=1 Value\nVADDR[0] VADDR[0] = node_pointer[31:0] (uint32)\nVADDR[1] VADDR[1] = node_pointer[63:32] (uint32)\nVADDR[2] VADDRA[0] = ray_extent (float32)\nVADDR[3] VADDRB[0] = ray_origin.x (float32)\nVADDR[4] VADDRB[1] = ray_origin.y (float32)\nVADDR[5] VADDRB[2] = ray_origin.z (float32)\nVADDR[6] VADDRC[0] = ray_dir.x (float32)\nVADDR[7] VADDRC[1] = ray_dir.y (float32)\nVADDR[8] VADDRC[2] = ray_dir.z (float32)\nVADDR[9] VADDRD[0] = ray_inv_dir.x (float32)\nVADDR[10] VADDRD[1] = ray_inv_dir.y (float32)\nVADDR[11] VADDRD[2] = ray_inv_dir.z (float32)\nADDR (A16 = 1):\nWhen the instruction is encoded with 16 bit addresses only 9 address VGPRs are used as follows (dependent on\nNSA mode):\n\u2022 NSA=0 NSA=1 Value\nVADDR[0] VADDR[0] = node_pointer[31:0] (uint32)\nVADDR[1] VADDR[1] = node_pointer[63:32] (uint32)\nVADDR[2] VADDRA[0] = ray_extent (float32)\nVADDR[3] VADDRB[0] = ray_origin.x (float32)\nVADDR[4] VADDRB[1] = ray_origin.y (float32)\nVADDR[5] VADDRB[2] = ray_origin.z (float32)\nVADDR[6] VADDRC[0] = {ray_inv_dir.x, ray_dir.x} (2x float16)\nVADDR[7] VADDRC[1] = {ray_inv_dir.y, ray_dir.y} (2x float16)\nVADDR[8] VADDRC[2] = {ray_inv_dir.z, ray_dir.z} (2x float16)\n16.18. MIMG Instructions 564 of 600"}, "image_sample": {"desc": "Sample texture map.", "code": "", "notes": ""}, "image_sample_d": {"desc": "Sample texture map, with user derivatives.", "code": "", "notes": ""}, "image_sample_l": {"desc": "Sample texture map, with user LOD.", "code": "", "notes": ""}, "image_sample_b": {"desc": "Sample texture map, with lod bias.", "code": "", "notes": ""}, "image_sample_lz": {"desc": "Sample texture map, from level 0.", "code": "", "notes": ""}, "image_sample_c": {"desc": "Sample texture map, with PCF.", "code": "", "notes": ""}, "image_sample_c_d": {"desc": "SAMPLE_C, with user derivatives.", "code": "", "notes": ""}, "image_sample_c_l": {"desc": "SAMPLE_C, with user LOD.", "code": "", "notes": ""}, "image_sample_c_b": {"desc": "SAMPLE_C, with lod bias.\n16.18. MIMG Instructions 565 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "", "notes": ""}, "image_sample_c_lz": {"desc": "SAMPLE_C, from level 0.", "code": "", "notes": ""}, "image_sample_o": {"desc": "Sample texture map, with user offsets.", "code": "", "notes": ""}, "image_sample_d_o": {"desc": "SAMPLE_O, with user derivatives.", "code": "", "notes": ""}, "image_sample_l_o": {"desc": "SAMPLE_O, with user LOD.", "code": "", "notes": ""}, "image_sample_b_o": {"desc": "SAMPLE_O, with lod bias.", "code": "", "notes": ""}, "image_sample_lz_o": {"desc": "SAMPLE_O, from level 0.", "code": "", "notes": ""}, "image_sample_c_o": {"desc": "SAMPLE_C with user specified offsets.", "code": "", "notes": ""}, "image_sample_c_d_o": {"desc": "SAMPLE_C_O, with user derivatives.", "code": "", "notes": ""}, "image_sample_c_l_o": {"desc": "SAMPLE_C_O, with user LOD.\n16.18. MIMG Instructions 566 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "", "notes": ""}, "image_sample_c_b_o": {"desc": "SAMPLE_C_O, with lod bias.", "code": "", "notes": ""}, "image_sample_c_lz_o": {"desc": "SAMPLE_C_O, from level 0.", "code": "", "notes": ""}, "image_gather4": {"desc": "Gather 4 single component elements (2x2).", "code": "", "notes": ""}, "image_gather4_l": {"desc": "Gather 4 single component elements (2x2) with user LOD.", "code": "", "notes": ""}, "image_gather4_b": {"desc": "Gather 4 single component elements (2x2) with user bias.", "code": "", "notes": ""}, "image_gather4_lz": {"desc": "Gather 4 single component elements (2x2) at level 0.", "code": "", "notes": ""}, "image_gather4_c": {"desc": "Gather 4 single component elements (2x2) with PCF.", "code": "", "notes": ""}, "image_gather4_c_lz": {"desc": "Gather 4 single component elements (2x2) at level 0, with PCF.", "code": "", "notes": ""}, "image_gather4_o": {"desc": "GATHER4, with user offsets.\n16.18. MIMG Instructions 567 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "", "notes": ""}, "image_gather4_lz_o": {"desc": "GATHER4_LZ, with user offsets.", "code": "", "notes": ""}, "image_gather4_c_lz_o": {"desc": "GATHER4_C_LZ, with user offsets.", "code": "", "notes": ""}, "image_get_lod": {"desc": "Return calculated LOD as two 32-bit floating point values.", "code": "VDATA[0] = clampedLOD;\nVDATA[1] = rawLOD.", "notes": ""}, "image_sample_d_g16": {"desc": "SAMPLE_D with 16-bit floating point derivatives (gradients).", "code": "", "notes": ""}, "image_sample_c_d_g16": {"desc": "SAMPLE_C_D with 16-bit floating point derivatives (gradients).", "code": "", "notes": ""}, "image_sample_d_o_g16": {"desc": "SAMPLE_D_O with 16-bit floating point derivatives (gradients).", "code": "", "notes": ""}, "image_sample_c_d_o_g16": {"desc": "SAMPLE_C_D_O with 16-bit floating point derivatives (gradients).", "code": "", "notes": ""}, "image_sample_cl": {"desc": "Sample texture map, with LOD clamp specified in shader.\n16.18. MIMG Instructions 568 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "", "notes": ""}, "image_sample_d_cl": {"desc": "Sample texture map, with LOD clamp specified in shader, with user derivatives.", "code": "", "notes": ""}, "image_sample_b_cl": {"desc": "Sample texture map, with LOD clamp specified in shader, with lod bias.", "code": "", "notes": ""}, "image_sample_c_cl": {"desc": "SAMPLE_C, with LOD clamp specified in shader.", "code": "", "notes": ""}, "image_sample_c_d_cl": {"desc": "SAMPLE_C, with LOD clamp specified in shader, with user derivatives.", "code": "", "notes": ""}, "image_sample_c_b_cl": {"desc": "SAMPLE_C, with LOD clamp specified in shader, with lod bias.", "code": "", "notes": ""}, "image_sample_cl_o": {"desc": "SAMPLE_O with LOD clamp specified in shader.", "code": "", "notes": ""}, "image_sample_d_cl_o": {"desc": "SAMPLE_O, with LOD clamp specified in shader, with user derivatives.", "code": "", "notes": ""}, "image_sample_b_cl_o": {"desc": "SAMPLE_O, with LOD clamp specified in shader, with lod bias.", "code": "", "notes": ""}, "image_sample_c_cl_o": {"desc": "SAMPLE_C_O, with LOD clamp specified in shader.\n16.18. MIMG Instructions 569 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "", "notes": ""}, "image_sample_c_d_cl_o": {"desc": "SAMPLE_C_O, with LOD clamp specified in shader, with user derivatives.", "code": "", "notes": ""}, "image_sample_c_b_cl_o": {"desc": "SAMPLE_C_O, with LOD clamp specified in shader, with lod bias.", "code": "", "notes": ""}, "image_sample_c_d_cl_g16": {"desc": "SAMPLE_C_D_CL with 16-bit floating point derivatives (gradients).", "code": "", "notes": ""}, "image_sample_d_cl_o_g16": {"desc": "SAMPLE_D_CL_O with 16-bit floating point derivatives (gradients).", "code": "", "notes": ""}, "image_sample_c_d_cl_o_g16": {"desc": "SAMPLE_C_D_CL_O with 16-bit floating point derivatives (gradients).", "code": "", "notes": ""}, "image_sample_d_cl_g16": {"desc": "SAMPLE_D_CL with 16-bit floating point derivatives (gradients).", "code": "", "notes": ""}, "image_gather4_cl": {"desc": "Gather 4 single component elements (2x2) with user LOD clamp.", "code": "", "notes": ""}, "image_gather4_b_cl": {"desc": "Gather 4 single component elements (2x2) with user bias and clamp.", "code": "", "notes": ""}, "image_gather4_c_cl": {"desc": "Gather 4 single component elements (2x2) with user LOD clamp and PCF.\n16.18. MIMG Instructions 570 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "", "notes": ""}, "image_gather4_c_l": {"desc": "Gather 4 single component elements (2x2) with user LOD and PCF.", "code": "", "notes": ""}, "image_gather4_c_b": {"desc": "Gather 4 single component elements (2x2) with user bias and PCF.", "code": "", "notes": ""}, "image_gather4_c_b_cl": {"desc": "Gather 4 single component elements (2x2) with user bias, clamp and PCF.", "code": "", "notes": ""}, "image_gather4h": {"desc": "Fetch 1 component per texel from 4x1 texels. DMASK selects which component to read (R,G,B,A) and must\nhave only one bit set to 1.\n16.18. MIMG Instructions 571 of 600\n\"RDNA3\" Instruction Set Architecture\n\"RDNA3\" Instruction Set Architecture", "code": "", "notes": "Transfer vertex position, vertex parameter, pixel color, or pixel depth information to the output buffer. Every\npixel shader must do at least one export to a color, depth or NULL target with the VM bit set to 1. This\ncommunicates the pixel-valid mask to the color and depth buffers. Every pixel does only one of the above\nexport types with the DONE bit set to 1. Vertex shaders must do one or more position exports, and at least one\nparameter export. The final position export must have the DONE bit set to 1.\n16.19. EXPORT Instructions 572 of 600\nThe bitfield map of the FLAT format is:\n16.20.1. Flat Instructions\nFlat instructions look at the per work-item address and determine for each work-item if the target memory\naddress is in global, private or scratch memory."}, "flat_load_u8": {"desc": "Untyped buffer load unsigned byte, zero extend in data register.", "code": "VDATA.u = 32'U({ 24'0, MEM[ADDR].u8 })", "notes": ""}, "flat_load_i8": {"desc": "Untyped buffer load signed byte, sign extend in data register.", "code": "VDATA.i = 32'I(signext(MEM[ADDR].i8))", "notes": ""}, "flat_load_u16": {"desc": "Untyped buffer load unsigned short, zero extend in data register.", "code": "VDATA.u = 32'U({ 16'0, MEM[ADDR].u16 })", "notes": ""}, "flat_load_i16": {"desc": "Untyped buffer load signed short, sign extend in data register.\n16.20. FLAT, Scratch and Global Instructions 573 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "VDATA.i = 32'I(signext(MEM[ADDR].i16))", "notes": ""}, "flat_load_b32": {"desc": "Untyped buffer load dword.", "code": "VDATA.b = MEM[ADDR].b", "notes": ""}, "flat_load_b64": {"desc": "Untyped buffer load 2 dwords.", "code": "VDATA[31 : 0] = MEM[ADDR + 0U].b;\nVDATA[63 : 32] = MEM[ADDR + 4U].b", "notes": ""}, "flat_load_b96": {"desc": "Untyped buffer load 3 dwords.", "code": "VDATA[31 : 0] = MEM[ADDR + 0U].b;\nVDATA[63 : 32] = MEM[ADDR + 4U].b;\nVDATA[95 : 64] = MEM[ADDR + 8U].b", "notes": ""}, "flat_load_b128": {"desc": "Untyped buffer load 4 dwords.", "code": "VDATA[31 : 0] = MEM[ADDR + 0U].b;\nVDATA[63 : 32] = MEM[ADDR + 4U].b;\nVDATA[95 : 64] = MEM[ADDR + 8U].b;\nVDATA[127 : 96] = MEM[ADDR + 12U].b", "notes": ""}, "flat_store_b8": {"desc": "Untyped buffer store byte.\n16.20. FLAT, Scratch and Global Instructions 574 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "MEM[ADDR].b8 = VDATA[7 : 0]", "notes": ""}, "flat_store_b16": {"desc": "Untyped buffer store short.", "code": "MEM[ADDR].b16 = VDATA[15 : 0]", "notes": ""}, "flat_store_b32": {"desc": "Untyped buffer store dword.", "code": "MEM[ADDR].b = VDATA[31 : 0]", "notes": ""}, "flat_store_b64": {"desc": "Untyped buffer store 2 dwords.", "code": "MEM[ADDR + 0U].b = VDATA[31 : 0];\nMEM[ADDR + 4U].b = VDATA[63 : 32]", "notes": ""}, "flat_store_b96": {"desc": "Untyped buffer store 3 dwords.", "code": "MEM[ADDR + 0U].b = VDATA[31 : 0];\nMEM[ADDR + 4U].b = VDATA[63 : 32];\nMEM[ADDR + 8U].b = VDATA[95 : 64]", "notes": ""}, "flat_store_b128": {"desc": "Untyped buffer store 4 dwords.\n16.20. FLAT, Scratch and Global Instructions 575 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "MEM[ADDR + 0U].b = VDATA[31 : 0];\nMEM[ADDR + 4U].b = VDATA[63 : 32];\nMEM[ADDR + 8U].b = VDATA[95 : 64];\nMEM[ADDR + 12U].b = VDATA[127 : 96]", "notes": ""}, "flat_load_d16_u8": {"desc": "Untyped buffer load unsigned byte, use low 16 bits of data register.", "code": "VDATA[15 : 0].u16 = 16'U({ 8'0, MEM[ADDR].u8 });\n// VDATA[31:16] is preserved.", "notes": ""}, "flat_load_d16_i8": {"desc": "Untyped buffer load signed byte, use low 16 bits of data register.", "code": "VDATA[15 : 0].i16 = 16'I(signext(MEM[ADDR].i8));\n// VDATA[31:16] is preserved.", "notes": ""}, "flat_load_d16_b16": {"desc": "Untyped buffer load short, use low 16 bits of data register.", "code": "VDATA[15 : 0].b16 = MEM[ADDR].b16;\n// VDATA[31:16] is preserved.", "notes": ""}, "flat_load_d16_hi_u8": {"desc": "Untyped buffer load unsigned byte, use high 16 bits of data register.", "code": "VDATA[31 : 16].u16 = 16'U({ 8'0, MEM[ADDR].u8 });\n// VDATA[15:0] is preserved.", "notes": ""}, "flat_load_d16_hi_i8": {"desc": "Untyped buffer load signed byte, use high 16 bits of data register.", "code": "VDATA[31 : 16].i16 = 16'I(signext(MEM[ADDR].i8));\n// VDATA[15:0] is preserved.", "notes": ""}, "flat_load_d16_hi_b16": {"desc": "16.20. FLAT, Scratch and Global Instructions 576 of 600\n\"RDNA3\" Instruction Set Architecture\nUntyped buffer load short, use high 16 bits of data register.", "code": "VDATA[31 : 16].b16 = MEM[ADDR].b16;\n// VDATA[15:0] is preserved.", "notes": ""}, "flat_store_d16_hi_b8": {"desc": "Untyped buffer store byte, use high 16 bits of data register.", "code": "MEM[ADDR].b8 = VDATA[23 : 16].b8", "notes": ""}, "flat_store_d16_hi_b16": {"desc": "Untyped buffer store short, use high 16 bits of data register.", "code": "MEM[ADDR].b16 = VDATA[31 : 16].b16", "notes": ""}, "flat_atomic_swap_b32": {"desc": "Swap values in data register and memory.", "code": "tmp = MEM[ADDR].b;\nMEM[ADDR].b = DATA.b;\nRETURN_DATA.b = tmp", "notes": ""}, "flat_atomic_cmpswap_b32": {"desc": "Compare and swap with memory value.", "code": "tmp = MEM[ADDR].b;\nsrc = DATA[31 : 0].b;\ncmp = DATA[63 : 32].b;\nMEM[ADDR].b = tmp == cmp ? src : tmp;\nRETURN_DATA.b = tmp", "notes": ""}, "flat_atomic_add_u32": {"desc": "16.20. FLAT, Scratch and Global Instructions 577 of 600\n\"RDNA3\" Instruction Set Architecture\nAdd data register to memory value.", "code": "tmp = MEM[ADDR].u;\nMEM[ADDR].u += DATA.u;\nRETURN_DATA.u = tmp", "notes": ""}, "flat_atomic_sub_u32": {"desc": "Subtract data register from memory value.", "code": "tmp = MEM[ADDR].u;\nMEM[ADDR].u -= DATA.u;\nRETURN_DATA.u = tmp", "notes": ""}, "flat_atomic_min_i32": {"desc": "Minimum of two signed integer values.", "code": "tmp = MEM[ADDR].i;\nsrc = DATA.i;\nMEM[ADDR].i = src < tmp ? src : tmp;\nRETURN_DATA.i = tmp", "notes": ""}, "flat_atomic_min_u32": {"desc": "Minimum of two unsigned integer values.", "code": "tmp = MEM[ADDR].u;\nsrc = DATA.u;\nMEM[ADDR].u = src < tmp ? src : tmp;\nRETURN_DATA.u = tmp", "notes": ""}, "flat_atomic_max_i32": {"desc": "Maximum of two signed integer values.\n16.20. FLAT, Scratch and Global Instructions 578 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].i;\nsrc = DATA.i;\nMEM[ADDR].i = src > tmp ? src : tmp;\nRETURN_DATA.i = tmp", "notes": ""}, "flat_atomic_max_u32": {"desc": "Maximum of two unsigned integer values.", "code": "tmp = MEM[ADDR].u;\nsrc = DATA.u;\nMEM[ADDR].u = src > tmp ? src : tmp;\nRETURN_DATA.u = tmp", "notes": ""}, "flat_atomic_and_b32": {"desc": "Bitwise AND of register value and memory value.", "code": "tmp = MEM[ADDR].b;\nMEM[ADDR].b = (tmp & DATA.b);\nRETURN_DATA.b = tmp", "notes": ""}, "flat_atomic_or_b32": {"desc": "Bitwise OR of register value and memory value.", "code": "tmp = MEM[ADDR].b;\nMEM[ADDR].b = (tmp | DATA.b);\nRETURN_DATA.b = tmp", "notes": ""}, "flat_atomic_xor_b32": {"desc": "Bitwise XOR of register value and memory value.", "code": "tmp = MEM[ADDR].b;\nMEM[ADDR].b = (tmp ^ DATA.b);\nRETURN_DATA.b = tmp", "notes": ""}, "flat_atomic_inc_u32": {"desc": "16.20. FLAT, Scratch and Global Instructions 579 of 600\n\"RDNA3\" Instruction Set Architecture\nIncrement memory value with wraparound to zero when incremented to register value.", "code": "tmp = MEM[ADDR].u;\nsrc = DATA.u;\nMEM[ADDR].u = tmp >= src ? 0U : tmp + 1U;\nRETURN_DATA.u = tmp", "notes": ""}, "flat_atomic_dec_u32": {"desc": "Decrement memory value with wraparound to register value when decremented below zero.", "code": "tmp = MEM[ADDR].u;\nsrc = DATA.u;\nMEM[ADDR].u = ((tmp == 0U) || (tmp > src)) ? src : tmp - 1U;\nRETURN_DATA.u = tmp", "notes": ""}, "flat_atomic_swap_b64": {"desc": "Swap 64-bit values in data register and memory.", "code": "tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = DATA.b64;\nRETURN_DATA.b64 = tmp", "notes": ""}, "flat_atomic_cmpswap_b64": {"desc": "Compare and swap with 64-bit memory value.\nNOTE: RETURN_DATA[2:3] is not modified.", "code": "tmp = MEM[ADDR].b64;\nsrc = DATA[63 : 0].b64;\ncmp = DATA[127 : 64].b64;\nMEM[ADDR].b64 = tmp == cmp ? src : tmp;\nRETURN_DATA.b64 = tmp", "notes": ""}, "flat_atomic_add_u64": {"desc": "Add data register to 64-bit memory value.\n16.20. FLAT, Scratch and Global Instructions 580 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].u64;\nMEM[ADDR].u64 += DATA.u64;\nRETURN_DATA.u64 = tmp", "notes": ""}, "flat_atomic_sub_u64": {"desc": "Subtract data register from 64-bit memory value.", "code": "tmp = MEM[ADDR].u64;\nMEM[ADDR].u64 -= DATA.u64;\nRETURN_DATA.u64 = tmp", "notes": ""}, "flat_atomic_min_i64": {"desc": "Minimum of two signed 64-bit integer values.", "code": "tmp = MEM[ADDR].i64;\nsrc = DATA.i64;\nMEM[ADDR].i64 = src < tmp ? src : tmp;\nRETURN_DATA.i64 = tmp", "notes": ""}, "flat_atomic_min_u64": {"desc": "Minimum of two unsigned 64-bit integer values.", "code": "tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = src < tmp ? src : tmp;\nRETURN_DATA.u64 = tmp", "notes": ""}, "flat_atomic_max_i64": {"desc": "Maximum of two signed 64-bit integer values.\n16.20. FLAT, Scratch and Global Instructions 581 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].i64;\nsrc = DATA.i64;\nMEM[ADDR].i64 = src > tmp ? src : tmp;\nRETURN_DATA.i64 = tmp", "notes": ""}, "flat_atomic_max_u64": {"desc": "Maximum of two unsigned 64-bit integer values.", "code": "tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = src > tmp ? src : tmp;\nRETURN_DATA.u64 = tmp", "notes": ""}, "flat_atomic_and_b64": {"desc": "Bitwise AND of register value and 64-bit memory value.", "code": "tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp & DATA.b64);\nRETURN_DATA.b64 = tmp", "notes": ""}, "flat_atomic_or_b64": {"desc": "Bitwise OR of register value and 64-bit memory value.", "code": "tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp | DATA.b64);\nRETURN_DATA.b64 = tmp", "notes": ""}, "flat_atomic_xor_b64": {"desc": "Bitwise XOR of register value and 64-bit memory value.", "code": "tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp ^ DATA.b64);\nRETURN_DATA.b64 = tmp", "notes": ""}, "flat_atomic_inc_u64": {"desc": "Increment 64-bit memory value with wraparound to zero when incremented to register value.\n16.20. FLAT, Scratch and Global Instructions 582 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = tmp >= src ? 0ULL : tmp + 1ULL;\nRETURN_DATA.u64 = tmp", "notes": ""}, "flat_atomic_dec_u64": {"desc": "Decrement 64-bit memory value with wraparound to register value when decremented below zero.", "code": "tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = ((tmp == 0ULL) || (tmp > src)) ? src : tmp - 1ULL;\nRETURN_DATA.u64 = tmp", "notes": ""}, "flat_atomic_cmpswap_f32": {"desc": "Compare and swap with floating-point memory value.", "code": "tmp = MEM[ADDR].f;\nsrc = DATA[31 : 0].f;\ncmp = DATA[63 : 32].f;\nMEM[ADDR].f = tmp == cmp ? src : tmp;\nRETURN_DATA.f = tmp", "notes": "Floating-point compare handles NAN/INF/denorm."}, "flat_atomic_min_f32": {"desc": "Minimum of two floating-point values.", "code": "tmp = MEM[ADDR].f;\nsrc = DATA.f;\nMEM[ADDR].f = src < tmp ? src : tmp;\nRETURN_DATA = tmp", "notes": "Floating-point compare handles NAN/INF/denorm."}, "flat_atomic_max_f32": {"desc": "16.20. FLAT, Scratch and Global Instructions 583 of 600\n\"RDNA3\" Instruction Set Architecture\nMaximum of two floating-point values.", "code": "tmp = MEM[ADDR].f;\nsrc = DATA.f;\nMEM[ADDR].f = src > tmp ? src : tmp;\nRETURN_DATA = tmp", "notes": "Floating-point compare handles NAN/INF/denorm."}, "flat_atomic_add_f32": {"desc": "Add data register to floating-point memory value.", "code": "tmp = MEM[ADDR].f;\nsrc = DATA.f;\nMEM[ADDR].f = src + tmp;\nRETURN_DATA.f = tmp", "notes": "Floating-point addition handles NAN/INF/denorm.\n16.20.2. Scratch Instructions\nScratch instructions are like Flat, but assume all work-item addresses fall in scratch (private) space."}, "scratch_load_u8": {"desc": "Untyped buffer load unsigned byte, zero extend in data register.", "code": "VDATA.u = 32'U({ 24'0, MEM[ADDR].u8 })", "notes": ""}, "scratch_load_i8": {"desc": "Untyped buffer load signed byte, sign extend in data register.\n16.20. FLAT, Scratch and Global Instructions 584 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "VDATA.i = 32'I(signext(MEM[ADDR].i8))", "notes": ""}, "scratch_load_u16": {"desc": "Untyped buffer load unsigned short, zero extend in data register.", "code": "VDATA.u = 32'U({ 16'0, MEM[ADDR].u16 })", "notes": ""}, "scratch_load_i16": {"desc": "Untyped buffer load signed short, sign extend in data register.", "code": "VDATA.i = 32'I(signext(MEM[ADDR].i16))", "notes": ""}, "scratch_load_b32": {"desc": "Untyped buffer load dword.", "code": "VDATA.b = MEM[ADDR].b", "notes": ""}, "scratch_load_b64": {"desc": "Untyped buffer load 2 dwords.", "code": "VDATA[31 : 0] = MEM[ADDR + 0U].b;\nVDATA[63 : 32] = MEM[ADDR + 4U].b", "notes": ""}, "scratch_load_b96": {"desc": "Untyped buffer load 3 dwords.\n16.20. FLAT, Scratch and Global Instructions 585 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "VDATA[31 : 0] = MEM[ADDR + 0U].b;\nVDATA[63 : 32] = MEM[ADDR + 4U].b;\nVDATA[95 : 64] = MEM[ADDR + 8U].b", "notes": ""}, "scratch_load_b128": {"desc": "Untyped buffer load 4 dwords.", "code": "VDATA[31 : 0] = MEM[ADDR + 0U].b;\nVDATA[63 : 32] = MEM[ADDR + 4U].b;\nVDATA[95 : 64] = MEM[ADDR + 8U].b;\nVDATA[127 : 96] = MEM[ADDR + 12U].b", "notes": ""}, "scratch_store_b8": {"desc": "Untyped buffer store byte.", "code": "MEM[ADDR].b8 = VDATA[7 : 0]", "notes": ""}, "scratch_store_b16": {"desc": "Untyped buffer store short.", "code": "MEM[ADDR].b16 = VDATA[15 : 0]", "notes": ""}, "scratch_store_b32": {"desc": "Untyped buffer store dword.", "code": "MEM[ADDR].b = VDATA[31 : 0]", "notes": ""}, "scratch_store_b64": {"desc": "Untyped buffer store 2 dwords.\n16.20. FLAT, Scratch and Global Instructions 586 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "MEM[ADDR + 0U].b = VDATA[31 : 0];\nMEM[ADDR + 4U].b = VDATA[63 : 32]", "notes": ""}, "scratch_store_b96": {"desc": "Untyped buffer store 3 dwords.", "code": "MEM[ADDR + 0U].b = VDATA[31 : 0];\nMEM[ADDR + 4U].b = VDATA[63 : 32];\nMEM[ADDR + 8U].b = VDATA[95 : 64]", "notes": ""}, "scratch_store_b128": {"desc": "Untyped buffer store 4 dwords.", "code": "MEM[ADDR + 0U].b = VDATA[31 : 0];\nMEM[ADDR + 4U].b = VDATA[63 : 32];\nMEM[ADDR + 8U].b = VDATA[95 : 64];\nMEM[ADDR + 12U].b = VDATA[127 : 96]", "notes": ""}, "scratch_load_d16_u8": {"desc": "Untyped buffer load unsigned byte, use low 16 bits of data register.", "code": "VDATA[15 : 0].u16 = 16'U({ 8'0, MEM[ADDR].u8 });\n// VDATA[31:16] is preserved.", "notes": ""}, "scratch_load_d16_i8": {"desc": "Untyped buffer load signed byte, use low 16 bits of data register.", "code": "VDATA[15 : 0].i16 = 16'I(signext(MEM[ADDR].i8));\n// VDATA[31:16] is preserved.", "notes": ""}, "scratch_load_d16_b16": {"desc": "Untyped buffer load short, use low 16 bits of data register.\n16.20. FLAT, Scratch and Global Instructions 587 of 600\n\"RDNA3\" Instruction Set Architecture", "code": "VDATA[15 : 0].b16 = MEM[ADDR].b16;\n// VDATA[31:16] is preserved.", "notes": ""}, "scratch_load_d16_hi_u8": {"desc": "Untyped buffer load unsigned byte, use high 16 bits of data register.", "code": "VDATA[31 : 16].u16 = 16'U({ 8'0, MEM[ADDR].u8 });\n// VDATA[15:0] is preserved.", "notes": ""}, "scratch_load_d16_hi_i8": {"desc": "Untyped buffer load signed byte, use high 16 bits of data register.", "code": "VDATA[31 : 16].i16 = 16'I(signext(MEM[ADDR].i8));\n// VDATA[15:0] is preserved.", "notes": ""}, "scratch_load_d16_hi_b16": {"desc": "Untyped buffer load short, use high 16 bits of data register.", "code": "VDATA[31 : 16].b16 = MEM[ADDR].b16;\n// VDATA[15:0] is preserved.", "notes": ""}, "scratch_store_d16_hi_b8": {"desc": "Untyped buffer store byte, use high 16 bits of data register.", "code": "MEM[ADDR].b8 = VDATA[23 : 16].b8", "notes": ""}, "scratch_store_d16_hi_b16": {"desc": "Untyped buffer store short, use high 16 bits of data register.\n16.20. FLAT, Scratch and Global Instructions 588 of 600", "code": "MEM[ADDR].b16 = VDATA[31 : 16].b16", "notes": ""}}